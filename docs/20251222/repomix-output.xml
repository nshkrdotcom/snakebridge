This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by â‹®---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by â‹®---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
autobridge-design/
  adapter-lifecycle.md
  agentic-system.md
  architecture.md
  implementation-roadmap.md
  interactive-development.md
  priority-libraries.md
  README.md
  type-mapping.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="autobridge-design/adapter-lifecycle.md">
# Adapter Lifecycle

## Overview

Every Python library adapter in AutoBridge follows a defined lifecycle, transitioning from unknown to fully optimized production wrapper. This document details each phase, transitions, and the artifacts produced.

---

## Lifecycle Phases

```mermaid
stateDiagram-v2
    [*] --> Unknown: Library not yet integrated
    
    Unknown --> Discovery: Developer requests library
    Discovery --> Learning: Initial config generated
    Learning --> Confident: Usage patterns stabilize
    Confident --> Frozen: Developer finalizes
    Frozen --> Production: Compiled & optimized
    
    Learning --> Learning: Refinements applied
    Confident --> Learning: Major pattern change
    Frozen --> Updating: Version change detected
    Updating --> Frozen: Compatible update
    Updating --> Learning: Breaking change
    
    Production --> Production: Stable operation
```

---

## Phase 1: Unknown

**State**: Library has never been used with AutoBridge.

**Artifacts**: None

**Triggers to Next**: 
```elixir
use AutoBridge, :sympy
# OR
AutoBridge.integrate("sympy")
```

---

## Phase 2: Discovery

**State**: AI agents are analyzing the Python library.

**Duration**: 1-30 seconds (depending on library size)

**Process**:
```mermaid
flowchart TD
    A[Library Name] --> B[Python Introspection]
    B --> C[Extract Classes]
    B --> D[Extract Functions]
    B --> E[Extract Types]
    B --> F[Extract Docstrings]
    
    C --> G[Schema Assembly]
    D --> G
    E --> G
    F --> G
    
    G --> H[Classification]
    H --> I{Known Archetype?}
    
    I -->|Yes| J[Apply Template]
    I -->|No| K[LLM Analysis]
    
    J --> L[Initial Config]
    K --> L
    
    L --> M[Generate Elixir Wrapper]
    M --> N[Learning Phase Begins]
```

**Artifacts Produced**:
```
priv/autobridge/learning/sympy/
â”œâ”€â”€ schema.json           # Full Python introspection
â”œâ”€â”€ classification.json   # Library category & archetype
â”œâ”€â”€ initial_config.exs    # Generated configuration
â””â”€â”€ wrapper.beam          # Runtime-compiled module
```

**Example Schema**:
```json
{
  "library": "sympy",
  "version": "1.13.1",
  "classification": "math_symbolic",
  "modules": [
    {
      "path": "sympy.core.symbol",
      "classes": [
        {
          "name": "Symbol",
          "bases": ["AtomicExpr"],
          "methods": [...],
          "constructor": {
            "args": ["name"],
            "kwargs": {"commutative": true}
          }
        }
      ],
      "functions": [
        {
          "name": "symbols",
          "signature": "(names, **kwargs) -> tuple",
          "docstring": "..."
        }
      ]
    }
  ]
}
```

**Transition**: Automatic to Learning phase once config is generated.

---

## Phase 3: Learning

**State**: Adapter is active, AI is observing usage patterns.

**Duration**: Variable (until confidence > 95% OR developer forces finalization)

**Signals**:
- Every function call is observed
- Type patterns are accumulated
- Error conditions are logged
- Performance is tracked

**Process**:
```mermaid
sequenceDiagram
    participant Dev as Developer
    participant AB as AutoBridge
    participant Obs as Observer
    participant Ref as Refiner
    
    loop Every Function Call
        Dev->>AB: SymPy.solve(expr, x)
        AB->>Obs: Record observation
        AB-->>Dev: {:ok, result}
        
        alt Threshold Reached
            Obs->>Ref: Analyze patterns
            Ref->>AB: Propose refinement
            AB->>Dev: Display suggestion
        end
    end
```

**Artifacts Updated**:
```
priv/autobridge/learning/sympy/
â”œâ”€â”€ observations.dets     # Persistent observation store
â”œâ”€â”€ patterns.json         # Detected usage patterns
â”œâ”€â”€ refinements.json      # Proposed improvements
â”œâ”€â”€ current_config.exs    # Updated configuration
â””â”€â”€ confidence.json       # Confidence metrics
```

**Refinement Proposal Example**:
```json
{
  "id": "ref_001",
  "type": "typespec",
  "target": "solve/2",
  "status": "pending",
  "proposed_at": "2024-12-22T10:30:00Z",
  "current": "@spec solve(term(), term()) :: {:ok, term()} | {:error, term()}",
  "proposed": "@spec solve(expression(), symbol()) :: {:ok, [expression()]} | {:error, solve_error()}",
  "rationale": "Observed 47 calls: 100% string expressions, 100% atom symbols, 95% list results",
  "confidence": 0.92,
  "observations_supporting": 47
}
```

**Developer Interaction**:
```elixir
iex> AutoBridge.status(:sympy)
%{
  phase: :learning,
  confidence: 0.73,
  observations: 124,
  pending_refinements: 3,
  time_in_phase: "2 days, 4 hours"
}

iex> AutoBridge.pending_refinements(:sympy)
[
  %{id: "ref_001", type: :typespec, target: "solve/2", confidence: 0.92},
  %{id: "ref_002", type: :default, target: "simplify/2", confidence: 0.87},
  %{id: "ref_003", type: :docstring, target: "expand/1", confidence: 0.78}
]

iex> AutoBridge.accept("ref_001")
:ok  # Typespec updated

iex> AutoBridge.reject("ref_002", reason: "I prefer explicit options")
:ok  # Refinement dismissed, learning continues

iex> AutoBridge.modify("ref_003", docstring: "Custom docstring here")
:ok  # Developer-provided override
```

**Confidence Calculation**:
```elixir
defmodule AutoBridge.Confidence do
  def calculate(library) do
    weights = %{
      observation_count: 0.3,
      type_consistency: 0.25,
      error_rate: 0.15,
      refinement_stability: 0.2,
      coverage: 0.1
    }
    
    scores = %{
      observation_count: min(observations(library) / 100, 1.0),
      type_consistency: type_consistency_score(library),
      error_rate: 1.0 - error_rate(library),
      refinement_stability: refinement_stability(library),
      coverage: function_coverage(library)
    }
    
    Enum.reduce(weights, 0, fn {key, weight}, acc ->
      acc + (scores[key] * weight)
    end)
  end
end
```

**Transition**: 
- â†’ Confident: When confidence > 0.95
- â†’ Learning: Stays until threshold OR manual intervention

---

## Phase 4: Confident

**State**: AI believes the adapter is stable and ready for finalization.

**Duration**: Until developer action

**Automatic Prompt**:
```
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ ðŸŽ¯ AutoBridge: sympy ready for finalization                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Confidence: 97.2%                                           â”‚
â”‚ Observations: 243                                           â”‚
â”‚ Refinements applied: 7                                      â”‚
â”‚ Functions covered: 23/28 (82%)                              â”‚
â”‚                                                             â”‚
â”‚ Run `AutoBridge.finalize(:sympy)` to:                       â”‚
â”‚ â€¢ Generate frozen configuration                             â”‚
â”‚ â€¢ Compile optimized wrapper                                 â”‚
â”‚ â€¢ Enable production mode                                    â”‚
â”‚                                                             â”‚
â”‚ Or continue using for more observations.                    â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

**Developer Options**:
```elixir
# Option 1: Finalize
AutoBridge.finalize(:sympy)

# Option 2: Continue learning with higher threshold
AutoBridge.configure(:sympy, confidence_threshold: 0.99)

# Option 3: Review before finalizing
AutoBridge.review(:sympy)  # Opens detailed report
```

**Transition**:
- â†’ Frozen: `AutoBridge.finalize(:library)`
- â†’ Learning: If usage patterns change significantly

---

## Phase 5: Frozen

**State**: Configuration is locked, adapter is production-ready.

**Process**:
```mermaid
flowchart TD
    A[Finalize Command] --> B[Validate Config]
    B --> C{Valid?}
    C -->|No| D[Return to Learning]
    C -->|Yes| E[Generate Tests]
    E --> F[Run Test Suite]
    F --> G{Tests Pass?}
    G -->|No| H[Report Issues]
    H --> D
    G -->|Yes| I[Freeze Configuration]
    I --> J[Compile Optimized Module]
    J --> K[Store in Frozen Registry]
    K --> L[Generate Documentation]
```

**Artifacts Produced**:
```
priv/autobridge/frozen/sympy-1.13/
â”œâ”€â”€ config.exs            # Frozen configuration
â”œâ”€â”€ schema.json           # Locked schema reference
â”œâ”€â”€ wrapper.ex            # Generated source (for reference)
â”œâ”€â”€ wrapper.beam          # Compiled optimized module
â”œâ”€â”€ types.ex              # Generated type definitions
â”œâ”€â”€ tests.exs             # Auto-generated test suite
â”œâ”€â”€ docs.md               # Generated documentation
â””â”€â”€ metadata.json         # Version, timestamps, etc.
```

**Frozen Config Example**:
```elixir
# priv/autobridge/frozen/sympy-1.13/config.exs
%AutoBridge.FrozenConfig{
  library: "sympy",
  version: "1.13.1",
  frozen_at: ~U[2024-12-22 15:30:00Z],
  confidence_at_freeze: 0.972,
  
  elixir_module: AutoBridge.SymPy,
  
  functions: [
    %{
      name: :symbols,
      python_path: "sympy.symbols",
      spec: "@spec symbols(String.t(), keyword()) :: {:ok, [atom()]}",
      defaults: %{cls: :symbol, commutative: true}
    },
    %{
      name: :solve,
      python_path: "sympy.solve",
      spec: "@spec solve(String.t() | expression(), atom()) :: {:ok, [term()]}",
      docs: "Solves the given equation for the specified variable."
    },
    # ... more functions
  ],
  
  types: [
    {:expression, "String.t() | map()"},
    {:symbol, "atom()"},
    {:solve_error, "{:error, :no_solution | :invalid_expression}"}
  ],
  
  options: %{
    timeout: 30_000,
    pool_size: 4,
    telemetry: true
  }
}
```

**Test Generation**:
```elixir
# priv/autobridge/frozen/sympy-1.13/tests.exs
defmodule AutoBridge.SymPyTest do
  use ExUnit.Case, async: true
  
  # Tests generated from observed successful calls
  
  describe "symbols/1" do
    test "creates symbols from string" do
      assert {:ok, symbols} = AutoBridge.SymPy.symbols("x y z")
      assert length(symbols) == 3
    end
  end
  
  describe "solve/2" do
    test "solves simple equation" do
      assert {:ok, solutions} = AutoBridge.SymPy.solve("x**2 - 1", :x)
      assert Enum.sort(solutions) == [-1, 1]
    end
    
    test "returns error for invalid expression" do
      assert {:error, _} = AutoBridge.SymPy.solve("invalid(((", :x)
    end
  end
end
```

---

## Phase 6: Production

**State**: Optimized wrapper in active use.

**Characteristics**:
- No observation overhead
- Compile-time optimized
- Full type checking (Dialyzer)
- Comprehensive documentation

**Usage**:
```elixir
# In production code
defmodule MyApp.MathEngine do
  alias AutoBridge.SymPy
  
  def solve_equation(expr, var) do
    SymPy.solve(expr, var)
  end
end
```

---

## Phase 7: Updating (Maintenance)

**State**: Maintainer agent detected version or API change.

**Triggers**:
- Python library version update
- API breaking change detected
- Deprecation warnings

**Process**:
```mermaid
flowchart TD
    A[Version Change Detected] --> B[Re-introspect Library]
    B --> C[Compare Schemas]
    C --> D{Change Type?}
    
    D -->|Additions Only| E[Propose Additions]
    E --> F[Developer Approval]
    F --> G[Update Frozen Config]
    
    D -->|Deprecations| H[Log Warnings]
    H --> G
    
    D -->|Breaking Changes| I[Alert Developer]
    I --> J{Accept Changes?}
    J -->|Yes| K[Return to Learning]
    J -->|No| L[Pin Old Version]
```

**Update Notification**:
```
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ âš ï¸  AutoBridge: sympy version change detected               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Current adapter: sympy 1.13.1                              â”‚
â”‚ Installed version: sympy 1.14.0                            â”‚
â”‚                                                             â”‚
â”‚ Changes detected:                                           â”‚
â”‚ â€¢ [ADDITION] sympy.simplify.radsimp() - new function       â”‚
â”‚ â€¢ [ADDITION] sympy.core.expr.Expr.rewrite() - new method   â”‚
â”‚ â€¢ [DEPRECATION] sympy.utilities.lambdify() - use sympy.lambdify â”‚
â”‚                                                             â”‚
â”‚ No breaking changes detected.                               â”‚
â”‚                                                             â”‚
â”‚ [u]pdate adapter  [i]gnore  [r]evert to 1.13               â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

---

## Lifecycle Storage Locations

```
priv/autobridge/
â”‚
â”œâ”€â”€ learning/                  # Phase 3: Active learning
â”‚   â”œâ”€â”€ sympy/
â”‚   â”‚   â”œâ”€â”€ schema.json
â”‚   â”‚   â”œâ”€â”€ observations.dets
â”‚   â”‚   â”œâ”€â”€ patterns.json
â”‚   â”‚   â”œâ”€â”€ refinements.json
â”‚   â”‚   â””â”€â”€ current_config.exs
â”‚   â””â”€â”€ pylatexenc/
â”‚       â””â”€â”€ ...
â”‚
â”œâ”€â”€ frozen/                    # Phase 5-6: Production
â”‚   â”œâ”€â”€ sympy-1.13/
â”‚   â”‚   â”œâ”€â”€ config.exs
â”‚   â”‚   â”œâ”€â”€ wrapper.beam
â”‚   â”‚   â”œâ”€â”€ tests.exs
â”‚   â”‚   â””â”€â”€ docs.md
â”‚   â””â”€â”€ pylatexenc-3.0/
â”‚       â””â”€â”€ ...
â”‚
â”œâ”€â”€ bundled/                   # Ships with AutoBridge
â”‚   â”œâ”€â”€ json.exs               # Built-in Python json
â”‚   â””â”€â”€ math.exs               # Built-in Python math
â”‚
â””â”€â”€ archive/                   # Old versions (for rollback)
    â””â”€â”€ sympy-1.12/
        â””â”€â”€ ...
```

---

## APIs for Lifecycle Management

```elixir
defmodule AutoBridge.Lifecycle do
  @doc "Get current phase of a library"
  def phase(library), do: ...
  
  @doc "Get detailed status"
  def status(library), do: ...
  
  @doc "Force transition (with safety checks)"
  def transition(library, to_phase), do: ...
  
  @doc "Reset to discovery phase"
  def reset(library), do: ...
  
  @doc "Export frozen config for sharing"
  def export(library, path), do: ...
  
  @doc "Import shared frozen config"
  def import(path), do: ...
  
  @doc "List all adapters by phase"
  def list_by_phase(phase), do: ...
end

# Usage Examples
AutoBridge.Lifecycle.phase(:sympy)
# => :learning

AutoBridge.Lifecycle.status(:sympy)
# => %{phase: :learning, confidence: 0.73, observations: 124, ...}

AutoBridge.Lifecycle.reset(:sympy)
# => :ok (clears all learning data, restarts discovery)

AutoBridge.Lifecycle.export(:sympy, "exports/sympy-adapter.zip")
# => :ok (creates portable adapter package)
```

---

## Best Practices

### For Rapid Finalization

1. **Focus usage on core functions** - Prioritize the functions you actually need
2. **Accept reasonable refinements** - Don't over-engineer early
3. **Use realistic data** - Pass real-world inputs during learning
4. **Review type proposals carefully** - Types are the most impactful refinements

### For Maximum Quality

1. **Let learning run longer** - More observations = better confidence
2. **Test edge cases** - Intentionally try unusual inputs
3. **Review generated tests** - Add custom tests if needed
4. **Document complex types** - Add custom type definitions

### For Team Sharing

1. **Export frozen adapters** - Share across team members
2. **Version lock Python libraries** - Consistent environments
3. **Include in version control** - `priv/autobridge/frozen/` should be committed
</file>

<file path="autobridge-design/agentic-system.md">
# AutoBridge Agentic System

## Overview

The AutoBridge agentic system is the "brain" that enables self-building, self-healing library integration. Unlike traditional static configuration systems, it uses AI agents that actively observe, learn, and propose improvements.

---

## Agent Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        AGENT ORCHESTRATOR                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                     Event Router & Scheduler                      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚              â”‚              â”‚               â”‚                 â”‚
â”‚         â–¼              â–¼              â–¼               â–¼                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ Discovery â”‚  â”‚ Observer  â”‚  â”‚  Refiner  â”‚  â”‚ Maintainer â”‚          â”‚
â”‚  â”‚   Agent   â”‚  â”‚   Agent   â”‚  â”‚   Agent   â”‚  â”‚   Agent    â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚       â”‚              â”‚              â”‚               â”‚                   â”‚
â”‚       â”‚         â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”         â”‚                   â”‚
â”‚       â”‚         â”‚ Pattern â”‚    â”‚   LLM   â”‚         â”‚                   â”‚
â”‚       â”‚         â”‚ Matcher â”‚    â”‚ Backend â”‚         â”‚                   â”‚
â”‚       â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                                              â”‚
        â–¼                                              â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ Python  â”‚                                   â”‚  PyPI /  â”‚
   â”‚ Runtime â”‚                                   â”‚ Versions â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## The Four Agents

### 1. Discovery Agent

**Purpose**: Transform unknown Python libraries into usable Elixir wrappers.

**Capabilities**:
- Deep Python introspection (classes, functions, signatures, docstrings)
- Library classification (math, text, ML, data, web, etc.)
- Archetype matching (known patterns â†’ config templates)
- Initial type mapping inference

**AI Integration**:
```elixir
defmodule AutoBridge.Agents.Discovery do
  @doc """
  The Discovery Agent uses a combination of heuristics and LLM
  for smart library analysis.
  """
  
  # Heuristic layer (fast, deterministic)
  defp classify_by_structure(schema) do
    cond do
      has_symbolic_types?(schema) -> :math_symbolic
      has_tensor_types?(schema) -> :ml_framework
      has_parser_patterns?(schema) -> :text_processing
      has_http_patterns?(schema) -> :web_client
      true -> :generic
    end
  end
  
  # LLM layer (smart, for edge cases)
  defp classify_with_llm(schema) do
    prompt = """
    Analyze this Python library schema and classify it:
    
    #{format_schema(schema)}
    
    Categories: math_symbolic, text_processing, ml_framework, 
                data_processing, web_client, generic
    
    Also identify:
    1. Primary use case
    2. Key exports to wrap
    3. Stateful vs stateless nature
    4. Recommended Elixir module structure
    """
    
    LLMBackend.complete(prompt)
  end
  
  # Combine approaches
  def classify(schema) do
    heuristic = classify_by_structure(schema)
    
    if heuristic == :generic do
      # Fall back to LLM for unknown patterns
      classify_with_llm(schema)
    else
      {:ok, heuristic}
    end
  end
end
```

**Discovery Process**:

```mermaid
flowchart TD
    A[Library Name] --> B{Known Bundled?}
    B -->|Yes| C[Use Bundled Config]
    B -->|No| D[Python Introspection]
    D --> E[Extract Schema]
    E --> F{Matches Archetype?}
    F -->|Yes| G[Apply Template]
    F -->|No| H[LLM Classification]
    H --> I[Generate Custom Config]
    G --> J[Initial Config Ready]
    I --> J
    J --> K[Create Learning Adapter]
```

---

### 2. Observer Agent

**Purpose**: Watch library usage at runtime and collect learning data.

**What It Observes**:
- Function calls (name, arguments, results)
- Argument types and patterns
- Return value types
- Error conditions
- Performance characteristics
- Usage frequency

**Data Collection**:
```elixir
defmodule AutoBridge.Agents.Observer do
  @observation_fields [
    :function_name,
    :module_path,
    :argument_types,
    :argument_values_sample,  # Anonymized samples
    :result_type,
    :result_shape,            # For collections/tensors
    :success,
    :error_type,
    :duration_microseconds,
    :timestamp
  ]
  
  def observe_call(library, function, args, result, metadata) do
    observation = %Observation{
      function_name: function,
      module_path: metadata.module,
      argument_types: Enum.map(args, &type_of/1),
      argument_values_sample: sample_values(args),
      result_type: type_of(result),
      result_shape: shape_of(result),
      success: success?(result),
      error_type: error_type(result),
      duration_microseconds: metadata.duration,
      timestamp: System.monotonic_time(:microsecond)
    }
    
    store_observation(library, observation)
  end
  
  defp type_of(value) do
    cond do
      is_binary(value) -> :string
      is_integer(value) -> :integer
      is_float(value) -> :float
      is_list(value) -> {:list, type_of(hd(value))}
      is_map(value) -> :map
      is_atom(value) -> :atom
      true -> :unknown
    end
  end
end
```

**Pattern Detection**:
```elixir
defmodule AutoBridge.Agents.Observer.PatternDetector do
  @doc """
  Analyzes accumulated observations to detect usage patterns.
  """
  
  def detect_patterns(observations) do
    [
      detect_type_patterns(observations),
      detect_argument_patterns(observations),
      detect_error_patterns(observations),
      detect_performance_patterns(observations)
    ]
    |> List.flatten()
    |> Enum.filter(&significant?/1)
  end
  
  defp detect_type_patterns(observations) do
    observations
    |> Enum.group_by(& &1.function_name)
    |> Enum.map(fn {func, obs} ->
      arg_types = obs |> Enum.map(& &1.argument_types) |> find_common_types()
      result_type = obs |> Enum.map(& &1.result_type) |> find_common_type()
      
      %TypePattern{
        function: func,
        argument_types: arg_types,
        result_type: result_type,
        confidence: calculate_confidence(obs)
      }
    end)
  end
  
  defp detect_argument_patterns(observations) do
    # Find common argument values that could become defaults
    # e.g., "most calls to solve() pass simplify: true"
  end
  
  defp detect_error_patterns(observations) do
    # Find common error conditions
    # e.g., "TypeError when passing integer to string arg"
  end
end
```

---

### 3. Refiner Agent

**Purpose**: Transform observations into actionable configuration improvements.

**Refinement Types**:

| Type | Description | Example |
|------|-------------|---------|
| `typespec` | Type specification updates | `@spec solve(String.t())` â†’ `@spec solve(expression())` |
| `default` | Add default argument values | `simplify \\ true` |
| `validation` | Input validation rules | `guard is_binary(expr)` |
| `docstring` | Documentation generation | Auto-generated from usage |
| `error_handling` | Error mapping | Python exceptions â†’ Elixir errors |
| `alias` | Function aliases | `simplify/1` also as `simp/1` |

**LLM-Powered Refinement**:
```elixir
defmodule AutoBridge.Agents.Refiner do
  @doc """
  Uses LLM to generate intelligent refinement proposals.
  """
  
  def propose_refinements(library, patterns) do
    # First, use heuristics for obvious refinements
    heuristic_refinements = patterns
    |> Enum.flat_map(&apply_heuristics/1)
    
    # Then, use LLM for nuanced suggestions
    llm_refinements = generate_llm_refinements(library, patterns)
    
    # Combine and deduplicate
    (heuristic_refinements ++ llm_refinements)
    |> Enum.uniq_by(& &1.target)
    |> Enum.sort_by(& &1.confidence, :desc)
  end
  
  defp generate_llm_refinements(library, patterns) do
    prompt = """
    I'm building an Elixir wrapper for the Python library "#{library}".
    
    Based on these observed usage patterns:
    #{format_patterns(patterns)}
    
    Current configuration:
    #{format_current_config(library)}
    
    Suggest improvements for:
    1. Type specifications (be specific about Elixir types)
    2. Default argument values
    3. Error handling strategies
    4. Documentation
    5. Any idiomatic Elixir patterns we should apply
    
    Format each suggestion as:
    - Type: [typespec|default|validation|docstring|error_handling]
    - Target: [function name]
    - Current: [current behavior]
    - Proposed: [proposed change]
    - Rationale: [why this helps]
    """
    
    response = LLMBackend.complete(prompt)
    parse_refinement_suggestions(response)
  end
end
```

**Confidence Scoring**:
```elixir
defmodule AutoBridge.Agents.Refiner.Confidence do
  @doc """
  Calculates confidence score for refinement proposals.
  
  Factors:
  - Number of supporting observations
  - Consistency of patterns
  - Type of refinement
  - Library maturity signals
  """
  
  def score(refinement, observations) do
    base_score = observation_support_score(refinement, observations)
    consistency = pattern_consistency_score(refinement, observations)
    type_weight = refinement_type_weight(refinement.type)
    
    # Weighted combination
    (base_score * 0.5 + consistency * 0.3) * type_weight
  end
  
  defp observation_support_score(refinement, observations) do
    relevant = Enum.filter(observations, &relevant?(&1, refinement))
    min(length(relevant) / 50, 1.0)  # Cap at 50 observations
  end
  
  defp pattern_consistency_score(refinement, observations) do
    # How consistent are the observations?
    # e.g., 95% of calls return string â†’ high consistency
  end
  
  defp refinement_type_weight(type) do
    case type do
      :typespec -> 1.0       # High confidence needed
      :default -> 0.9        # Medium-high
      :docstring -> 0.7      # Lower bar
      :validation -> 1.0     # High confidence needed
      _ -> 0.8
    end
  end
end
```

---

### 4. Maintainer Agent

**Purpose**: Keep adapters healthy over time as Python libraries evolve.

**Responsibilities**:
- Monitor library version updates
- Detect API changes
- Propose adapter updates
- Track deprecations

**Version Monitoring**:
```elixir
defmodule AutoBridge.Agents.Maintainer do
  use GenServer
  
  @check_interval :timer.hours(24)
  
  def handle_info(:version_check, state) do
    for {library, adapter} <- list_frozen_adapters() do
      current_version = get_installed_version(library)
      adapter_version = adapter.version_constraint
      
      cond do
        version_mismatch?(current_version, adapter_version) ->
          check_api_compatibility(library, adapter)
          
        newer_available?(library, current_version) ->
          notify_update_available(library, current_version)
          
        true ->
          :ok
      end
    end
    
    schedule_check(@check_interval)
    {:noreply, state}
  end
  
  defp check_api_compatibility(library, adapter) do
    # Re-introspect the library
    {:ok, current_schema} = AutoBridge.Agents.Discovery.introspect(library)
    
    # Compare with adapter's expected schema
    changes = diff_schemas(adapter.schema, current_schema)
    
    case categorize_changes(changes) do
      :compatible ->
        :ok
        
      {:additions, new_funcs} ->
        propose_additions(library, new_funcs)
        
      {:breaking, broken_funcs} ->
        alert_breaking_changes(library, broken_funcs)
        
      {:deprecations, deprecated} ->
        log_deprecations(library, deprecated)
    end
  end
end
```

---

## LLM Backend Integration

AutoBridge supports multiple LLM backends for AI operations:

```elixir
defmodule AutoBridge.LLMBackend do
  @moduledoc """
  Abstraction layer for LLM operations.
  
  Supports:
  - Local models (Ollama, llama.cpp)
  - OpenAI API
  - Anthropic API
  - Custom endpoints
  """
  
  @callback complete(prompt :: String.t(), opts :: keyword()) :: {:ok, String.t()} | {:error, term()}
  @callback embed(text :: String.t()) :: {:ok, [float()]} | {:error, term()}
  
  def complete(prompt, opts \\ []) do
    backend = get_configured_backend()
    backend.complete(prompt, opts)
  end
  
  # Implementations
  defmodule Ollama do
    @behaviour AutoBridge.LLMBackend
    
    def complete(prompt, opts) do
      model = Keyword.get(opts, :model, "codellama")
      # Call local Ollama instance
    end
  end
  
  defmodule OpenAI do
    @behaviour AutoBridge.LLMBackend
    
    def complete(prompt, opts) do
      model = Keyword.get(opts, :model, "gpt-4")
      # Call OpenAI API
    end
  end
end
```

**Configuration**:
```elixir
# config/config.exs
config :autobridge,
  llm_backend: AutoBridge.LLMBackend.Ollama,
  llm_model: "codellama:13b",
  llm_temperature: 0.3,  # Lower for more deterministic
  
  # OR for cloud
  llm_backend: AutoBridge.LLMBackend.OpenAI,
  llm_api_key: System.get_env("OPENAI_API_KEY")
```

---

## Event System

Agents communicate through a central event bus:

```elixir
defmodule AutoBridge.Events do
  @moduledoc """
  Event system for agent coordination.
  """
  
  @events [
    # Discovery events
    :library_discovered,
    :schema_extracted,
    :config_generated,
    
    # Observation events
    :function_called,
    :error_occurred,
    :pattern_detected,
    
    # Refinement events
    :refinement_proposed,
    :refinement_accepted,
    :refinement_rejected,
    
    # Maintenance events
    :version_changed,
    :api_changed,
    :deprecation_detected,
    
    # Lifecycle events
    :learning_started,
    :confidence_threshold_reached,
    :adapter_finalized
  ]
  
  def emit(event, payload) do
    Phoenix.PubSub.broadcast(AutoBridge.PubSub, "agents", {event, payload})
  end
  
  def subscribe do
    Phoenix.PubSub.subscribe(AutoBridge.PubSub, "agents")
  end
end
```

---

## Learning State Machine

Each library adapter follows a state machine:

```mermaid
stateDiagram-v2
    [*] --> Undiscovered
    
    Undiscovered --> Discovering: use AutoBridge, :library
    Discovering --> Learning: schema extracted
    Discovering --> Failed: introspection error
    
    Learning --> Learning: observation
    Learning --> Learning: refinement accepted
    Learning --> Confident: confidence > 95%
    
    Confident --> Finalizing: finalize command
    Confident --> Learning: major change detected
    
    Finalizing --> Frozen: validation passed
    Finalizing --> Learning: validation failed
    
    Frozen --> Updating: version change
    Updating --> Frozen: update applied
    Updating --> Learning: breaking change
    
    Failed --> Discovering: retry
```

**State Storage**:
```elixir
defmodule AutoBridge.AdapterState do
  defstruct [
    :library,
    :state,           # :undiscovered, :discovering, :learning, etc.
    :schema,
    :config,
    :observations,
    :patterns,
    :refinements,
    :confidence,
    :version,
    :created_at,
    :updated_at
  ]
  
  def transition(adapter, event) do
    case {adapter.state, event} do
      {:undiscovered, :discover} -> {:discovering, start_discovery(adapter)}
      {:discovering, {:schema, schema}} -> {:learning, init_learning(adapter, schema)}
      {:learning, {:observation, obs}} -> {:learning, add_observation(adapter, obs)}
      {:learning, {:confidence, c}} when c > 0.95 -> {:confident, adapter}
      {:confident, :finalize} -> {:finalizing, start_finalization(adapter)}
      {:finalizing, :validated} -> {:frozen, freeze(adapter)}
      _ -> {:error, :invalid_transition}
    end
  end
end
```

---

## Observability

### Telemetry Events

```elixir
# All agent actions emit telemetry
:telemetry.execute(
  [:autobridge, :agent, :discovery, :complete],
  %{duration: duration},
  %{library: library, functions_found: count}
)

:telemetry.execute(
  [:autobridge, :agent, :observer, :pattern_detected],
  %{count: 1},
  %{library: library, pattern_type: type}
)

:telemetry.execute(
  [:autobridge, :agent, :refiner, :proposal],
  %{confidence: confidence},
  %{library: library, refinement_type: type}
)
```

### Metrics Dashboard

```elixir
defmodule AutoBridge.Metrics do
  def library_status(library) do
    %{
      state: get_state(library),
      confidence: get_confidence(library),
      observations: count_observations(library),
      pending_refinements: count_pending(library),
      last_activity: get_last_activity(library),
      time_in_learning: calculate_learning_time(library)
    }
  end
  
  def system_health do
    %{
      active_learnings: count_learning_adapters(),
      frozen_adapters: count_frozen_adapters(),
      pending_updates: count_pending_updates(),
      llm_quota_remaining: get_llm_quota(),
      agent_health: check_agent_health()
    }
  end
end
```

---

## Privacy & Safety

### Data Handling

```elixir
defmodule AutoBridge.Privacy do
  @doc """
  All observation data is processed locally by default.
  No external transmission without explicit consent.
  """
  
  # Argument values are sampled and anonymized
  def anonymize_sample(value) when is_binary(value) do
    cond do
      looks_like_api_key?(value) -> "[REDACTED]"
      String.length(value) > 100 -> String.slice(value, 0, 50) <> "..."
      true -> value
    end
  end
  
  def looks_like_api_key?(value) do
    # Detect common API key patterns
    String.match?(value, ~r/^(sk-|pk_|api_|key_)/)
  end
end
```

### AI Safety

```elixir
defmodule AutoBridge.Safety do
  @doc """
  All AI-generated code goes through safety checks.
  """
  
  def validate_generated_code(code) do
    checks = [
      &no_system_calls?/1,
      &no_file_writes?/1,
      &no_network_calls?/1,
      &valid_elixir_syntax?/1,
      &no_code_injection?/1
    ]
    
    Enum.all?(checks, & &1.(code))
  end
  
  defp no_system_calls?(code) do
    not String.contains?(code, ["System.cmd", "Port.open", ":os.cmd"])
  end
end
```

---

## Future: Multi-Agent Collaboration

Vision for advanced scenarios:

```mermaid
graph TB
    subgraph "Library A Agent Cluster"
        DA1[Discovery]
        OA1[Observer]
        RA1[Refiner]
    end
    
    subgraph "Library B Agent Cluster"
        DA2[Discovery]
        OA2[Observer]
        RA2[Refiner]
    end
    
    subgraph "Meta Agent"
        MA[Cross-Library Learner]
    end
    
    OA1 --> MA
    OA2 --> MA
    MA --> RA1
    MA --> RA2
    
    Note[Meta Agent learns patterns across libraries]
```

The Meta Agent could:
- Learn that "math libraries usually need Expr type handling"
- Apply lessons from SymPy to other symbolic math libraries
- Detect common Python patterns and pre-generate templates
</file>

<file path="autobridge-design/architecture.md">
# AutoBridge Architecture

## System Overview

AutoBridge extends SnakeBridge with an intelligent layer that automates library integration through AI-driven discovery, observation, and refinement.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           AUTOBRIDGE SYSTEM                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    7. AGENTIC ORCHESTRATOR                           â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚  Discovery  â”‚  â”‚   Learning   â”‚  â”‚ Refinement  â”‚  â”‚ Mainten.  â”‚  â”‚   â”‚
â”‚  â”‚  â”‚    Agent    â”‚  â”‚   Observer   â”‚  â”‚    Agent    â”‚  â”‚  Monitor  â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                    â–²                                        â”‚
â”‚                                    â”‚ Events                                 â”‚
â”‚                                    â–¼                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    6. INTERACTIVE DEV SHELL                          â”‚   â”‚
â”‚  â”‚  â€¢ Real-time refinement proposals  â€¢ Accept/reject UI                â”‚   â”‚
â”‚  â”‚  â€¢ Confidence metrics display      â€¢ Finalization workflow           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                    â–²                                        â”‚
â”‚                                    â”‚                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    5. ADAPTER REGISTRY                               â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚   â”‚
â”‚  â”‚  â”‚   Learning   â”‚  â”‚   Frozen     â”‚  â”‚   Bundled    â”‚               â”‚   â”‚
â”‚  â”‚  â”‚   Adapters   â”‚  â”‚   Adapters   â”‚  â”‚   Adapters   â”‚               â”‚   â”‚
â”‚  â”‚  â”‚  (per-user)  â”‚  â”‚  (finalized) â”‚  â”‚ (with lib)   â”‚               â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                    â–²                                        â”‚
â”‚                                    â”‚                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     SNAKEBRIDGE CORE (Existing)                             â”‚
â”‚                                    â”‚                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    4. CODE GENERATION ENGINE                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    3. SCHEMA & TYPE SYSTEM                           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    2. DISCOVERY & INTROSPECTION                      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    1. EXECUTION RUNTIME (Snakepit)                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Layer Descriptions

### Layer 1-4: SnakeBridge Core (Existing)

These layers remain unchanged from SnakeBridge:

| Layer | Purpose |
|-------|---------|
| **1. Execution Runtime** | Snakepit-based Python orchestration, gRPC, sessions |
| **2. Discovery** | Python introspection, schema extraction |
| **3. Schema & Types** | Type mapping, caching, inference |
| **4. Code Generation** | Macro-based Elixir module generation |

### Layer 5: Adapter Registry (New)

Manages three tiers of adapters:

```elixir
defmodule AutoBridge.AdapterRegistry do
  @moduledoc """
  Central registry for all Python library adapters.
  
  Adapter Tiers:
  - :learning  - Active observation, per-user, mutable
  - :frozen    - Finalized, shared, immutable
  - :bundled   - Ships with AutoBridge or Python library
  """
  
  defstruct [
    :library_name,
    :tier,
    :config,
    :confidence,
    :observations,
    :last_updated,
    :version_constraints
  ]
  
  # Resolution order: bundled > frozen > learning > generate_new
  def resolve(library_name) do
    case lookup_bundled(library_name) do
      {:ok, adapter} -> {:bundled, adapter}
      :not_found ->
        case lookup_frozen(library_name) do
          {:ok, adapter} -> {:frozen, adapter}
          :not_found ->
            case lookup_learning(library_name) do
              {:ok, adapter} -> {:learning, adapter}
              :not_found -> {:generate, library_name}
            end
        end
    end
  end
end
```

**Adapter Storage Locations:**

```
priv/autobridge/
â”œâ”€â”€ bundled/           # Ships with AutoBridge (sympy.exs, etc.)
â”œâ”€â”€ frozen/            # User-finalized adapters
â”‚   â”œâ”€â”€ sympy-1.13.exs
â”‚   â””â”€â”€ numpy-2.0.exs
â””â”€â”€ learning/          # Active learning state
    â””â”€â”€ custom_lib.state
```

### Layer 6: Interactive Dev Shell (New)

Integrates with IEx to provide real-time feedback during development:

```elixir
defmodule AutoBridge.DevShell do
  @moduledoc """
  IEx integration for interactive adapter refinement.
  """
  
  def install do
    # Hooks into IEx.pry for observation
    # Displays refinement proposals in shell
    # Provides commands: AutoBridge.accept/2, AutoBridge.reject/2, etc.
  end
  
  def display_status(library) do
    # Shows current learning state, confidence, pending proposals
  end
  
  def propose_refinement(library, refinement) do
    # AI-generated suggestion displayed to developer
    # Developer can accept, reject, or modify
  end
end
```

**Example Shell Session:**

```
iex> AutoBridge.SymPy.expand("(x+1)**3")
{:ok, "x**3 + 3*x**2 + 3*x + 1"}

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ ðŸ§  AutoBridge Suggestion                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Library: sympy (learning mode, 67% confident)              â”‚
â”‚                                                             â”‚
â”‚ Observation: expand/1 always returns string expression     â”‚
â”‚                                                             â”‚
â”‚ Proposed refinement:                                        â”‚
â”‚   @spec expand(String.t()) :: {:ok, String.t()}            â”‚
â”‚                                                             â”‚
â”‚ [a]ccept  [r]eject  [m]odify  [i]gnore                     â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

### Layer 7: Agentic Orchestrator (New)

The brain of AutoBridgeâ€”coordinates AI agents for discovery, observation, and refinement.

```elixir
defmodule AutoBridge.AgenticOrchestrator do
  use GenServer
  
  @agents [
    AutoBridge.Agents.Discovery,      # Initial library introspection
    AutoBridge.Agents.Observer,       # Runtime usage pattern detection
    AutoBridge.Agents.Refiner,        # Configuration improvement proposals
    AutoBridge.Agents.Maintainer      # Version monitoring, update detection
  ]
  
  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end
  
  def init(_opts) do
    state = %{
      active_learnings: %{},
      agent_states: initialize_agents(@agents),
      event_queue: :queue.new()
    }
    {:ok, state}
  end
  
  # Events from library usage flow here
  def handle_cast({:observation, library, event}, state) do
    # Route to Observer agent
    # Accumulate patterns
    # Trigger Refiner when threshold reached
    {:noreply, process_observation(state, library, event)}
  end
end
```

---

## Data Flow

### Discovery Flow

```mermaid
sequenceDiagram
    participant Dev as Developer
    participant AB as AutoBridge
    participant DA as Discovery Agent
    participant Py as Python (Snakepit)
    
    Dev->>AB: use AutoBridge, :sympy
    AB->>AB: Check registry (not found)
    AB->>DA: Initiate discovery
    DA->>Py: Introspect "sympy"
    Py-->>DA: Module schema
    DA->>DA: Apply heuristics
    DA->>DA: Generate initial config
    DA->>AB: Learning adapter created
    AB-->>Dev: Module ready (learning mode)
```

### Learning Flow

```mermaid
sequenceDiagram
    participant Dev as Developer
    participant AB as AutoBridge
    participant Obs as Observer Agent
    participant Ref as Refiner Agent
    participant Shell as Dev Shell
    
    Dev->>AB: SymPy.solve(expr, var)
    AB->>Obs: Log observation
    AB-->>Dev: {:ok, result}
    
    Note over Obs: Accumulates patterns
    
    Obs->>Ref: Pattern threshold reached
    Ref->>Ref: Analyze patterns
    Ref->>Ref: Generate refinement proposal
    Ref->>Shell: Display proposal
    Shell-->>Dev: "Suggested: add typespec..."
    
    Dev->>Shell: accept
    Shell->>AB: Apply refinement
    AB->>AB: Update adapter config
    AB->>AB: Recalculate confidence
```

### Finalization Flow

```mermaid
sequenceDiagram
    participant Dev as Developer
    participant AB as AutoBridge
    participant Reg as Registry
    
    Note over AB: Confidence > 95%
    
    AB->>Dev: "Suggest finalization?"
    Dev->>AB: AutoBridge.finalize(:sympy)
    AB->>AB: Validate config completeness
    AB->>AB: Run test generation
    AB->>Reg: Store frozen adapter
    AB->>AB: Compile optimized module
    AB-->>Dev: "sympy frozen, production-ready"
```

---

## Component Deep Dive

### Discovery Agent

Responsible for initial library analysis:

```elixir
defmodule AutoBridge.Agents.Discovery do
  @moduledoc """
  AI agent for Python library discovery and initial config generation.
  """
  
  defstruct [:library, :schema, :heuristics_applied, :initial_config]
  
  @doc """
  Discovers a Python library and generates initial configuration.
  
  Process:
  1. Deep introspection via Snakepit
  2. Classification (math, text, ML, data, etc.)
  3. Pattern matching against known library archetypes
  4. Heuristic-based config generation
  5. Initial type mapping
  """
  def discover(library_name) do
    with {:ok, schema} <- introspect(library_name),
         {:ok, classification} <- classify(schema),
         {:ok, archetype} <- match_archetype(classification),
         {:ok, config} <- generate_config(schema, archetype) do
      {:ok, %__MODULE__{
        library: library_name,
        schema: schema,
        heuristics_applied: archetype.heuristics,
        initial_config: config
      }}
    end
  end
  
  defp classify(schema) do
    # AI/heuristic classification
    # Returns: :math_symbolic, :text_processing, :ml_framework, etc.
  end
  
  defp match_archetype(classification) do
    # Match to predefined archetypes with config templates
  end
end
```

### Observer Agent

Watches library usage at runtime:

```elixir
defmodule AutoBridge.Agents.Observer do
  @moduledoc """
  Observes library usage patterns and accumulates learning data.
  """
  
  use GenServer
  
  defstruct [
    :library,
    :observations,
    :pattern_counts,
    :type_evidence,
    :error_patterns
  ]
  
  @doc """
  Records a function call observation.
  """
  def observe(library, function, args, result, duration) do
    observation = %{
      function: function,
      arg_types: infer_types(args),
      result_type: infer_type(result),
      success: match?({:ok, _}, result),
      duration_us: duration,
      timestamp: System.monotonic_time()
    }
    
    GenServer.cast(__MODULE__, {:observe, library, observation})
  end
  
  def handle_cast({:observe, library, obs}, state) do
    new_state = state
    |> update_pattern_counts(library, obs)
    |> update_type_evidence(library, obs)
    |> maybe_trigger_refinement(library)
    
    {:noreply, new_state}
  end
  
  defp maybe_trigger_refinement(state, library) do
    if observation_threshold_reached?(state, library) do
      AutoBridge.Agents.Refiner.analyze(library, state.observations[library])
    end
    state
  end
end
```

### Refiner Agent

Proposes configuration improvements:

```elixir
defmodule AutoBridge.Agents.Refiner do
  @moduledoc """
  Analyzes observations and proposes configuration refinements.
  
  This agent uses AI/LLM to generate intelligent refinement proposals
  based on accumulated usage patterns.
  """
  
  @refinement_types [
    :typespec,           # Update type specifications
    :default_value,      # Add sensible defaults
    :error_handling,     # Improve error handling
    :doc_string,         # Generate documentation
    :validation,         # Add input validation
    :optimization        # Performance hints
  ]
  
  def analyze(library, observations) do
    patterns = extract_patterns(observations)
    
    refinements = for type <- @refinement_types,
                      refinement = propose(type, patterns),
                      refinement != nil do
      refinement
    end
    
    # Send to DevShell for developer review
    AutoBridge.DevShell.propose_refinements(library, refinements)
  end
  
  defp propose(:typespec, patterns) do
    # Analyze type evidence to propose better typespecs
    # Uses statistical analysis of observed types
  end
  
  defp propose(:default_value, patterns) do
    # Identify commonly used argument values
    # Propose as defaults
  end
end
```

### Maintainer Agent

Monitors library versions and API changes:

```elixir
defmodule AutoBridge.Agents.Maintainer do
  @moduledoc """
  Background agent that monitors Python library versions
  and detects API changes that require adapter updates.
  """
  
  use GenServer
  
  @check_interval :timer.hours(24)
  
  def init(state) do
    schedule_check()
    {:ok, state}
  end
  
  def handle_info(:check_versions, state) do
    for {library, adapter} <- frozen_adapters() do
      case check_compatibility(library, adapter) do
        :compatible -> 
          :ok
        {:incompatible, changes} -> 
          notify_and_propose_update(library, changes)
        {:new_version, version} ->
          log_new_version(library, version)
      end
    end
    
    schedule_check()
    {:noreply, state}
  end
  
  defp check_compatibility(library, adapter) do
    # Introspect current library version
    # Compare against adapter's expected schema
    # Identify breaking changes
  end
end
```

---

## Configuration Hierarchy

AutoBridge uses a layered configuration system:

```
Priority (highest to lowest):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. User Overrides (runtime)                â”‚  AutoBridge.configure(:sympy, ...)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 2. Project Config (config/autobridge.exs)  â”‚  Project-specific settings
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 3. Frozen Adapter (priv/autobridge/frozen/)â”‚  Finalized from learning
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 4. Bundled Adapter (with AutoBridge)       â”‚  Ships with library
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 5. Library Metadata (pyproject.toml)       â”‚  Python package hints
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 6. AI-Generated (discovery)                â”‚  Heuristic defaults
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Integration Points

### With SnakeBridge

AutoBridge is an extension, not a replacement:

```elixir
defmodule AutoBridge do
  @moduledoc """
  AutoBridge extends SnakeBridge with AI-driven adapter management.
  """
  
  # All existing SnakeBridge functionality available
  defdelegate discover(module), to: SnakeBridge
  defdelegate generate(config), to: SnakeBridge
  
  # New AutoBridge functionality
  def auto_integrate(library_name, opts \\ [])
  def status(library_name)
  def accept_refinement(library_name, refinement_id)
  def reject_refinement(library_name, refinement_id)
  def finalize(library_name)
end
```

### With Python Libraries

Libraries can optionally include AutoBridge hints:

```toml
# pyproject.toml in a Python library
[tool.autobridge]
category = "math_symbolic"
primary_exports = ["solve", "simplify", "expand"]
type_hints_complete = true
elixir_module_prefix = "MyMath"

[tool.autobridge.type_overrides]
"sympy.core.expr.Expr" = "any"
```

---

## Security Considerations

### Code Generation Safety

- All generated code is sandboxed
- No arbitrary code execution from Python
- Type validation on all cross-boundary calls

### AI Agent Boundaries

- Agents can propose, never execute without approval
- All refinements go through developer review
- No external network calls from agents (except version check)

### Data Privacy

- Learning data stays local
- No telemetry without explicit opt-in
- Frozen adapters can be shared selectively
</file>

<file path="autobridge-design/implementation-roadmap.md">
# Implementation Roadmap

## Overview

This roadmap outlines the phased development of AutoBridge, from core infrastructure through production readiness.

---

## Phase 0: Foundation (4-6 weeks)

### Goals
- Extend SnakeBridge with AutoBridge module structure
- Implement basic adapter registry
- Set up observation infrastructure

### Deliverables

#### 0.1 Module Structure
```
lib/autobridge/
â”œâ”€â”€ autobridge.ex              # Main API
â”œâ”€â”€ adapter_registry.ex        # Adapter storage/lookup
â”œâ”€â”€ observer.ex                # Call observation
â”œâ”€â”€ config.ex                  # Configuration
â””â”€â”€ types.ex                   # Type definitions
```

#### 0.2 Basic Registry
```elixir
defmodule AutoBridge.AdapterRegistry do
  def register(library, config)
  def lookup(library)
  def list_all()
  def update(library, updates)
end
```

#### 0.3 Observation System
```elixir
defmodule AutoBridge.Observer do
  def observe(library, function, args, result)
  def get_observations(library)
  def clear(library)
end
```

### Verification
- Unit tests for registry CRUD
- Integration test: observe calls, retrieve observations

---

## Phase 1: Discovery Agent (3-4 weeks)

### Goals
- Automatic Python library introspection
- Library classification heuristics
- Initial config generation

### Deliverables

#### 1.1 Enhanced Discovery
```elixir
defmodule AutoBridge.Agents.Discovery do
  def discover(library_name)
  def introspect(library_name)
  def classify(schema)
  def generate_config(schema, classification)
end
```

#### 1.2 Classification System
```elixir
@archetypes [
  :math_symbolic,    # SymPy-like
  :text_processing,  # pylatexenc-like
  :data_processing,  # pandas-like
  :ml_framework,     # torch-like
  :generic           # fallback
]
```

#### 1.3 Config Templates
```
priv/autobridge/templates/
â”œâ”€â”€ math_symbolic.exs
â”œâ”€â”€ text_processing.exs
â””â”€â”€ generic.exs
```

### Verification
- Discover SymPy â†’ generates valid config
- Discover pylatexenc â†’ correct classification
- Generated configs compile without error

---

## Phase 2: Learning System (4-5 weeks)

### Goals
- Pattern detection from observations
- Confidence scoring
- Basic refinement proposals

### Deliverables

#### 2.1 Pattern Detector
```elixir
defmodule AutoBridge.Agents.Observer.PatternDetector do
  def detect_type_patterns(observations)
  def detect_argument_patterns(observations)
  def detect_error_patterns(observations)
end
```

#### 2.2 Confidence Scoring
```elixir
defmodule AutoBridge.Confidence do
  def calculate(library)
  def breakdown(library)
  # Returns: 0.0 - 1.0
end
```

#### 2.3 Refinement Proposals
```elixir
defmodule AutoBridge.Agents.Refiner do
  def propose(:typespec, patterns)
  def propose(:default, patterns)
  def propose(:docstring, patterns)
end
```

### Verification
- 50 observations â†’ patterns detected
- Confidence increases with observations
- Refinement proposals are valid Elixir

---

## Phase 3: Interactive DevShell (3-4 weeks)

### Goals
- IEx integration
- Real-time refinement UI
- Accept/reject workflow

### Deliverables

#### 3.1 DevShell Module
```elixir
defmodule AutoBridge.DevShell do
  def install()
  def display_proposal(proposal)
  def handle_input(input)
end
```

#### 3.2 Status Display
```elixir
def status(library)
def pending(library)
def review(library, refinement_id)
```

#### 3.3 Actions
```elixir
def accept(refinement_id)
def reject(refinement_id)
def modify(refinement_id, changes)
def accept_all(library, opts)
```

### Verification
- DevShell installs in IEx
- Proposals display correctly
- Accept/reject modifies config

---

## Phase 4: LLM Integration (3-4 weeks)

### Goals
- LLM backend abstraction
- Smart classification with fallback
- Intelligent refinement generation

### Deliverables

#### 4.1 LLM Backend
```elixir
defmodule AutoBridge.LLMBackend do
  @callback complete(prompt, opts) :: {:ok, String.t()}
end

defmodule AutoBridge.LLMBackend.Ollama do
  @behaviour AutoBridge.LLMBackend
end

defmodule AutoBridge.LLMBackend.OpenAI do
  @behaviour AutoBridge.LLMBackend
end
```

#### 4.2 AI-Enhanced Discovery
```elixir
def classify_with_llm(schema)
def generate_refinements_with_llm(patterns)
```

### Verification
- Ollama backend: local model responds
- OpenAI backend: API integration works
- LLM-generated configs are valid

---

## Phase 5: Finalization & Production (4-5 weeks)

### Goals
- Finalization workflow
- Test generation
- Optimized compilation

### Deliverables

#### 5.1 Finalization
```elixir
defmodule AutoBridge.Lifecycle do
  def finalize(library)
  def validate(library)
  def freeze(library)
end
```

#### 5.2 Test Generation
```elixir
defmodule AutoBridge.TestGenerator do
  def generate_from_observations(library)
  def run_test_suite(library)
end
```

#### 5.3 Production Module
```elixir
defmodule AutoBridge.Compiler do
  def compile_frozen(library)
  def optimize(module)
end
```

### Verification
- Finalization produces frozen config
- Generated tests pass
- Compiled module works in production

---

## Phase 6: Priority Libraries (6-8 weeks)

### Goals
- Complete integration for SymPy, pylatexenc, Math-Verify
- Bundled adapters
- Documentation

### Deliverables

#### 6.1 SymPy Adapter
```
priv/autobridge/bundled/sympy.exs
lib/autobridge/bundled/sympy.ex
test/autobridge/sympy_test.exs
```

#### 6.2 pylatexenc Adapter
```
priv/autobridge/bundled/pylatexenc.exs
lib/autobridge/bundled/pylatexenc.ex
```

#### 6.3 Math-Verify Adapter
```
priv/autobridge/bundled/math_verify.exs
lib/autobridge/bundled/math_verify.ex
```

### Verification
- All three libraries work end-to-end
- Pipeline example from priority-libraries.md works
- Benchmarks: < 5% overhead

---

## Phase 7: Maintenance Agent (3-4 weeks)

### Goals
- Version monitoring
- API change detection
- Update proposals

### Deliverables

#### 7.1 Maintainer Agent
```elixir
defmodule AutoBridge.Agents.Maintainer do
  def check_versions()
  def detect_changes(library)
  def propose_updates(library, changes)
end
```

### Verification
- Detects version changes
- Identifies breaking changes
- Proposes valid updates

---

## Timeline Summary

```
Phase 0: Foundation          [Week 1-6]      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Phase 1: Discovery Agent     [Week 7-10]         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Phase 2: Learning System     [Week 11-15]            â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Phase 3: Interactive Dev     [Week 16-19]                â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Phase 4: LLM Integration     [Week 20-23]                    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Phase 5: Finalization        [Week 24-28]                        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Phase 6: Priority Libraries  [Week 29-36]                            â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Phase 7: Maintenance         [Week 37-40]                                    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

Total: ~40 weeks to production-ready with bundled adapters
```

---

## Milestones

| Milestone | Target | Criteria |
|-----------|--------|----------|
| **M1: Observable** | Week 6 | Can observe function calls, store in registry |
| **M2: Discoverable** | Week 10 | Can auto-discover and classify libraries |
| **M3: Learnable** | Week 15 | Confidence scoring, pattern detection working |
| **M4: Interactive** | Week 19 | DevShell refinement workflow complete |
| **M5: Intelligent** | Week 23 | LLM-powered discovery and refinement |
| **M6: Finalizable** | Week 28 | Full lifecycle: discovery â†’ frozen â†’ production |
| **M7: Libraries** | Week 36 | SymPy, pylatexenc, Math-Verify bundled |
| **M8: Maintainable** | Week 40 | Version monitoring, update proposals |

---

## Risk Mitigation

| Risk | Impact | Mitigation |
|------|--------|------------|
| LLM latency | Slow discovery | Cache results, async proposals |
| Python API changes | Broken adapters | Maintainer agent, version pinning |
| Complex type mapping | Dialyzer errors | Gradual types, escape hatches |
| Large library APIs | Overwhelm | Focus mode, subset selection |

---

## Success Metrics

### Quantitative

- **Discovery time**: < 30 seconds for average library
- **Finalization time**: < 100 observations typically
- **Runtime overhead**: < 5% vs direct Snakepit
- **Config accuracy**: > 95% of functions work without modification

### Qualitative

- Developer experience feels like collaboration
- Zero manual config for priority libraries
- Adapters stay current with library updates
</file>

<file path="autobridge-design/interactive-development.md">
# Interactive Development Experience

## Core Principle

AutoBridge transforms library integration from "configure then use" to "use and refine together". The AI observes your patterns and proposes improvements inline.

---

## IEx Integration

### Installation

```elixir
# In .iex.exs or manually:
iex> AutoBridge.DevShell.install()
AutoBridge DevShell activated ðŸðŸŒ‰
```

### Discovery

```elixir
iex> use AutoBridge, :sympy

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ ðŸ” Discovering sympy...                                     â”‚
â”‚ Found: 847 functions, 124 classes                          â”‚
â”‚ âœ“ AutoBridge.SymPy ready (learning mode)                   â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

---

## Refinement Proposals

As you use functions, AI proposes improvements:

```elixir
iex> AutoBridge.SymPy.expand("(x + 1)**3")
{:ok, "x**3 + 3*x**2 + 3*x + 1"}

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ ðŸ§  Refinement Proposal                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Function: expand/1                                          â”‚
â”‚ Proposed: @spec expand(String.t()) :: {:ok, String.t()}    â”‚
â”‚ Confidence: 94%                                             â”‚
â”‚ [a]ccept  [r]eject  [m]odify  [s]kip                       â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

iex> a
âœ“ Refinement applied
```

### Commands

| Key | Action |
|-----|--------|
| `a` | Accept proposal |
| `r` | Reject permanently |
| `m` | Modify with custom value |
| `s` | Skip for now |
| `d` | Show details |

---

## Status Dashboard

```elixir
iex> AutoBridge.status(:sympy)
%{
  phase: :learning,
  confidence: 73,
  observations: 124,
  pending_refinements: 3,
  functions_used: "23/847"
}
```

### Pending Refinements

```elixir
iex> AutoBridge.pending(:sympy)
[
  %{id: 1, type: :typespec, target: "solve/2", confidence: 94},
  %{id: 2, type: :default, target: "simplify/2", confidence: 87}
]

iex> AutoBridge.accept(1)
âœ“ Typespec for solve/2 applied
```

---

## Batch Operations

```elixir
# Accept all high-confidence proposals
iex> AutoBridge.accept_all(:sympy, min_confidence: 0.9)
Accepted 2 refinements

# Enable auto-accept for rapid prototyping
iex> AutoBridge.configure(:sympy, auto_accept: true, threshold: 0.95)
```

---

## Error Learning

AutoBridge learns from errors too:

```elixir
iex> AutoBridge.SymPy.solve(123, :x)
{:error, :type_error}

# May propose validation guard:
â”‚ Proposed: Add `when is_binary(expr)` guard â”‚
```

---

## Finalization

When confidence reaches threshold:

```elixir
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ ðŸŽ¯ sympy ready for finalization (97% confidence)           â”‚
â”‚ Run `AutoBridge.finalize(:sympy)` when ready               â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

iex> AutoBridge.finalize(:sympy)
Step 1/5: Validating... âœ“
Step 2/5: Generating tests... âœ“
Step 3/5: Running tests... âœ“
Step 4/5: Compiling... âœ“
Step 5/5: Documenting... âœ“

âœ“ sympy frozen and production-ready!
```

---

## Notification Control

```elixir
# Silence notifications
iex> AutoBridge.DevShell.quiet()

# Enable all notifications
iex> AutoBridge.DevShell.verbose()

# Configure via config.exs
config :autobridge, notification_level: :normal  # :quiet | :normal | :verbose | :silent
```

---

## Troubleshooting

```elixir
# Confidence stuck?
iex> AutoBridge.diagnose(:sympy)
# Shows what's limiting confidence

# Accidentally rejected?
iex> AutoBridge.undo(:sympy)

# Focus on subset of functions
iex> AutoBridge.focus(:sympy, only: [:solve, :simplify, :expand])
```
</file>

<file path="autobridge-design/priority-libraries.md">
# Priority Libraries: Phase 1

The first three Python libraries for AutoBridge integration are selected for their stateless, computational nature and complementary functionality.

---

## Library Overview

| Library | Purpose | Size | Complexity |
|---------|---------|------|------------|
| **SymPy** | Symbolic mathematics | 847 functions | High (symbolic types) |
| **pylatexenc** | LaTeX â†” Unicode | ~50 functions | Medium (string transforms) |
| **Math-Verify** | Expression evaluation | ~30 functions | Medium (parsing + verification) |

---

## 1. SymPy

### Overview

SymPy is a Python library for symbolic mathematics. It provides algebraic manipulation, calculus, equation solving, and more.

### Target Functions

**Core Symbolic Operations**:
```python
sympy.symbols(names)              # Create symbolic variables
sympy.solve(equation, variable)   # Solve equations
sympy.simplify(expr)              # Simplify expressions
sympy.expand(expr)                # Expand polynomials
sympy.factor(expr)                # Factor expressions
sympy.diff(expr, variable)        # Differentiate
sympy.integrate(expr, variable)   # Integrate
```

**Expression Manipulation**:
```python
sympy.Eq(lhs, rhs)                # Create equation
sympy.sympify(string)             # Parse string to expression
sympy.latex(expr)                 # Convert to LaTeX
sympy.N(expr, precision)          # Numerical evaluation
```

### Type Mapping Strategy

| Python Type | Elixir Type | Notes |
|-------------|-------------|-------|
| `sympy.Symbol` | `atom()` | Map symbol names to atoms |
| `sympy.Expr` | `String.t() \| map()` | Serialized expression |
| `sympy.Eq` | `{:eq, left, right}` | Tuple representation |
| `list[Expr]` | `[term()]` | List of solutions |
| `dict` | `map()` | Substitution maps |

### Challenges

1. **Symbolic expressions** - Complex nested structures need serialization strategy
2. **Assumptions** - SymPy has assumption system (`positive=True`, etc.)
3. **Large API** - Need to focus on core subset

### Integration Strategy

```elixir
# Focus mode for rapid convergence
AutoBridge.configure(:sympy, 
  focus: [
    :symbols, :solve, :simplify, :expand, :factor,
    :diff, :integrate, :Eq, :sympify, :latex, :N
  ],
  # Serialize expressions as strings by default
  expr_serialization: :string,
  # Timeout for complex computations
  timeout: 30_000
)
```

### Example Usage (Target)

```elixir
alias AutoBridge.SymPy

# Create symbols
{:ok, [x, y]} = SymPy.symbols("x y")

# Solve equation
{:ok, solutions} = SymPy.solve("x**2 - 4", :x)
# => [-2, 2]

# Simplify
{:ok, simplified} = SymPy.simplify("sin(x)**2 + cos(x)**2")
# => "1"

# Differentiate
{:ok, derivative} = SymPy.diff("x**3 + 2*x", :x)
# => "3*x**2 + 2"

# Convert to LaTeX
{:ok, latex} = SymPy.latex("x**2/2")
# => "\\frac{x^{2}}{2}"
```

---

## 2. pylatexenc

### Overview

pylatexenc provides bidirectional conversion between LaTeX and Unicode text.

### Target Functions

```python
# LaTeX to Unicode
pylatexenc.latex2text.LatexNodes2Text().latex_to_text(latex_str)

# Unicode to LaTeX
pylatexenc.latexencode.unicode_to_latex(unicode_str)

# LaTeX parsing
pylatexenc.latexwalker.LatexWalker(latex_str).get_latex_nodes()
```

### Type Mapping Strategy

| Python Type | Elixir Type | Notes |
|-------------|-------------|-------|
| `str` (LaTeX) | `String.t()` | LaTeX formatted |
| `str` (Unicode) | `String.t()` | Plain text |
| `LatexNode` | `map()` | AST node representation |
| `list[LatexNode]` | `[map()]` | Node list |

### Integration Strategy

Since pylatexenc is primarily stateless string transforms, it's ideal for AutoBridge:

```elixir
AutoBridge.configure(:pylatexenc,
  # Simple function wrapping, no class instances
  mode: :functions_only,
  # Core functions to wrap
  focus: [
    :latex_to_text,
    :unicode_to_latex,
    :get_latex_nodes
  ]
)
```

### Example Usage (Target)

```elixir
alias AutoBridge.PyLatexEnc

# LaTeX to plain text
{:ok, text} = PyLatexEnc.latex_to_text("\\textbf{Hello} $\\alpha + \\beta$")
# => "Hello Î± + Î²"

# Unicode to LaTeX
{:ok, latex} = PyLatexEnc.unicode_to_latex("Î± + Î² â‰¤ Î³")
# => "\\alpha + \\beta \\leq \\gamma"

# Parse LaTeX to AST
{:ok, nodes} = PyLatexEnc.parse("\\frac{1}{2}")
# => [%{type: :macro, name: "frac", args: ["1", "2"]}]
```

---

## 3. Math-Verify

### Overview

Math-Verify is a mathematical expression evaluation system for assessing LLM outputs. It parses, normalizes, and compares mathematical expressions.

### Target Functions

```python
# Parse expressions
math_verify.parse(text, extraction_config=[...])

# Verify equality
math_verify.verify(gold, answer)

# Grading
math_verify.grader.grade(gold, answer)
```

### Type Mapping Strategy

| Python Type | Elixir Type | Notes |
|-------------|-------------|-------|
| `SymPy Expr` | `term()` | Parsed expression |
| `bool` | `boolean()` | Verification result |
| `ExtractionConfig` | `keyword()` | Config options |
| `ParseResult` | `{:ok, term()} \| {:error, term()}` | Parse result |

### Integration Strategy

```elixir
AutoBridge.configure(:math_verify,
  focus: [:parse, :verify, :grade],
  # Special handling for SymPy expressions
  inherit_types_from: :sympy,
  # Error handling for parse failures
  error_mapping: %{
    "ParseError" => :parse_error,
    "VerifyError" => :verify_error
  }
)
```

### Example Usage (Target)

```elixir
alias AutoBridge.MathVerify

# Parse LaTeX expression
{:ok, gold} = MathVerify.parse("${1,3} \\cup {2,4}$")
{:ok, answer} = MathVerify.parse("${1,2,3,4}$")

# Verify equivalence
{:ok, true} = MathVerify.verify(gold, answer)

# Parse with config
{:ok, expr} = MathVerify.parse("The answer is 42", 
  extraction: :expr,
  boxed_priority: 0
)
```

---

## Integration Pipeline

```mermaid
flowchart LR
    subgraph "Input"
        A[User Input]
        B[LaTeX Expression]
    end
    
    subgraph "pylatexenc"
        C[latex_to_text]
        D[unicode_to_latex]
    end
    
    subgraph "SymPy"
        E[sympify]
        F[simplify]
        G[solve]
        H[latex]
    end
    
    subgraph "Math-Verify"
        I[parse]
        J[verify]
    end
    
    A --> C --> E --> F --> H --> D
    B --> I --> J
    G --> I
```

---

## Synergy Examples

### Complete Math Pipeline

```elixir
defmodule MyApp.MathPipeline do
  alias AutoBridge.{SymPy, PyLatexEnc, MathVerify}
  
  def evaluate_and_verify(problem_latex, student_answer) do
    # Parse LaTeX to text
    {:ok, problem_text} = PyLatexEnc.latex_to_text(problem_latex)
    
    # Solve symbolically
    {:ok, solution} = SymPy.solve(problem_text, :x)
    
    # Convert solution to LaTeX
    {:ok, solution_latex} = SymPy.latex(hd(solution))
    
    # Verify student answer
    {:ok, gold} = MathVerify.parse(solution_latex)
    {:ok, answer} = MathVerify.parse(student_answer)
    
    MathVerify.verify(gold, answer)
  end
end
```

### LLM Output Grading

```elixir
defmodule MyApp.LLMGrader do
  alias AutoBridge.MathVerify
  
  def grade_response(expected, llm_output) do
    with {:ok, gold} <- MathVerify.parse(expected, extraction: :latex),
         {:ok, answer} <- MathVerify.parse(llm_output, extraction: [:latex, :expr]),
         {:ok, true} <- MathVerify.verify(gold, answer) do
      :correct
    else
      {:ok, false} -> :incorrect
      {:error, reason} -> {:error, reason}
    end
  end
end
```

---

## Success Criteria

### Per Library

| Library | Finalization Criteria |
|---------|----------------------|
| SymPy | 10 core functions wrapped, type-safe, working solve/simplify |
| pylatexenc | All 3 core functions wrapped, bidirectional conversion working |
| Math-Verify | parse/verify working, integration with SymPy expressions |

### Overall

- All three libraries usable together in pipeline
- Zero manual configuration required after finalization
- < 5% overhead vs direct Python calls
- Comprehensive type specs for Dialyzer
</file>

<file path="autobridge-design/README.md">
# AutoBridge: AI-Native Python Library Integration

<p align="center">
  <strong>ðŸ§  The Library That Builds Itself</strong>
</p>

> **Vision**: A single, intelligent system that automatically integrates any stateless Python library into Elixirâ€”learning and evolving through AI-driven discovery, interactive development, and continuous refinement.

---

## The Big Idea

AutoBridge is not just another library integration tool. It represents a **paradigm shift** in how software is built:

**Traditional Approach:**
```
Developer â†’ Manually writes config â†’ Tests â†’ Deploys â†’ Repeat for each library
```

**AutoBridge Approach:**
```
Developer â†’ Uses library â†’ AI observes patterns â†’ Converges on optimal config â†’ Zero ongoing maintenance
```

This is a **gateway to next-generation software architecture** where AI is native to the application, actively participating in building and maintaining itself.

---

## Core Philosophy

### 1. Stateless Python, Stateful BEAM

The BEAM (Erlang VM) excels at state management, concurrency, and fault tolerance. Python excels at computational libraries. AutoBridge embraces this division:

| Responsibility | Owner |
|---------------|-------|
| Symbolic computation | Python (SymPy) |
| LaTeX processing | Python (pylatexenc) |
| Mathematical verification | Python (Math-Verify) |
| Session management | BEAM (GenServer) |
| Caching | BEAM (ETS) |
| Fault tolerance | BEAM (Supervisors) |
| State & coordination | BEAM (Processes) |

### 2. AI-Driven Evolution, Not Static Configuration

Instead of hoping a community maintains adapters, AutoBridge uses **agentic AI systems** to:

- Discover library APIs automatically
- Generate optimal configurations through heuristics
- Learn from developer interactions during use
- Continuously refine and update adapters as libraries evolve

### 3. Interactive Convergence

The "magic" isn't deterministic heuristics that miss edge cases. It's an **AI-assisted process** that:

- Observes how developers use the library
- Proposes configuration refinements
- Learns from corrections and feedback
- Converges on a finalized "zero-config" state

---

## Target Libraries (Phase 1)

### Priority 1: Mathematical & Scientific

| Library | Purpose | Integration Focus |
|---------|---------|-------------------|
| **SymPy** | Symbolic mathematics | Core symbolic classes, solvers, simplifiers |
| **pylatexenc** | LaTeX â†” Unicode conversion | Stateless conversion functions |
| **Math-Verify** | Mathematical expression evaluation | Parser, verifier, grader components |

### Why These Libraries?

1. **Stateless by nature** - Pure computational functions
2. **Well-documented APIs** - Clear introspection targets
3. **Complementary** - Together they form a complete math processing pipeline
4. **Real-world demand** - Essential for LLM evaluation, education tech, scientific computing

---

## Document Index

| Document | Purpose |
|----------|---------|
| [Architecture](./architecture.md) | System design and component overview |
| [Agentic System](./agentic-system.md) | How AI drives discovery and refinement |
| [Adapter Lifecycle](./adapter-lifecycle.md) | From discovery to zero-config finalization |
| [Interactive Development](./interactive-development.md) | Developer experience during library usage |
| [Priority Libraries](./priority-libraries.md) | SymPy, pylatexenc, Math-Verify specifications |
| [Implementation Roadmap](./implementation-roadmap.md) | Phased development plan |
| [Type Mapping](./type-mapping.md) | Python â†” Elixir type conversion strategies |

---

## Quick Example: The Vision

```elixir
# DAY 1: First time using SymPy
# AutoBridge has never seen this library

iex> use AutoBridge, :sympy

# Behind the scenes:
# 1. AI discovers SymPy's API structure
# 2. Generates initial config with smart defaults
# 3. Creates type mappings for symbolic expressions
# 4. Starts in "learning mode"

iex> AutoBridge.SymPy.symbols("x y z")
{:ok, [x, y, z]}

# AutoBridge observes: "User called symbols() with string arg, got list back"
# AI updates internal model of common usage patterns

iex> AutoBridge.SymPy.solve("x**2 - 1", :x)
{:ok, [-1, 1]}

# More observations accumulate...
# AI notices: "solve() always used with expression string + symbol"
# Proposes refined typespec: solve(String.t(), atom()) :: {:ok, list()}

# INTERACTIVE REFINEMENT (in dev mode):

iex> AutoBridge.status(:sympy)
%{
  mode: :learning,
  confidence: 0.73,
  observations: 47,
  proposed_refinements: [
    {:typespec, :solve, "Add symbol constraint"},
    {:default, :simplify, "Auto-simplify results"}
  ],
  pending_review: 2
}

iex> AutoBridge.accept_refinement(:sympy, 0)
# âœ“ Typespec updated for solve/2

# AFTER STABILIZATION (confidence > 0.95):

iex> AutoBridge.finalize(:sympy)
# Generates frozen config: priv/autobridge/adapters/sympy.exs
# Compiles optimized wrapper module
# Disables learning mode
# Library is now "zero-config" for all users
```

---

## What Makes This "Next-Gen"

### Traditional Integration Libraries
- Static configs maintained by humans
- Community contributions with varying quality
- Breaks when Python libraries update
- One-size-fits-all approach

### AutoBridge
- **Self-building**: AI generates and refines configs
- **Self-healing**: Detects API changes, proposes updates
- **Context-aware**: Learns from actual usage patterns
- **Converges**: Moves from "learning" to "frozen" state
- **Interactive**: Developer collaborates with AI during refinement

---

## The Agentic Pipeline

```mermaid
graph TB
    subgraph "Discovery Phase"
        A[New Library Request] --> B[AI Introspection Agent]
        B --> C[Schema Generation]
        C --> D[Initial Config]
    end
    
    subgraph "Learning Phase"
        D --> E[Developer Uses Library]
        E --> F[Usage Pattern Observer]
        F --> G[AI Refinement Agent]
        G --> H{Confidence > 95%?}
        H -->|No| E
        H -->|Yes| I[Propose Finalization]
    end
    
    subgraph "Finalization Phase"
        I --> J[Developer Review]
        J --> K[Frozen Config]
        K --> L[Optimized Production Module]
    end
    
    subgraph "Maintenance Phase"
        L --> M[Version Monitor Agent]
        M --> N{API Changed?}
        N -->|Yes| O[Propose Updates]
        O --> P[Developer Approval]
        P --> D
        N -->|No| M
    end
```

---

## Success Metrics

1. **Time to Integration**: < 5 minutes from "never seen library" to working wrapper
2. **Configuration Accuracy**: > 95% of generated configs work without modification
3. **Maintenance Burden**: Zero manual updates required for library version bumps
4. **Developer Experience**: Interactive refinement feels natural, not intrusive

---

## Getting Started

See [Implementation Roadmap](./implementation-roadmap.md) for the phased development plan.

---

*This design represents a prototype for AI-native software architectureâ€”where the system actively participates in building and maintaining itself.*
</file>

<file path="autobridge-design/type-mapping.md">
# Type Mapping System

## Overview

AutoBridge must translate between Python's dynamic type system and Elixir's statically-typed world. This document defines the mapping strategies and type inference approaches.

---

## Core Type Mappings

### Primitive Types

| Python Type | Elixir Type | Notes |
|-------------|-------------|-------|
| `str` | `String.t()` | UTF-8 compatible |
| `int` | `integer()` | Arbitrary precision |
| `float` | `float()` | IEEE 754 |
| `bool` | `boolean()` | `True` â†’ `true` |
| `None` | `nil` | |
| `bytes` | `binary()` | Raw bytes |

### Collection Types

| Python Type | Elixir Type | Notes |
|-------------|-------------|-------|
| `list` | `list(term())` | Heterogeneous |
| `list[T]` | `[t()]` | Homogeneous, inferred |
| `tuple` | `tuple()` | Fixed structure |
| `dict` | `map()` | Key-value |
| `dict[str, T]` | `%{String.t() => t()}` | Typed dict |
| `set` | `MapSet.t()` | Unordered unique |

### Special Types

| Python Type | Elixir Type | Notes |
|-------------|-------------|-------|
| `Optional[T]` | `t() \| nil` | Nullable |
| `Union[A, B]` | `a() \| b()` | Union types |
| `Any` | `term()` | Escape hatch |
| `Callable` | `function()` | For callbacks |

---

## Library-Specific Type Mappings

### SymPy Types

```elixir
@type expression :: String.t() | map()
@type symbol :: atom()
@type equation :: {:eq, expression(), expression()}
@type solution :: [expression()]
@type substitution :: %{symbol() => expression()}

# Complex SymPy objects serialized as strings
@type sympy_expr :: String.t()
```

**Serialization Strategy**:
```elixir
# SymPy expressions â†’ string (default)
SymPy.sympify("x**2 + 1")
# Returns: {:ok, "x**2 + 1"}

# SymPy expressions â†’ structured map (optional)
SymPy.sympify("x**2 + 1", format: :structured)
# Returns: {:ok, %{type: :add, args: [%{type: :pow, ...}, 1]}}
```

### pylatexenc Types

```elixir
@type latex_string :: String.t()
@type unicode_string :: String.t()
@type latex_node :: %{
  type: :text | :macro | :group | :environment,
  content: term(),
  position: {integer(), integer()}
}
```

### Math-Verify Types

```elixir
@type parse_result :: {:ok, expression()} | {:error, parse_error()}
@type verify_result :: {:ok, boolean()} | {:error, verify_error()}
@type extraction_config :: :latex | :expr | :string | keyword()

@type parse_error :: 
  :invalid_syntax | 
  :unsupported_expression | 
  {:extraction_failed, String.t()}
```

---

## Type Inference Algorithm

### From Observations

```elixir
defmodule AutoBridge.TypeInference do
  @doc """
  Infer Elixir type from observed Python values.
  """
  def infer_type(observations) do
    observations
    |> Enum.map(&classify_value/1)
    |> find_common_type()
    |> to_typespec()
  end
  
  defp classify_value(value) when is_binary(value), do: :string
  defp classify_value(value) when is_integer(value), do: :integer
  defp classify_value(value) when is_float(value), do: :float
  defp classify_value(value) when is_boolean(value), do: :boolean
  defp classify_value(value) when is_nil(value), do: :nil
  defp classify_value(value) when is_list(value) do
    case value do
      [] -> {:list, :any}
      [h | _] -> {:list, classify_value(h)}
    end
  end
  defp classify_value(value) when is_map(value), do: :map
  defp classify_value(_), do: :any
  
  defp find_common_type(types) do
    unique = Enum.uniq(types)
    case unique do
      [single] -> single
      multiple -> {:union, multiple}
    end
  end
  
  defp to_typespec(:string), do: "String.t()"
  defp to_typespec(:integer), do: "integer()"
  defp to_typespec(:float), do: "float()"
  defp to_typespec(:boolean), do: "boolean()"
  defp to_typespec(:nil), do: "nil"
  defp to_typespec({:list, inner}), do: "[#{to_typespec(inner)}]"
  defp to_typespec(:map), do: "map()"
  defp to_typespec(:any), do: "term()"
  defp to_typespec({:union, types}) do
    types |> Enum.map(&to_typespec/1) |> Enum.join(" | ")
  end
end
```

### From Python Type Hints

```elixir
defmodule AutoBridge.TypeHints do
  @doc """
  Parse Python type hints to Elixir typespecs.
  """
  def parse_hint("str"), do: "String.t()"
  def parse_hint("int"), do: "integer()"
  def parse_hint("float"), do: "float()"
  def parse_hint("bool"), do: "boolean()"
  def parse_hint("None"), do: "nil"
  def parse_hint("Any"), do: "term()"
  
  def parse_hint("list[" <> rest) do
    inner = String.trim_trailing(rest, "]")
    "[#{parse_hint(inner)}]"
  end
  
  def parse_hint("dict[str, " <> rest) do
    value_type = String.trim_trailing(rest, "]")
    "%{String.t() => #{parse_hint(value_type)}}"
  end
  
  def parse_hint("Optional[" <> rest) do
    inner = String.trim_trailing(rest, "]")
    "#{parse_hint(inner)} | nil"
  end
  
  def parse_hint("Union[" <> rest) do
    types = rest
    |> String.trim_trailing("]")
    |> String.split(", ")
    |> Enum.map(&parse_hint/1)
    |> Enum.join(" | ")
  end
  
  # Unknown types become term()
  def parse_hint(_unknown), do: "term()"
end
```

---

## Custom Type Definitions

Users can define custom type mappings:

```elixir
# config/autobridge.exs
config :autobridge, :type_mappings,
  sympy: %{
    "sympy.core.symbol.Symbol" => "atom()",
    "sympy.core.expr.Expr" => "expression()",
    "sympy.core.numbers.Integer" => "integer()",
    "sympy.core.numbers.Float" => "float()"
  },
  pylatexenc: %{
    "pylatexenc.latexwalker.LatexNode" => "latex_node()"
  }
```

---

## Type Generation

### Spec Generation

```elixir
defmodule AutoBridge.TypeGenerator do
  def generate_spec(function, inferred_types) do
    args = inferred_types.args
    |> Enum.map(&format_arg/1)
    |> Enum.join(", ")
    
    return = format_return(inferred_types.return)
    
    "@spec #{function}(#{args}) :: #{return}"
  end
  
  defp format_arg({name, type}) do
    "#{name} :: #{type}"
  end
  
  defp format_return({:ok_error, success_type}) do
    "{:ok, #{success_type}} | {:error, term()}"
  end
end
```

### Type Module Generation

For complex libraries, generate dedicated type modules:

```elixir
# Generated: lib/autobridge/types/sympy.ex
defmodule AutoBridge.Types.SymPy do
  @moduledoc "Type definitions for SymPy integration"
  
  @type expression :: String.t() | map()
  @type symbol :: atom()
  @type equation :: {:eq, expression(), expression()}
  @type solution :: [expression()]
  @type substitution :: %{symbol() => expression()}
  
  @type solve_error :: 
    {:no_solution, expression()} |
    {:invalid_expression, String.t()} |
    {:unsupported, String.t()}
end
```

---

## Serialization

### Python â†’ Elixir

```elixir
defmodule AutoBridge.Serializer do
  @doc """
  Serialize Python objects for Elixir consumption.
  """
  
  # Standard JSON-compatible types pass through
  def serialize(value) when is_binary(value), do: value
  def serialize(value) when is_number(value), do: value
  def serialize(value) when is_boolean(value), do: value
  def serialize(nil), do: nil
  def serialize(value) when is_list(value) do
    Enum.map(value, &serialize/1)
  end
  def serialize(value) when is_map(value) do
    Map.new(value, fn {k, v} -> {serialize(k), serialize(v)} end)
  end
  
  # Complex objects: convert to string representation
  def serialize({:python_object, type, repr}) do
    case serialization_strategy(type) do
      :string -> repr
      :structured -> parse_structured(repr)
      :custom -> apply_custom_serializer(type, repr)
    end
  end
end
```

### Elixir â†’ Python

```elixir
defmodule AutoBridge.Deserializer do
  @doc """
  Prepare Elixir values for Python consumption.
  """
  
  def deserialize(value) when is_atom(value) do
    Atom.to_string(value)
  end
  
  def deserialize(%DateTime{} = dt) do
    DateTime.to_iso8601(dt)
  end
  
  def deserialize(value) when is_struct(value) do
    Map.from_struct(value)
  end
  
  def deserialize(value), do: value
end
```

---

## Error Type Mapping

### Python Exceptions â†’ Elixir Errors

```elixir
@exception_mapping %{
  "TypeError" => :type_error,
  "ValueError" => :value_error,
  "KeyError" => :key_error,
  "IndexError" => :index_error,
  "AttributeError" => :attribute_error,
  "RuntimeError" => :runtime_error,
  "sympy.SympifyError" => :sympify_error,
  "sympy.SolveFailed" => :solve_failed
}

def map_exception(python_exception) do
  exception_type = python_exception["type"]
  message = python_exception["message"]
  
  elixir_error = Map.get(@exception_mapping, exception_type, :python_error)
  {:error, {elixir_error, message}}
end
```

---

## Dialyzer Integration

AutoBridge generates Dialyzer-compatible specs:

```elixir
# Generated wrapper with full specs
defmodule AutoBridge.SymPy do
  @moduledoc "Auto-generated SymPy wrapper"
  
  @type expression :: String.t() | map()
  @type symbol :: atom()
  
  @spec solve(expression(), symbol()) :: {:ok, [expression()]} | {:error, solve_error()}
  def solve(expr, var) do
    AutoBridge.Runtime.call(:sympy, :solve, [expr, var])
  end
  
  @spec simplify(expression()) :: {:ok, expression()} | {:error, term()}
  def simplify(expr) do
    AutoBridge.Runtime.call(:sympy, :simplify, [expr])
  end
end
```

---

## Escape Hatches

When type inference fails, provide escape hatches:

```elixir
# Override inferred type
AutoBridge.configure(:sympy, :solve, 
  return_type: "{:ok, [String.t()]} | {:error, solve_error()}"
)

# Skip type checking for complex function
AutoBridge.configure(:sympy, :complex_function,
  skip_typespec: true
)

# Use raw term() for unpredictable returns
# (Automatically applied when variance is too high)
```
</file>

</files>
