# Elixir Metaprogramming & Code Generation for SnakeBridge v2

**Date**: 2025-12-24
**Status**: Research Document
**Author**: Architecture Review for v2 Redesign

## Executive Summary

This document analyzes Elixir metaprogramming capabilities for SnakeBridge v2, which aims to auto-generate fully-documented, well-typed Elixir modules from Python library introspection. We examine current approaches, Elixir's compilation model, and recommend the optimal path forward for generating HexDocs-quality modules.

**Key Recommendation**: Use a **hybrid compile-time approach** with Mix compiler integration, generating source files that can be committed to version control while maintaining runtime flexibility for development.

---

## Table of Contents

1. [Current SnakeBridge Code Generation Approach](#1-current-snakebridge-code-generation-approach)
2. [Elixir Metaprogramming Fundamentals](#2-elixir-metaprogramming-fundamentals)
3. [Compile-Time vs Runtime Code Generation](#3-compile-time-vs-runtime-code-generation)
4. [Documentation Generation Requirements](#4-documentation-generation-requirements)
5. [Typespec Generation Patterns](#5-typespec-generation-patterns)
6. [Module Creation Approaches](#6-module-creation-approaches)
7. [Mix Compiler Integration](#7-mix-compiler-integration)
8. [Recommended v2 Architecture](#8-recommended-v2-architecture)
9. [Implementation Roadmap](#9-implementation-roadmap)

---

## 1. Current SnakeBridge Code Generation Approach

### 1.1 Current Architecture Overview

SnakeBridge currently uses a **runtime code generation** approach:

```elixir
# lib/snakebridge/generator.ex (lines 19-65)
def generate_module(descriptor, config) do
  quote do
    defmodule unquote(module_name) do
      @moduledoc unquote(Helpers.build_moduledoc(descriptor))
      @python_path unquote(python_path)
      @config unquote(Macro.escape(config))
      @type t :: {session_id :: String.t(), instance_id :: String.t()}

      unquote_splicing(generate_constant_attributes(constant_fields))
      unquote(generate_hooks(compilation_mode))
      unquote(generate_create_function(python_path, constructor))
      unquote_splicing(generate_methods(methods))

      defp generate_session_id do
        SnakeBridge.SessionId.generate("session")
      end
    end
  end
end
```

**Key characteristics:**
- Uses `quote`/`unquote` macros to build AST
- Compiles via `Code.compile_quoted/1` at runtime
- Loads modules into BEAM at runtime
- No persistent source files by default
- Minimal documentation generation

### 1.2 Current Module Loading Flow

```elixir
# lib/snakebridge/manifest/loader.ex (lines 199-210)
defp load_file(path) do
  case Manifest.from_file(path) do
    {:ok, config} ->
      case Generator.generate_all(config) do
        {:ok, modules} -> {:ok, %{config: config, modules: modules}}
        {:error, _} = error -> error
      end
    {:error, reason} ->
      {:error, %{path: path, reason: reason}}
  end
end

# lib/snakebridge/generator.ex (lines 497-503)
def compile_and_load(ast) do
  [{module, _bytecode}] = Code.compile_quoted(ast)
  {:ok, module}
rescue
  e -> {:error, Exception.message(e)}
end
```

**Current flow:**
1. Load JSON manifest from `priv/snakebridge/manifests/*.json`
2. Parse manifest into `SnakeBridge.Config` struct
3. Generate AST using `quote` blocks
4. Compile AST to bytecode with `Code.compile_quoted/1`
5. Module available in BEAM memory only

### 1.3 Compile-Time Generation Support

SnakeBridge has preliminary compile-time support:

```elixir
# lib/snakebridge/manifest/compiler.ex (lines 8-32)
def compile_files(files, output_dir) when is_list(files) and is_binary(output_dir) do
  File.mkdir_p!(output_dir)

  outputs =
    files
    |> Enum.flat_map(fn file ->
      case Manifest.from_file(file) do
        {:ok, config} ->
          config
          |> Generator.generate_all_ast()
          |> Enum.map(&write_ast(&1, output_dir))
        {:error, reason} ->
          raise "Failed to load manifest #{file}: #{inspect(reason)}"
      end
    end)

  {:ok, outputs}
end

defp write_ast(ast, output_dir) do
  module = module_from_ast(ast)
  file_path = Path.join(output_dir, module_filename(module))

  contents =
    ast
    |> Macro.to_string()
    |> Code.format_string!()
    |> IO.iodata_to_binary()

  header = "# Generated by mix snakebridge.manifest.compile\n\n"
  File.write!(file_path, header <> contents <> "\n")
  file_path
end
```

**Current limitations:**
- AST-to-string conversion may lose formatting
- No preservation of complex documentation
- Limited integration with Mix compilation pipeline
- Manual invocation required via `mix snakebridge.manifest.compile`

### 1.4 Current Type System

```elixir
# lib/snakebridge/type_system/mapper.ex (lines 283-383)
@spec to_elixir_spec(map() | String.t() | nil) :: Macro.t()

# Primitives
defp do_to_elixir_spec(%{kind: "primitive", primitive_type: "int"}),
  do: quote(do: integer())
defp do_to_elixir_spec(%{kind: "primitive", primitive_type: "str"}),
  do: quote(do: String.t())

# Collections
defp do_to_elixir_spec(%{kind: "list", element_type: element}) do
  inner = to_elixir_spec(element)
  quote do: [unquote(inner)]
end

# Union types
defp do_to_elixir_spec(%{kind: "union", union_types: types}) do
  types
  |> Enum.map(&to_elixir_spec/1)
  |> Enum.reduce(fn spec, acc ->
    quote do: unquote(acc) | unquote(spec)
  end)
end
```

**Type system features:**
- Rich Python-to-Elixir type mapping
- Support for primitives, collections, unions, classes
- DateTime, callable, generator types
- Normalizes both `%{type: "int"}` and `%{kind: "primitive", primitive_type: "int"}` formats
- Smart module name generation from Python class paths

### 1.5 Current Documentation Generation

```elixir
# lib/snakebridge/generator/helpers.ex (lines 41-53)
def build_moduledoc(descriptor) do
  docstring = get_field(descriptor, :docstring, "")
  python_path = get_field(descriptor, :python_path, "")

  """
  Elixir wrapper for #{python_path}.

  #{docstring}

  This module was automatically generated by SnakeBridge.
  """
end

# Function doc generation (lines 58-71)
def build_function_doc(function_desc, _class_config \\ %{}) do
  name = get_field(function_desc, :name, "unknown")
  docstring = get_field(function_desc, :docstring, "")
  streaming = get_field(function_desc, :streaming, false)

  """
  Call #{name} on the Python instance.

  #{docstring}

  Streaming: #{streaming}
  """
end
```

**Current limitations:**
- Basic documentation only
- No parameter documentation
- No examples or usage patterns
- No links or cross-references
- Minimal metadata

---

## 2. Elixir Metaprogramming Fundamentals

### 2.1 The Quote/Unquote Model

Elixir metaprogramming is based on AST manipulation:

```elixir
# AST representation
quote do
  def hello(name) do
    "Hello, #{name}!"
  end
end

# Returns:
{:def, [context: Elixir, import: Kernel],
 [
   {:hello, [context: Elixir], [{:name, [], Elixir}]},
   [do: {:<<>>, [], ["Hello, ", {:name, [], Elixir}, "!"]}]
 ]}
```

**Key primitives:**
- `quote` - Convert code to AST
- `unquote` - Inject values into quoted expressions
- `unquote_splicing` - Inject lists of AST nodes
- `Macro.escape` - Safely inject runtime data structures
- `Macro.to_string` - Convert AST back to source code

### 2.2 Module Attributes

Module attributes are compile-time metadata:

```elixir
defmodule Example do
  @moduledoc """
  Module documentation for ExDoc.
  """

  @doc """
  Function documentation.

  ## Examples

      iex> Example.hello("World")
      "Hello, World!"
  """
  @spec hello(String.t()) :: String.t()
  def hello(name), do: "Hello, #{name}!"

  @type user :: %{name: String.t(), age: integer()}
end
```

**Important attributes for v2:**
- `@moduledoc` - Module-level documentation (ExDoc)
- `@doc` - Function documentation (ExDoc)
- `@spec` - Type specifications (Dialyzer)
- `@type`, `@typep`, `@opaque` - Type definitions
- `@deprecated` - Deprecation notices
- Custom attributes for metadata

### 2.3 Compile-Time Hooks

```elixir
defmodule Example do
  @before_compile MyMacro
  @on_load :init
  @after_compile __MODULE__

  def init do
    # Called when module loads
    :ok
  end

  def __after_compile__(env, _bytecode) do
    # Called after compilation
    IO.puts "Compiled #{env.module}"
  end
end

defmodule MyMacro do
  defmacro __before_compile__(env) do
    # Inject code before module finalization
    quote do
      def injected_function, do: :ok
    end
  end
end
```

**Current usage in SnakeBridge:**
```elixir
# lib/snakebridge/generator.ex (lines 148-167)
defp generate_hooks(:compile_time) do
  quote do
    @before_compile SnakeBridge.Generator.Hooks
  end
end

defp generate_hooks(:runtime) do
  quote do
    @on_load :__snakebridge_load__

    def __snakebridge_load__ do
      :ok
    end
  end
end
```

### 2.4 Macro Expansion and Compilation Phases

Elixir compilation happens in phases:

1. **Lexing/Parsing** - Source code → AST
2. **Macro Expansion** - Expand all macros recursively
3. **Compilation** - AST → BEAM bytecode
4. **Loading** - Bytecode → BEAM VM

**Key insight**: Documentation attributes are evaluated during macro expansion and become part of the module's metadata, which ExDoc extracts post-compilation.

---

## 3. Compile-Time vs Runtime Code Generation

### 3.1 Runtime Generation (Current Approach)

**Mechanism:**
```elixir
# Runtime generation
ast = generate_module(descriptor, config)
[{module, bytecode}] = Code.compile_quoted(ast)
# Module now in memory, no source file
```

**Advantages:**
- Fast development iteration
- Dynamic module creation
- No source file management
- Can respond to runtime configuration

**Disadvantages:**
- ❌ Modules not available to ExDoc
- ❌ No Mix compiler integration
- ❌ Hard to debug generated code
- ❌ No git history of generated modules
- ❌ Lost on BEAM restart (unless persisted)
- ❌ Dialyzer can't analyze without source
- ❌ No IDE autocomplete/goto definition

### 3.2 Compile-Time Generation via Source Files

**Mechanism:**
```elixir
# Generate .ex files
ast = generate_module(descriptor, config)
source = ast |> Macro.to_string() |> Code.format_string!()
File.write!("lib/generated/my_module.ex", source)
# Mix compiler picks up .ex file
```

**Advantages:**
- ✅ Full ExDoc integration
- ✅ Dialyzer analysis
- ✅ IDE support (autocomplete, goto definition)
- ✅ Git-trackable
- ✅ Debuggable source code
- ✅ Standard Mix compilation
- ✅ Can review generated code

**Disadvantages:**
- Requires pre-compilation step
- Source files need management
- Larger repository size

### 3.3 Mix Compiler Integration

**Mechanism:**
```elixir
# lib/mix/tasks/compile/snakebridge.ex
defmodule Mix.Tasks.Compile.Snakebridge do
  use Mix.Task.Compiler

  def run(_args) do
    # Generate source files
    manifests = scan_manifests()

    Enum.each(manifests, fn manifest ->
      generate_and_write_module(manifest)
    end)

    {:ok, []}  # Return compilation status
  end

  def clean do
    # Clean generated files
    File.rm_rf!("lib/snakebridge/generated")
  end
end

# mix.exs
def project do
  [
    compilers: [:snakebridge] ++ Mix.compilers(),
    # ...
  ]
end
```

**Advantages:**
- ✅ Automatic on `mix compile`
- ✅ Incremental compilation
- ✅ Dependency tracking
- ✅ Standard Mix workflow
- ✅ `mix clean` integration

**Pattern used by:**
- Phoenix (view compilation)
- Ecto (schema compilation)
- Protocol implementations
- NimbleParsec (parser generation)

### 3.4 Module.create/3 Approach

```elixir
# Runtime module creation
Module.create(MyModule, quote do
  def hello, do: :world
end, Macro.Env.location(__ENV__))
```

**Characteristics:**
- Bypasses normal compilation
- No source file
- Used for truly dynamic modules
- Limited metadata support

**Not recommended for v2** because:
- No ExDoc integration
- No Mix compiler integration
- Hard to debug
- Better suited for DSLs, not library wrappers

---

## 4. Documentation Generation Requirements

### 4.1 ExDoc Documentation Standards

ExDoc extracts documentation from:

1. **Module attributes**: `@moduledoc`, `@doc`, `@typedoc`
2. **Type specifications**: `@spec`, `@type`, `@callback`
3. **Metadata**: `@since`, `@deprecated`
4. **Markdown**: Full markdown support in docstrings

**High-quality example:**
```elixir
defmodule SnakeBridge.NumPy do
  @moduledoc """
  Elixir wrapper for NumPy array operations.

  NumPy is the fundamental package for scientific computing with Python.
  This module provides type-safe Elixir bindings to NumPy's core functionality.

  ## Installation

  Add to your `mix.exs`:

      config :snakebridge, load: [:numpy]

  The Python package will be installed automatically.

  ## Examples

      # Create array
      {:ok, arr} = NumPy.array(%{data: [1, 2, 3, 4]})

      # Reshape
      {:ok, reshaped} = NumPy.reshape(%{arr: arr, shape: [2, 2]})

      # Mathematical operations
      {:ok, result} = NumPy.sum(%{arr: arr})

  ## Type Mapping

  - Python `ndarray` → Elixir `NumPy.array_t()`
  - Python `dtype` → Elixir atom (`:int64`, `:float64`, etc.)

  ## Links

  - [NumPy Documentation](https://numpy.org/doc/)
  - [SnakeBridge Guide](https://hexdocs.pm/snakebridge)
  """

  @typedoc """
  NumPy array reference.

  Represents a Python NumPy array instance managed by SnakeBridge.
  The tuple contains `{session_id, instance_id}` for referencing
  the array in the Python runtime.
  """
  @type array_t :: {session_id :: String.t(), instance_id :: String.t()}

  @typedoc "NumPy data type specifier"
  @type dtype :: :int8 | :int16 | :int32 | :int64 |
                 :float16 | :float32 | :float64 |
                 :complex64 | :complex128 | :bool

  @doc """
  Create a NumPy array from Elixir data.

  ## Parameters

  - `data` - Nested list or flat list of numbers
  - `dtype` - Optional data type (default: inferred)
  - `order` - Memory layout: `:c` (row-major) or `:fortran` (column-major)

  ## Returns

  `{:ok, array_t()}` on success, `{:error, reason}` on failure.

  ## Examples

      # 1D array
      {:ok, arr} = NumPy.array(%{data: [1, 2, 3, 4]})

      # 2D array with specific dtype
      {:ok, arr} = NumPy.array(%{
        data: [[1, 2], [3, 4]],
        dtype: :float64
      })

      # With memory order
      {:ok, arr} = NumPy.array(%{
        data: [[1, 2], [3, 4]],
        order: :fortran
      })

  ## See also

  - `reshape/2` - Change array dimensions
  - `astype/2` - Convert data type
  """
  @spec array(map(), keyword()) :: {:ok, array_t()} | {:error, term()}
  def array(args \\ %{}, opts \\ [])

  # Implementation...
end
```

### 4.2 Parameter Documentation

Current limitation: SnakeBridge generates minimal parameter docs.

**Enhanced approach for v2:**
```elixir
def build_function_doc(function_desc) do
  name = get_field(function_desc, :name)
  docstring = get_field(function_desc, :docstring, "")
  params = get_field(function_desc, :parameters, [])
  return_type = get_field(function_desc, :return_type)
  examples = get_field(function_desc, :examples, [])

  param_docs = build_parameter_docs(params)
  return_docs = build_return_docs(return_type)
  example_docs = build_example_docs(examples, name)

  """
  #{format_summary(docstring)}

  #{param_docs}

  #{return_docs}

  #{example_docs}

  #{build_see_also(function_desc)}
  """
end

defp build_parameter_docs([]), do: ""
defp build_parameter_docs(params) do
  """
  ## Parameters

  #{Enum.map_join(params, "\n", &format_param/1)}
  """
end

defp format_param(%{name: name, type: type, required: required, docstring: doc}) do
  required_marker = if required, do: "(required)", else: "(optional)"
  type_str = format_type_for_doc(type)
  "- `#{name}` #{required_marker} - #{type_str} - #{doc}"
end
```

### 4.3 Metadata and Cross-References

```elixir
@doc """
See also: `reshape/2`, `astype/2`, `copy/1`
"""

@deprecated "Use reshape/2 instead"

@doc since: "0.3.0"
```

### 4.4 HexDocs Integration

For HexDocs publishing, modules must:
1. ✅ Be compiled with source files
2. ✅ Have proper `@moduledoc` and `@doc` attributes
3. ✅ Be included in `mix.exs` docs configuration
4. ✅ Pass through ExDoc processing

**Current blocker**: Runtime-generated modules skip ExDoc.

**v2 solution**: Generate source files, commit to git, publish to Hex with documentation.

---

## 5. Typespec Generation Patterns

### 5.1 Current Typespec Generation

```elixir
# lib/snakebridge/generator.ex (lines 184-196)
quote do
  @doc unquote(Helpers.build_function_doc(method))
  @spec unquote(elixir_name)(t(), map(), keyword()) ::
          {:ok, unquote(return_spec)} | {:error, term()}
  def unquote(elixir_name)(instance_ref, args \\ %{}, opts \\ []) do
    SnakeBridge.Runtime.call_method(
      instance_ref,
      unquote(method_name),
      args,
      opts
    )
  end
end
```

**Current approach:**
- Generic `map()` for arguments
- `keyword()` for options
- Return type based on Python return type
- Always wrapped in `{:ok, ...} | {:error, term()}`

### 5.2 Enhanced Typespec Patterns

**Structured argument types:**
```elixir
@type array_options :: %{
  required(:data) => list(),
  optional(:dtype) => dtype(),
  optional(:order) => :c | :fortran
}

@spec array(array_options(), keyword()) :: {:ok, array_t()} | {:error, term()}
```

**Union types from Python:**
```elixir
# Python: def parse(input: str | bytes) -> Dict[str, Any]
@spec parse(String.t() | binary(), keyword()) ::
  {:ok, %{String.t() => term()}} | {:error, term()}
```

**Optional parameters:**
```elixir
@spec reshape(array_t(), list(integer())) :: {:ok, array_t()} | {:error, term()}
@spec reshape(array_t(), list(integer()), order: :c | :fortran) ::
  {:ok, array_t()} | {:error, term()}
```

### 5.3 Type System Mapping Strategy

```elixir
# lib/snakebridge/type_system/mapper.ex enhancements

# Generate structured map type from parameters
def build_args_type(parameters) do
  required = Enum.filter(parameters, & &1.required)
  optional = Enum.filter(parameters, &(not &1.required))

  fields =
    Enum.map(required, fn p ->
      quote do: required(unquote(p.name)) => unquote(to_elixir_spec(p.type))
    end) ++
    Enum.map(optional, fn p ->
      quote do: optional(unquote(p.name)) => unquote(to_elixir_spec(p.type))
    end)

  quote do: %{unquote_splicing(fields)}
end
```

### 5.4 Custom Type Definitions

For complex Python types, generate Elixir type aliases:

```elixir
defmodule SnakeBridge.NumPy do
  @type dtype :: :int8 | :int16 | :int32 | :int64 |
                 :float16 | :float32 | :float64

  @type shape :: [non_neg_integer()]

  @type array_options :: %{
    required(:data) => list() | list(list()),
    optional(:dtype) => dtype(),
    optional(:order) => :c | :fortran,
    optional(:ndmin) => non_neg_integer()
  }
end
```

---

## 6. Module Creation Approaches

### 6.1 Comparison Matrix

| Approach | ExDoc | Dialyzer | IDE Support | Git Trackable | Mix Integration | Debug |
|----------|-------|----------|-------------|---------------|-----------------|-------|
| Runtime (`Code.compile_quoted`) | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |
| Source Files (current compile) | ✅ | ✅ | ✅ | ✅ | ⚠️ | ✅ |
| Mix Compiler | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| `Module.create/3` | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ |

### 6.2 Recommended: Mix Compiler + Source Files

**Implementation pattern:**

```elixir
# lib/mix/tasks/compile/snakebridge.ex
defmodule Mix.Tasks.Compile.Snakebridge do
  use Mix.Task.Compiler

  @recursive true
  @manifest ".compile.snakebridge"

  @impl true
  def run(args) do
    config = Mix.Project.config()
    manifest_path = manifest_path(config)

    # Load previous manifest
    previous = load_manifest(manifest_path)

    # Scan for manifest files
    {manifest_files, _errors} = scan_manifests()

    # Check if recompilation needed
    stale? = check_stale(previous, manifest_files)

    if stale? do
      # Clean old files
      clean_generated()

      # Generate new files
      results = Enum.map(manifest_files, &generate_module/1)

      # Save manifest
      save_manifest(manifest_path, results)

      {:ok, warnings(results)}
    else
      {:noop, []}
    end
  end

  @impl true
  def clean do
    config = Mix.Project.config()
    File.rm(manifest_path(config))
    clean_generated()
  end

  @impl true
  def manifests do
    [manifest_path(Mix.Project.config())]
  end

  # Private

  defp generate_module(manifest_file) do
    {:ok, config} = SnakeBridge.Manifest.from_file(manifest_file)

    config
    |> SnakeBridge.Generator.generate_all_ast()
    |> Enum.map(&write_source_file/1)
  end

  defp write_source_file(ast) do
    module = extract_module_name(ast)
    file_path = output_path(module)

    source =
      ast
      |> format_ast_with_docs()
      |> add_header_comment()

    File.mkdir_p!(Path.dirname(file_path))
    File.write!(file_path, source)

    file_path
  end

  defp format_ast_with_docs(ast) do
    # Special handling to preserve documentation formatting
    ast
    |> Macro.to_string()
    |> Code.format_string!(line_length: 98)
    |> IO.iodata_to_binary()
  end
end
```

**mix.exs integration:**
```elixir
def project do
  [
    app: :snakebridge,
    compilers: [:snakebridge] ++ Mix.compilers(),
    # ...
  ]
end
```

### 6.3 Hybrid Approach for Development

Support both approaches:

```elixir
# config/config.exs
config :snakebridge,
  compilation_mode: :auto  # :compile_time | :runtime | :auto

# auto mode:
# - compile_time in prod
# - runtime in dev/test for fast iteration
```

**Auto mode logic:**
```elixir
def compilation_mode do
  configured = Application.get_env(:snakebridge, :compilation_mode, :auto)

  case configured do
    :auto ->
      if Mix.env() == :prod, do: :compile_time, else: :runtime
    mode ->
      mode
  end
end
```

---

## 7. Mix Compiler Integration

### 7.1 Mix.Task.Compiler Behaviour

Required callbacks:

```elixir
defmodule Mix.Tasks.Compile.Snakebridge do
  use Mix.Task.Compiler

  @impl true
  def run(args) do
    # Return: {:ok, warnings} | {:noop, []} | {:error, errors}
  end

  @impl true
  def clean() do
    # Clean generated files
  end

  @impl true
  def manifests() do
    # Return list of manifest files for dependency tracking
  end
end
```

### 7.2 Incremental Compilation

Track changes to avoid unnecessary recompilation:

```elixir
defp check_stale(previous_manifest, current_files) do
  # Check if manifest files changed
  manifest_changed? =
    current_files
    |> Enum.any?(fn file ->
      mtime = File.stat!(file).mtime
      previous_mtime = Map.get(previous_manifest, file)
      previous_mtime != mtime
    end)

  # Check if generator code changed
  generator_changed? =
    generator_modules_modified?(previous_manifest.generator_hash)

  manifest_changed? or generator_changed?
end

defp generator_modules_modified?(previous_hash) do
  current_hash =
    [SnakeBridge.Generator, SnakeBridge.Generator.Helpers]
    |> Enum.map(&module_source_hash/1)
    |> :erlang.phash2()

  current_hash != previous_hash
end
```

### 7.3 Dependency Tracking

```elixir
# In mix.exs
def project do
  [
    compilers: [:snakebridge] ++ Mix.compilers(),
    snakebridge: [
      manifest_dir: "priv/snakebridge/manifests",
      output_dir: "lib/snakebridge/generated",
      watch: ["priv/snakebridge/manifests/**/*.json"]
    ]
  ]
end
```

### 7.4 Error Reporting

```elixir
defp generate_module(manifest_file) do
  case SnakeBridge.Manifest.from_file(manifest_file) do
    {:ok, config} ->
      generate_sources(config)

    {:error, errors} ->
      # Return Mix-formatted errors
      Enum.map(errors, fn error ->
        %Mix.Task.Compiler.Diagnostic{
          file: manifest_file,
          severity: :error,
          message: error,
          compiler_name: "snakebridge"
        }
      end)
  end
end
```

---

## 8. Recommended v2 Architecture

### 8.1 High-Level Design

```
┌─────────────────────────────────────────────────────────┐
│                   Python Introspection                   │
│  (mix snakebridge.discover numpy --output numpy.json)   │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              Manifest Creation/Editing                   │
│   - AI-assisted curation (adapter.create)               │
│   - Manual review and enhancement                        │
│   - Type annotation enrichment                           │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│         JSON Manifest (Single Source of Truth)          │
│  priv/snakebridge/manifests/numpy.json                  │
│   - Function signatures                                  │
│   - Type information                                     │
│   - Documentation                                        │
│   - Examples                                             │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              Mix Compiler Integration                    │
│  (mix compile.snakebridge)                              │
│   - Automatic on 'mix compile'                          │
│   - Incremental compilation                             │
│   - Change detection                                     │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│           Enhanced AST Generation                        │
│  SnakeBridge.Generator.V2                               │
│   - Rich @moduledoc with examples                       │
│   - Detailed @doc for each function                     │
│   - Structured @spec with typed maps                    │
│   - @type definitions for complex types                 │
│   - Cross-references and links                          │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│          Source File Generation                          │
│  lib/snakebridge/generated/numpy.ex                     │
│   - Formatted, readable source code                     │
│   - Git-trackable                                       │
│   - IDE-friendly                                        │
│   - Dialyzer-analyzable                                 │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              Standard Mix Compilation                    │
│   - Elixir compiler processes .ex files                 │
│   - Documentation extracted by ExDoc                    │
│   - Type specs available to Dialyzer                    │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│                 Published Package                        │
│   - HexDocs with full documentation                     │
│   - Autocomplete in IDEs                                │
│   - Type checking with Dialyzer                         │
│   - Standard Elixir developer experience                │
└─────────────────────────────────────────────────────────┘
```

### 8.2 Key Principles

1. **Single Source of Truth**: Manifests are authoritative
2. **Compile-Time by Default**: Generated source files committed to git
3. **Development Flexibility**: Optional runtime mode for fast iteration
4. **Standard Tooling**: Full integration with Mix, ExDoc, Dialyzer
5. **Quality Documentation**: HexDocs-ready from day one
6. **Type Safety**: Rich typespecs for better DX and safety

### 8.3 Module Structure Template

```elixir
defmodule SnakeBridge.NumPy do
  @moduledoc """
  Elixir wrapper for NumPy (Numerical Python).

  [Full module documentation with examples, installation, usage]
  """

  # Type definitions
  @type array_t :: SnakeBridge.Runtime.instance_ref()
  @type dtype :: :int8 | :int16 | :int32 | :int64 | ...
  @type array_options :: %{
    required(:data) => list() | nested_list(),
    optional(:dtype) => dtype(),
    optional(:order) => :c | :fortran
  }

  # Runtime configuration
  @python_module "numpy"
  @config %SnakeBridge.Config{...}

  # Functions
  @doc """
  Create NumPy array from Elixir data.

  [Detailed documentation]
  """
  @spec array(array_options(), keyword()) ::
    {:ok, array_t()} | {:error, term()}
  def array(args \\ %{}, opts \\ []) do
    session_id = Keyword.get(opts, :session_id, generate_session_id())

    SnakeBridge.Runtime.call_function(
      "numpy.array",
      "array",
      args,
      Keyword.put(opts, :session_id, session_id)
    )
  end

  # ... more functions

  # Private helpers
  defp generate_session_id do
    SnakeBridge.SessionId.generate("session")
  end
end
```

### 8.4 Generator v2 Enhancements

```elixir
defmodule SnakeBridge.Generator.V2 do
  @moduledoc """
  Enhanced generator for v2 with rich documentation.
  """

  def generate_module(descriptor, config) do
    quote do
      defmodule unquote(module_name) do
        @moduledoc unquote(build_rich_moduledoc(descriptor, config))

        # Type definitions
        unquote_splicing(generate_type_definitions(descriptor))

        # Configuration
        @python_module unquote(config.python_module)
        @config unquote(Macro.escape(config))

        # Functions with rich docs
        unquote_splicing(generate_functions_v2(descriptor.functions, config))

        # Private helpers
        unquote(generate_private_helpers())
      end
    end
  end

  defp build_rich_moduledoc(descriptor, config) do
    """
    #{build_summary(descriptor)}

    #{build_installation_section(config)}

    #{build_examples_section(descriptor)}

    #{build_type_mapping_section(descriptor)}

    #{build_links_section(config)}

    ---

    *This module was automatically generated by SnakeBridge v#{snakebridge_version()}.*
    """
  end

  defp generate_functions_v2(functions, config) do
    Enum.map(functions, fn func ->
      quote do
        @doc unquote(build_rich_function_doc(func, config))
        @spec unquote(build_detailed_spec(func))
        def unquote(func.elixir_name)(unquote_splicing(build_args(func))) do
          unquote(build_function_body(func, config))
        end
      end
    end)
  end

  defp build_detailed_spec(func) do
    args_type = build_structured_args_type(func.parameters)
    return_type = TypeMapper.to_elixir_spec(func.return_type)

    quote do
      @spec unquote(func.elixir_name)(unquote(args_type), keyword()) ::
        {:ok, unquote(return_type)} | {:error, term()}
    end
  end
end
```

---

## 9. Implementation Roadmap

### Phase 1: Foundation (Week 1)

**Goal**: Set up compile-time infrastructure

1. Create `Mix.Tasks.Compile.Snakebridge`
2. Implement basic source file generation
3. Add to `mix.exs` compilers list
4. Test with simple manifest (e.g., json)

**Deliverables**:
- [ ] Working Mix compiler
- [ ] Source files in `lib/snakebridge/generated/`
- [ ] `mix compile` generates modules
- [ ] `mix clean` removes generated files

### Phase 2: Documentation Enhancement (Week 2)

**Goal**: Generate rich, HexDocs-quality documentation

1. Enhance `build_moduledoc` with structured sections
2. Add parameter documentation to function docs
3. Generate examples from manifest metadata
4. Add cross-references and links
5. Implement `@since`, `@deprecated` support

**Deliverables**:
- [ ] Rich @moduledoc with examples
- [ ] Detailed @doc with parameter descriptions
- [ ] Working ExDoc generation
- [ ] Sample HexDocs output

### Phase 3: Type System v2 (Week 3)

**Goal**: Generate precise, helpful type specifications

1. Implement structured args type generation
2. Add custom @type definitions per module
3. Support union types from Python
4. Generate @typedoc for complex types
5. Dialyzer integration testing

**Deliverables**:
- [ ] Structured map types for args
- [ ] Custom @type definitions
- [ ] @typedoc annotations
- [ ] Passing Dialyzer checks

### Phase 4: Developer Experience (Week 4)

**Goal**: Optimize for daily development workflow

1. Implement incremental compilation
2. Add configuration for compile-time vs runtime
3. Improve error messages
4. Add IDE support (goto definition, autocomplete)
5. Performance optimization

**Deliverables**:
- [ ] Fast incremental compilation
- [ ] Hybrid mode (dev vs prod)
- [ ] Helpful error messages
- [ ] Working IDE integration

### Phase 5: Migration & Testing (Week 5)

**Goal**: Migrate existing manifests, comprehensive testing

1. Migrate all built-in manifests to v2
2. Regenerate with new generator
3. Test all generated modules
4. Update examples and documentation
5. Performance benchmarking

**Deliverables**:
- [ ] All manifests on v2
- [ ] Comprehensive test suite
- [ ] Performance benchmarks
- [ ] Migration guide

---

## Appendix A: Code Examples

### A.1 Complete Generated Module Example

```elixir
# lib/snakebridge/generated/numpy.ex
# Generated by SnakeBridge v2.0.0 on 2025-12-24

defmodule SnakeBridge.NumPy do
  @moduledoc """
  Elixir wrapper for NumPy (Numerical Python).

  NumPy is the fundamental package for scientific computing in Python.
  It provides a high-performance multidimensional array object and tools
  for working with these arrays.

  ## Installation

  Add to your `config/config.exs`:

      config :snakebridge, load: [:numpy]

  The NumPy Python package will be installed automatically on first use.

  ## Basic Usage

      # Create an array
      {:ok, arr} = NumPy.array(%{data: [1, 2, 3, 4, 5]})

      # Reshape
      {:ok, reshaped} = NumPy.reshape(arr, %{newshape: [5, 1]})

      # Mathematical operations
      {:ok, sum} = NumPy.sum(arr)
      {:ok, mean} = NumPy.mean(arr)

  ## Type Mapping

  | Python Type | Elixir Type |
  |------------|-------------|
  | `ndarray` | `array_t()` |
  | `dtype` | `:int64`, `:float64`, etc. |
  | `int` | `integer()` |
  | `float` | `float()` |

  ## Links

  - [NumPy Documentation](https://numpy.org/doc/)
  - [NumPy GitHub](https://github.com/numpy/numpy)
  - [SnakeBridge Guide](https://hexdocs.pm/snakebridge)

  ---

  *Generated by SnakeBridge v2.0.0*
  """

  @python_module "numpy"
  @python_path_prefix "bridges.numpy_bridge"

  # Type Definitions

  @typedoc """
  Reference to a NumPy array in the Python runtime.

  The tuple contains `{session_id, instance_id}` for tracking
  the array across function calls.
  """
  @type array_t :: {session_id :: String.t(), instance_id :: String.t()}

  @typedoc "NumPy data type specifier"
  @type dtype ::
    :int8 | :int16 | :int32 | :int64 |
    :uint8 | :uint16 | :uint32 | :uint64 |
    :float16 | :float32 | :float64 |
    :complex64 | :complex128 |
    :bool

  @typedoc "Memory layout order"
  @type order :: :c | :fortran

  @type array_options :: %{
    required(:data) => list() | list(list()),
    optional(:dtype) => dtype(),
    optional(:order) => order(),
    optional(:ndmin) => non_neg_integer()
  }

  # Public API

  @doc """
  Create a NumPy array from Elixir data.

  Converts an Elixir list (or nested list) into a NumPy ndarray.

  ## Parameters

  - `data` (required) - List or nested list of numbers
  - `dtype` (optional) - Data type for the array elements. If not specified,
    NumPy will infer the type from the data.
  - `order` (optional) - Memory layout: `:c` for C-contiguous (row-major),
    `:fortran` for Fortran-contiguous (column-major). Default: `:c`
  - `ndmin` (optional) - Minimum number of dimensions. Default: 0

  ## Returns

  - `{:ok, array_t()}` - Success with array reference
  - `{:error, reason}` - Error with details

  ## Examples

      # 1D array
      {:ok, arr} = NumPy.array(%{data: [1, 2, 3, 4, 5]})

      # 2D array with specific dtype
      {:ok, arr} = NumPy.array(%{
        data: [[1.0, 2.0], [3.0, 4.0]],
        dtype: :float64
      })

      # Force minimum dimensions
      {:ok, arr} = NumPy.array(%{
        data: [1, 2, 3],
        ndmin: 2
      })
      # Results in shape (1, 3)

      # Fortran-order (column-major)
      {:ok, arr} = NumPy.array(%{
        data: [[1, 2], [3, 4]],
        order: :fortran
      })

  ## See Also

  - `zeros/1` - Create array filled with zeros
  - `ones/1` - Create array filled with ones
  - `reshape/2` - Change array shape
  """
  @spec array(array_options(), keyword()) :: {:ok, array_t()} | {:error, term()}
  def array(args \\ %{}, opts \\ []) do
    session_id = Keyword.get(opts, :session_id, generate_session_id())

    SnakeBridge.Runtime.call_function(
      "numpy.array",
      "array",
      args,
      Keyword.put(opts, :session_id, session_id)
    )
  end

  @doc """
  Reshape an array to a new shape.

  Returns a new array with the same data but different dimensions.
  The new shape must be compatible with the original shape (same
  total number of elements).

  ## Parameters

  - `arr` (required) - Array reference from `array/2` or similar
  - `newshape` (required) - List of integers specifying new dimensions.
    One dimension can be -1, which will be inferred.
  - `order` (optional) - Memory layout for the new array

  ## Returns

  - `{:ok, array_t()}` - Reshaped array
  - `{:error, reason}` - Error if shapes are incompatible

  ## Examples

      {:ok, arr} = NumPy.array(%{data: [1, 2, 3, 4, 5, 6]})

      # Reshape to 2x3
      {:ok, reshaped} = NumPy.reshape(arr, %{newshape: [2, 3]})

      # Infer one dimension
      {:ok, reshaped} = NumPy.reshape(arr, %{newshape: [-1, 2]})
      # Results in (3, 2)

  ## See Also

  - `array/2` - Create arrays
  - `flatten/1` - Flatten to 1D
  """
  @spec reshape(array_t(), %{required(:newshape) => [integer()]}, keyword()) ::
    {:ok, array_t()} | {:error, term()}
  def reshape(arr, args \\ %{}, opts \\ [])

  # ... more functions

  # Private Helpers

  defp generate_session_id do
    SnakeBridge.SessionId.generate("session")
  end
end
```

### A.2 Mix Compiler Implementation

```elixir
# lib/mix/tasks/compile/snakebridge.ex
defmodule Mix.Tasks.Compile.Snakebridge do
  @moduledoc """
  Mix compiler for SnakeBridge generated modules.

  Automatically generates Elixir source files from manifest files
  when running `mix compile`.

  ## Configuration

      # mix.exs
      def project do
        [
          compilers: [:snakebridge] ++ Mix.compilers(),
          snakebridge: [
            manifest_dir: "priv/snakebridge/manifests",
            output_dir: "lib/snakebridge/generated"
          ]
        ]
      end
  """

  use Mix.Task.Compiler
  require Logger

  @recursive true
  @manifest_vsn 1

  @impl Mix.Task.Compiler
  def run(_args) do
    config = snakebridge_config()
    manifest = load_manifest(config)

    # Scan for manifest files
    manifest_files = scan_manifest_files(config.manifest_dir)

    # Check if recompilation needed
    if needs_recompile?(manifest, manifest_files) do
      Logger.info("Compiling SnakeBridge modules...")

      # Clean old generated files
      clean_output_dir(config.output_dir)

      # Generate modules
      {generated, warnings} = generate_modules(manifest_files, config)

      # Save new manifest
      save_manifest(config, generated)

      Logger.info("Generated #{length(generated)} modules")
      {:ok, warnings}
    else
      {:noop, []}
    end
  end

  @impl Mix.Task.Compiler
  def clean do
    config = snakebridge_config()
    File.rm_rf!(config.output_dir)
    File.rm(manifest_path(config))
    :ok
  end

  @impl Mix.Task.Compiler
  def manifests do
    config = snakebridge_config()
    [manifest_path(config)]
  end

  # Private

  defp snakebridge_config do
    project = Mix.Project.config()
    user_config = Keyword.get(project, :snakebridge, [])

    %{
      manifest_dir: Keyword.get(user_config, :manifest_dir, "priv/snakebridge/manifests"),
      output_dir: Keyword.get(user_config, :output_dir, "lib/snakebridge/generated"),
      compile_elixir_path: Mix.Project.compile_path(project)
    }
  end

  defp manifest_path(config) do
    Path.join(config.compile_elixir_path, ".compile.snakebridge")
  end

  defp load_manifest(config) do
    path = manifest_path(config)

    case File.read(path) do
      {:ok, binary} ->
        :erlang.binary_to_term(binary)
      {:error, _} ->
        %{vsn: @manifest_vsn, files: %{}, generator_hash: nil}
    end
  end

  defp save_manifest(config, generated_files) do
    manifest = %{
      vsn: @manifest_vsn,
      files: Map.new(generated_files, fn {source, output} ->
        {source, %{
          output: output,
          mtime: File.stat!(source).mtime,
          hash: file_hash(source)
        }}
      end),
      generator_hash: generator_hash()
    }

    binary = :erlang.term_to_binary(manifest)
    File.write!(manifest_path(config), binary)
  end

  defp needs_recompile?(manifest, manifest_files) do
    # Check version
    if manifest.vsn != @manifest_vsn do
      true
    else
      # Check if generator code changed
      generator_changed? = manifest.generator_hash != generator_hash()

      # Check if any manifest file changed
      manifests_changed? =
        Enum.any?(manifest_files, fn file ->
          cached = Map.get(manifest.files, file)
          not cached or cached.hash != file_hash(file)
        end)

      # Check if manifest files were added/removed
      files_changed? =
        MapSet.new(Map.keys(manifest.files)) != MapSet.new(manifest_files)

      generator_changed? or manifests_changed? or files_changed?
    end
  end

  defp scan_manifest_files(dir) do
    Path.join(dir, "*.json")
    |> Path.wildcard()
    |> Enum.reject(&String.ends_with?(&1, "_index.json"))
  end

  defp generate_modules(manifest_files, config) do
    results =
      Enum.map(manifest_files, fn file ->
        generate_from_manifest(file, config)
      end)

    generated =
      results
      |> Enum.filter(&match?({:ok, _}, &1))
      |> Enum.flat_map(fn {:ok, files} -> files end)

    warnings =
      results
      |> Enum.filter(&match?({:warning, _}, &1))
      |> Enum.flat_map(fn {:warning, warns} -> warns end)

    {generated, warnings}
  end

  defp generate_from_manifest(manifest_file, config) do
    case SnakeBridge.Manifest.from_file(manifest_file) do
      {:ok, sb_config} ->
        asts = SnakeBridge.Generator.V2.generate_all_ast(sb_config)

        files =
          Enum.map(asts, fn ast ->
            output_file = write_source_file(ast, config.output_dir)
            {manifest_file, output_file}
          end)

        {:ok, files}

      {:error, errors} ->
        warnings =
          Enum.map(errors, fn error ->
            %Mix.Task.Compiler.Diagnostic{
              file: manifest_file,
              severity: :error,
              message: error,
              compiler_name: "snakebridge",
              position: 1
            }
          end)

        {:warning, warnings}
    end
  end

  defp write_source_file(ast, output_dir) do
    module_name = extract_module_name(ast)
    relative_path = module_to_path(module_name)
    output_file = Path.join(output_dir, relative_path)

    source = format_source(ast)

    File.mkdir_p!(Path.dirname(output_file))
    File.write!(output_file, source)

    output_file
  end

  defp format_source(ast) do
    header = """
    # Generated by SnakeBridge v#{snakebridge_version()}
    # DO NOT EDIT - Changes will be overwritten

    """

    body =
      ast
      |> Macro.to_string()
      |> Code.format_string!(line_length: 98)
      |> IO.iodata_to_binary()

    header <> body <> "\n"
  end

  defp extract_module_name({:defmodule, _meta, [module_ast, _body]}) do
    module_from_ast(module_ast)
  end

  defp module_from_ast({:__aliases__, _meta, parts}), do: Module.concat(parts)
  defp module_from_ast(module) when is_atom(module), do: module

  defp module_to_path(module) do
    module
    |> Atom.to_string()
    |> String.replace_prefix("Elixir.", "")
    |> Macro.underscore()
    |> Kernel.<>(".ex")
  end

  defp file_hash(path) do
    path
    |> File.read!()
    |> :erlang.phash2()
  end

  defp generator_hash do
    [
      SnakeBridge.Generator.V2,
      SnakeBridge.Generator.Helpers,
      SnakeBridge.TypeSystem.Mapper
    ]
    |> Enum.map(fn module ->
      module.module_info(:md5)
    end)
    |> :erlang.phash2()
  end

  defp snakebridge_version do
    Application.spec(:snakebridge, :vsn) |> to_string()
  end

  defp clean_output_dir(dir) do
    if File.dir?(dir) do
      File.rm_rf!(dir)
    end
    File.mkdir_p!(dir)
  end
end
```

---

## Appendix B: References

### B.1 Elixir Documentation

- [Elixir Metaprogramming Guide](https://elixir-lang.org/getting-started/meta/quote-and-unquote.html)
- [Mix.Task.Compiler Behaviour](https://hexdocs.pm/mix/Mix.Task.Compiler.html)
- [ExDoc Documentation](https://hexdocs.pm/ex_doc/readme.html)
- [Writing Documentation](https://hexdocs.pm/elixir/writing-documentation.html)

### B.2 Example Projects

- **Ecto**: Schema compilation, query AST generation
- **Phoenix**: View and template compilation
- **Absinthe**: GraphQL schema compilation
- **NimbleParsec**: Parser generation from PEG grammars

### B.3 Relevant Elixir Features

- Module attributes (`@moduledoc`, `@doc`, `@spec`, `@type`)
- `quote`/`unquote` for AST manipulation
- `Macro.to_string` and `Code.format_string!` for code generation
- Mix compiler behaviour for build integration
- ExDoc for documentation generation

---

## Conclusion

For SnakeBridge v2, the **recommended approach** is:

1. **Generate source files** in `lib/snakebridge/generated/`
2. **Integrate with Mix compiler** via `Mix.Tasks.Compile.Snakebridge`
3. **Commit generated files** to version control
4. **Rich documentation** with examples, parameter docs, cross-references
5. **Structured type specs** with typed maps and custom types
6. **Hybrid mode** for development flexibility

This approach provides:
- ✅ Full ExDoc/HexDocs integration
- ✅ IDE support (autocomplete, goto definition)
- ✅ Dialyzer type checking
- ✅ Git-trackable changes
- ✅ Standard Elixir developer experience
- ✅ Production-ready code quality

The v2 architecture positions SnakeBridge as a **first-class Elixir library generator**, producing modules indistinguishable from hand-written Elixir code.
