# SnakeBridge v2.1 Requirements

## Overview

SnakeBridge v2.1 enhances the generator to produce clean, modular code structures that mirror Python module organization, with built-in discovery, documentation, and registry capabilities.

## Goals

1. **Modular Code Generation** - Generate logical file/module hierarchies, not monolithic files
2. **Self-Documenting** - Generated code is instantly discoverable via IEx and ExDoc
3. **Registry System** - Simple manifest tracking what's generated for agent introspection
4. **Clean Regeneration** - Ability to cleanly remove and regenerate any library
5. **Zero Friction** - From `mix snakebridge.gen <lib>` to working code in seconds

---

## 1. Modular Code Structure

### Current Problem
```
lib/snakebridge/adapters/sympy.ex  # 278,000 lines - unusable
```

### New Structure
```
lib/snakebridge/adapters/
├── sympy/
│   ├── sympy.ex              # Main module with top-level functions
│   ├── core.ex               # sympy.core functions
│   ├── solvers.ex            # sympy.solvers functions
│   ├── matrices.ex           # sympy.matrices functions
│   ├── classes/
│   │   ├── symbol.ex         # Symbol class
│   │   ├── expr.ex           # Expr class
│   │   └── matrix.ex         # Matrix class
│   └── _meta.ex              # Discovery helpers, registry info
├── numpy/
│   ├── numpy.ex
│   ├── linalg.ex
│   ├── fft.ex
│   └── _meta.ex
└── json/
    ├── json.ex
    └── _meta.ex
```

### Rules

1. **One module per file** - Standard Elixir convention
2. **Directory per library** - `lib/snakebridge/adapters/<library>/`
3. **Submodules for namespaces** - Python `sympy.solvers` → `Sympy.Solvers` in `solvers.ex`
4. **Classes in `classes/` subdirectory** - Keep classes separate from functions
5. **Meta module** - Every library gets a `_meta.ex` with discovery helpers
6. **Max file size** - Split files exceeding 1000 lines into logical chunks

### Module Naming

```
Python                    Elixir Module              File
------                    -------------              ----
sympy                     Sympy                      sympy/sympy.ex
sympy.solve (function)    Sympy.solve/2              sympy/sympy.ex
sympy.solvers             Sympy.Solvers              sympy/solvers.ex
sympy.Symbol (class)      Sympy.Symbol               sympy/classes/symbol.ex
numpy.linalg              Numpy.Linalg               numpy/linalg.ex
numpy.linalg.norm         Numpy.Linalg.norm/1        numpy/linalg.ex
```

---

## 2. Enhanced Generation Output

### After Running `mix snakebridge.gen numpy`

```
Introspecting Python library: numpy...

Generated: lib/snakebridge/adapters/numpy/
  ├── numpy.ex          (42 functions)
  ├── linalg.ex         (28 functions)
  ├── fft.ex            (15 functions)
  ├── random.ex         (23 functions)
  ├── classes/
  │   ├── ndarray.ex    (45 methods)
  │   └── matrix.ex     (12 methods)
  └── _meta.ex          (discovery helpers)

Total: 165 functions, 2 classes

Quick start:
  iex> alias Numpy
  iex> Numpy.array([1, 2, 3])
  iex> Numpy.Linalg.norm(arr)

Discovery:
  iex> Numpy.__functions__()      # List all functions
  iex> Numpy.__search__("matrix") # Search functions
  iex> h Numpy.array              # View docs

Full docs:
  mix docs --open
```

---

## 3. Discovery Helpers (Meta Module)

Every generated library includes a `_meta.ex` file that defines discovery functions.

### Generated `_meta.ex` Example

```elixir
defmodule Numpy.Meta do
  @moduledoc false

  @functions [
    {:array, 1, Numpy, "Create an array from a list"},
    {:zeros, 1, Numpy, "Return array of zeros"},
    {:linalg_norm, 2, Numpy.Linalg, "Matrix or vector norm"},
    # ...
  ]

  @classes [
    {Numpy.Ndarray, "N-dimensional array"},
    {Numpy.Matrix, "Matrix class"},
  ]

  @submodules [
    Numpy,
    Numpy.Linalg,
    Numpy.Fft,
    Numpy.Random,
  ]

  def functions, do: @functions
  def classes, do: @classes
  def submodules, do: @submodules

  def search(query) do
    query = String.downcase(query)
    Enum.filter(@functions, fn {name, _, _, doc} ->
      String.contains?(Atom.to_string(name), query) or
      String.contains?(String.downcase(doc), query)
    end)
  end
end
```

### Main Module Integration

The main module (e.g., `Numpy`) delegates to Meta:

```elixir
defmodule Numpy do
  @moduledoc "NumPy - numerical computing for Python..."
  use SnakeBridge.Adapter, library: "numpy"

  # Discovery helpers
  defdelegate __functions__, to: Numpy.Meta, as: :functions
  defdelegate __classes__, to: Numpy.Meta, as: :classes
  defdelegate __submodules__, to: Numpy.Meta, as: :submodules
  defdelegate __search__(query), to: Numpy.Meta, as: :search

  # Generated functions...
  @doc "Create an array..."
  @spec array(any()) :: {:ok, any()} | {:error, any()}
  def array(object) do
    __python_call__("numpy", "array", %{"object" => object})
  end
end
```

---

## 4. Registry System

### Purpose

Allow agents and tools to introspect what libraries are generated without parsing code.

### Registry File

```
priv/snakebridge/registry.json
```

### Registry Format

```json
{
  "version": "2.1",
  "generated_at": "2024-12-24T15:30:00Z",
  "libraries": {
    "numpy": {
      "python_module": "numpy",
      "python_version": "1.26.0",
      "elixir_module": "Numpy",
      "generated_at": "2024-12-24T14:00:00Z",
      "path": "lib/snakebridge/adapters/numpy/",
      "files": [
        "numpy.ex",
        "linalg.ex",
        "fft.ex",
        "random.ex",
        "classes/ndarray.ex",
        "classes/matrix.ex",
        "_meta.ex"
      ],
      "stats": {
        "functions": 165,
        "classes": 2,
        "submodules": 4
      }
    },
    "json": {
      "python_module": "json",
      "python_version": "2.0.9",
      "elixir_module": "Json",
      "generated_at": "2024-12-24T15:00:00Z",
      "path": "lib/snakebridge/adapters/json/",
      "files": ["json.ex", "_meta.ex"],
      "stats": {
        "functions": 4,
        "classes": 3,
        "submodules": 1
      }
    }
  }
}
```

### Registry API

```elixir
# Runtime access
SnakeBridge.Registry.list_libraries()
# => ["numpy", "json"]

SnakeBridge.Registry.get("numpy")
# => %{elixir_module: Numpy, functions: 165, ...}

SnakeBridge.Registry.generated?("numpy")
# => true
```

### Mix Task Integration

```bash
# List what's generated
mix snakebridge.list

Generated libraries:
  numpy    (165 functions, 2 classes)  lib/snakebridge/adapters/numpy/
  json     (4 functions, 3 classes)    lib/snakebridge/adapters/json/

# Show details
mix snakebridge.info numpy

Library: numpy
Python module: numpy (version 1.26.0)
Elixir module: Numpy
Generated: 2024-12-24 14:00:00

Files:
  lib/snakebridge/adapters/numpy/numpy.ex      (42 functions)
  lib/snakebridge/adapters/numpy/linalg.ex     (28 functions)
  ...

Submodules:
  Numpy, Numpy.Linalg, Numpy.Fft, Numpy.Random
```

---

## 5. Clean Regeneration

### Remove Command

```bash
# Remove a generated library
mix snakebridge.remove numpy

Removing numpy...
  Deleted: lib/snakebridge/adapters/numpy/
  Updated: priv/snakebridge/registry.json

Done. Run `mix snakebridge.gen numpy` to regenerate.
```

### Regenerate (Force)

```bash
# Regenerate, removing old files first
mix snakebridge.gen numpy --force

Removing existing numpy adapter...
Introspecting Python library: numpy...
Generated: lib/snakebridge/adapters/numpy/
...
```

### Clean All

```bash
# Remove all generated adapters
mix snakebridge.clean

This will remove all generated adapters:
  - numpy (165 functions)
  - json (4 functions)

Continue? [y/N] y

Removed 2 libraries.
Registry cleared.
```

---

## 6. Mix Tasks Summary

| Task | Description |
|------|-------------|
| `mix snakebridge.gen <lib>` | Generate adapter for Python library |
| `mix snakebridge.gen <lib> --force` | Regenerate (removes existing first) |
| `mix snakebridge.remove <lib>` | Remove generated adapter |
| `mix snakebridge.clean` | Remove all generated adapters |
| `mix snakebridge.list` | List generated libraries |
| `mix snakebridge.info <lib>` | Show details about generated library |

---

## 7. Implementation Requirements

### Code Quality

- [ ] All tests passing (`mix test`)
- [ ] No compiler warnings
- [ ] Dialyzer clean (`mix dialyzer`)
- [ ] Credo clean (`mix credo --strict`)
- [ ] Formatted (`mix format --check-formatted`)

### Test Coverage

- [ ] Unit tests for generator modules
- [ ] Integration tests for mix tasks
- [ ] Registry CRUD tests
- [ ] Regeneration/cleanup tests
- [ ] Discovery helper tests

### Files to Create/Modify

**New Files:**
- `lib/snakebridge/registry.ex` - Registry API
- `lib/mix/tasks/snakebridge/remove.ex` - Remove task
- `lib/mix/tasks/snakebridge/clean.ex` - Clean task
- `lib/mix/tasks/snakebridge/list.ex` - List task
- `lib/mix/tasks/snakebridge/info.ex` - Info task
- `test/snakebridge/registry_test.exs`
- `test/mix/tasks/snakebridge/*_test.exs`

**Modify:**
- `lib/snakebridge/generator/source_writer.ex` - Multi-file generation
- `lib/mix/tasks/snakebridge/gen.ex` - Enhanced output, registry update
- `priv/python/introspect.py` - Add submodule detection

---

## 8. File Size Guidelines

To keep generated code manageable:

| Content | Max Lines | Action if exceeded |
|---------|-----------|-------------------|
| Single module | 500 | Split by category |
| Single file | 1000 | Split into submodules |
| Classes | 200 each | One file per class |
| Total library | 5000 | Warning in output |

---

## 9. Example: Full numpy Generation

```bash
$ mix snakebridge.gen numpy

Introspecting Python library: numpy...
  Found 165 functions in 4 namespaces
  Found 2 classes with 57 methods

Generating Elixir adapters...
  Writing lib/snakebridge/adapters/numpy/numpy.ex
  Writing lib/snakebridge/adapters/numpy/linalg.ex
  Writing lib/snakebridge/adapters/numpy/fft.ex
  Writing lib/snakebridge/adapters/numpy/random.ex
  Writing lib/snakebridge/adapters/numpy/classes/ndarray.ex
  Writing lib/snakebridge/adapters/numpy/classes/matrix.ex
  Writing lib/snakebridge/adapters/numpy/_meta.ex

Updating registry...

Success! Generated numpy adapter:
  Path: lib/snakebridge/adapters/numpy/
  Module: Numpy
  Functions: 165
  Classes: 2
  Submodules: Numpy.Linalg, Numpy.Fft, Numpy.Random

Quick start:
  iex> alias Numpy
  iex> arr = Numpy.array([1, 2, 3, 4, 5])
  iex> Numpy.Linalg.norm(arr)

Discovery:
  iex> Numpy.__functions__()
  iex> Numpy.__search__("matrix")
  iex> h Numpy.array

$ mix docs --open  # View full documentation
```

---

## 10. Success Criteria

1. **Modular Output** - Large libraries split into logical files
2. **Fast Discovery** - `__functions__/0` and `__search__/1` in every adapter
3. **Registry Works** - `mix snakebridge.list` shows all generated libs
4. **Clean Regenerate** - `--force` removes old files before generating
5. **All Tests Pass** - `mix test` green
6. **No Warnings** - `mix compile --warnings-as-errors` clean
7. **Dialyzer Clean** - `mix dialyzer` no errors
8. **Documentation** - `mix docs` includes generated adapters
