# Determinism Strategy

Status: Design
Date: 2025-12-25

## Overview

Determinism is a first-class design constraint for SnakeBridge. The goal is:

> Given the same inputs, SnakeBridge produces byte-identical outputs.

This document defines what "same inputs" means, what "outputs" we control, and
how we guarantee stability.

## Why Determinism Matters

1. **CI Reproducibility**: Build on machine A, verify on machine B
2. **Code Review**: Generated code changes only when semantics change
3. **Debugging**: Bisect issues across commits
4. **Team Collaboration**: No merge conflicts from timestamp churn
5. **Cache Efficiency**: Same inputs → cache hit

## Threat Model

Things that can break determinism:

| Threat | Example | Impact |
|--------|---------|--------|
| Timestamps | `Generated: 2025-12-25T10:00:00Z` | Diff churn on every compile |
| Ordering | `%{a: 1, b: 2}` vs `%{b: 2, a: 1}` | Random diffs |
| Python version | 3.11 vs 3.12 introspection differences | Different bindings |
| Package version | numpy 1.26.0 vs 1.26.4 | Different signatures |
| Platform | Linux vs macOS docstrings | Different docs |
| Floating point | `inspect(0.1 + 0.2)` | Non-portable |
| Random | `System.unique_integer()` | Never stable |

## What We Control

### 1. Generated Source Files

Files in `lib/snakebridge_generated/*.ex` must be:

- **Content-stable**: Same introspection data → same file content
- **Format-stable**: Same formatting across Elixir versions
- **Order-stable**: Functions/modules in consistent order

**Implementation**:

```elixir
# In generator.ex

# Sort functions alphabetically
functions = Enum.sort_by(functions, & &1.name)

# Sort modules by name
modules = Enum.sort_by(modules, & &1.module_name)

# Format consistently
Code.format_string!(source, [])
```

**Avoid**:

```elixir
# BAD: timestamp in output
@moduledoc """
Generated by SnakeBridge at #{DateTime.utc_now()}
"""

# GOOD: version only
@moduledoc """
Generated by SnakeBridge v0.4.0 - DO NOT EDIT MANUALLY
"""
```

### 2. Manifest File

`.snakebridge/manifest.json` must be:

- **Key-sorted**: Alphabetical key ordering
- **Deterministic JSON**: Consistent formatting

**Implementation**:

```elixir
# In manifest.ex
def save(manifest, path) do
  content = manifest
    |> sort_keys_recursively()
    |> Jason.encode!(pretty: true)

  File.write!(path, content)
end

defp sort_keys_recursively(map) when is_map(map) do
  map
  |> Enum.sort_by(fn {k, _} -> k end)
  |> Enum.map(fn {k, v} -> {k, sort_keys_recursively(v)} end)
  |> Enum.into(%{})
end
defp sort_keys_recursively(list) when is_list(list) do
  Enum.map(list, &sort_keys_recursively/1)
end
defp sort_keys_recursively(other), do: other
```

### 3. Lock File

`snakebridge.lock` is the **source of truth** for environment identity.

**Stable Fields** (never change unless semantics change):

```json
{
  "version": "0.4.0",
  "environment": {
    "python_version": "3.12.3",
    "python_platform": "x86_64-pc-linux-gnu",
    "python_packages_hash": "sha256:..."
  }
}
```

**Unstable Fields** (change on each generation):

None. We explicitly exclude:

- `generated_at` timestamps
- `hostname` or machine identifiers
- Absolute paths

**Hash Computation**:

The `python_packages_hash` is computed from resolved package versions:

```elixir
def compute_packages_hash(packages) do
  packages
  |> Enum.sort_by(fn {name, _} -> name end)
  |> Enum.map(fn {name, %{version: v}} -> "#{name}==#{v}" end)
  |> Enum.join("\n")
  |> then(&:crypto.hash(:sha256, &1))
  |> Base.encode16(case: :lower)
end
```

### 4. Introspection Script

The Python introspection script must produce deterministic output.

**Avoid**:

```python
# BAD: dict ordering not guaranteed in Python <3.7
return {"name": name, "params": params}
```

**Use**:

```python
# GOOD: explicit ordering
import json
result = json.dumps({
    "name": name,
    "params": params
}, sort_keys=True)
```

**Avoid**:

```python
# BAD: set ordering is random
return {"methods": list(methods)}
```

**Use**:

```python
# GOOD: sorted output
return {"methods": sorted(methods)}
```

## Environment Identity

Two machines produce identical bindings if and only if:

1. **Same SnakeBridge version**: Generator logic must match
2. **Same Python version**: Introspection behavior matches
3. **Same Python packages**: API surfaces match
4. **Same library config**: Include/exclude lists match

The lockfile captures this identity:

```json
{
  "environment": {
    "snakebridge_version": "0.4.0",
    "generator_hash": "c9163ff...",
    "python_version": "3.12.3",
    "python_platform": "x86_64-pc-linux-gnu",
    "python_packages_hash": "a1b2c3d4..."
  }
}
```

### Generator Hash

The `generator_hash` is a hash of:

- SnakeBridge version string
- Generator module source (or checksum)
- Introspection script source

This catches cases where the generator logic changes but version is unchanged.

```elixir
def generator_hash do
  sources = [
    @version,
    File.read!("lib/snakebridge/generator.ex"),
    @introspection_script
  ]

  :crypto.hash(:sha256, Enum.join(sources, "\n"))
  |> Base.encode16(case: :lower)
  |> String.slice(0, 12)
end
```

### Platform Handling

Some Python docstrings are platform-specific. For example:

- `os.path` functions differ on Windows vs Unix
- `ctypes` type sizes differ by platform

**Strategy**:

1. Record `python_platform` in lockfile
2. Warn if regenerating on different platform
3. For truly platform-specific APIs, generate conditional code:

```elixir
if match?({:unix, _}, :os.type()) do
  # Unix implementation
else
  # Windows implementation
end
```

**For v1**: Accept that platform-specific APIs may differ. Document the limitation.

## Invalidation Rules

When should SnakeBridge regenerate bindings?

| Change | Regenerate? | Reason |
|--------|-------------|--------|
| SnakeBridge version | Yes | Generator logic may differ |
| Python version | Yes | Introspection may differ |
| Package version | Yes | API may differ |
| Library config | Yes | Include/exclude changed |
| Source file changes | No | We scan for calls, not content |
| Elixir version | No | Generated .ex is portable |
| OTP version | No | Generated .ex is portable |

**Implementation**:

```elixir
def needs_regeneration?(old_lock, new_env) do
  old_lock.environment.snakebridge_version != snakebridge_version() ||
  old_lock.environment.python_version != new_env.python_version ||
  old_lock.environment.python_packages_hash != new_env.python_packages_hash
end
```

## Strict Mode Workflow

In strict mode, we never regenerate. This guarantees:

1. CI uses exactly what was committed
2. No Python execution in CI
3. No hidden environment dependencies

**Workflow**:

```
Developer machine:
  1. Edit code
  2. mix compile → regenerates if needed
  3. Commit: lib/snakebridge_generated/*.ex, .snakebridge/manifest.json, snakebridge.lock

CI machine:
  1. Checkout
  2. SNAKEBRIDGE_STRICT=1 mix compile
  3. If manifest missing symbols → FAIL
  4. If lock environment differs → WARN
  5. Compile generated files normally
```

## Testing Determinism

### Unit Test: Output Stability

```elixir
test "generator produces stable output" do
  introspection_data = fixture("numpy_introspection.json")

  output1 = Generator.render_library(:numpy, introspection_data)
  output2 = Generator.render_library(:numpy, introspection_data)

  assert output1 == output2
end
```

### Integration Test: Cross-Machine Stability

```elixir
test "lockfile hash is stable" do
  packages = %{
    "numpy" => %{version: "1.26.4"},
    "scipy" => %{version: "1.11.0"}
  }

  hash1 = Lock.compute_packages_hash(packages)
  hash2 = Lock.compute_packages_hash(packages)

  assert hash1 == hash2
  assert hash1 == "expected_hash_value"  # golden value
end
```

### CI Test: Regeneration Detection

```yaml
# .github/workflows/ci.yml
- name: Check for uncommitted generation
  run: |
    mix compile
    git diff --exit-code lib/snakebridge_generated/
    git diff --exit-code .snakebridge/manifest.json
```

## Known Limitations

### 1. Docstring Instability

Some Python libraries have non-deterministic docstrings:

- Timestamps in generated docs
- Build metadata in docstrings
- Platform-specific paths

**Mitigation**: Hash only the function signature, not the docstring.

### 2. Floating Point Representation

Python `repr(0.1)` may differ across platforms.

**Mitigation**: For default values, use string representation from source.

### 3. Dynamic APIs

Some Python libraries modify their API at import time based on:

- Available hardware (CUDA)
- Environment variables
- Random initialization

**Mitigation**: Document which libraries have dynamic APIs. Consider
introspecting with known environment state.

## Best Practices Summary

1. **Never include timestamps** in generated output
2. **Always sort** maps, sets, and lists before output
3. **Use deterministic JSON** encoding
4. **Hash resolved versions**, not requirements
5. **Record environment identity** in lockfile
6. **Fail in CI** if regeneration would occur
7. **Warn on environment mismatch** but allow compilation
8. **Test for stability** with golden outputs

## Conclusion

Determinism is achievable with discipline. The key insights:

1. Environment identity is defined by lockfile
2. Generated files are derived from environment + config
3. Strict mode guarantees CI uses committed artifacts
4. Testing validates stability across runs

With these mechanisms, SnakeBridge can promise:

> "Same lockfile + same config → same generated code"
