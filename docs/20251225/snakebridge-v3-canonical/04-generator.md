# Code Generator

## Purpose

The generator produces Elixir source files from introspection data. Each library gets one `.ex` file containing all its generated functions, sorted alphabetically for deterministic output.

## Output Format

```elixir
# lib/snakebridge_generated/numpy.ex
# Generated by SnakeBridge v3.0.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix snakebridge.generate
# Library: numpy 1.26.4

defmodule Numpy do
  @moduledoc """
  SnakeBridge bindings for `numpy`.

  This module provides Elixir wrappers for Python's numpy library.
  Functions call Python through the Snakepit runtime.

  ## Discovery

      Numpy.__functions__()   # List all functions
      Numpy.__search__("term") # Search by keyword
      Numpy.doc(:array)       # Get documentation

  ## Usage

      {:ok, arr} = Numpy.array([1, 2, 3])
      {:ok, mean} = Numpy.mean(arr)
  """

  @doc """
  Create an array.

  ## Parameters

    - `object` - An array, any object exposing the array interface,
      or any (nested) sequence.

  ## Returns

    - `{:ok, result}` on success
    - `{:error, reason}` on failure
  """
  @spec array(term()) :: {:ok, term()} | {:error, term()}
  def array(object) do
    SnakeBridge.Runtime.call(__MODULE__, :array, [object])
  end

  @doc """
  Compute the arithmetic mean along the specified axis.
  """
  @spec mean(term()) :: {:ok, term()} | {:error, term()}
  def mean(a) do
    SnakeBridge.Runtime.call(__MODULE__, :mean, [a])
  end

  @doc """
  Compute the standard deviation along the specified axis.
  """
  @spec std(term()) :: {:ok, term()} | {:error, term()}
  def std(a) do
    SnakeBridge.Runtime.call(__MODULE__, :std, [a])
  end

  # ── Discovery Functions ────────────────────────────────────────────

  @doc false
  def __functions__ do
    [
      {:array, 1, __MODULE__, "Create an array."},
      {:mean, 1, __MODULE__, "Compute the arithmetic mean..."},
      {:std, 1, __MODULE__, "Compute the standard deviation..."}
    ]
  end

  @doc false
  def __search__(query) do
    SnakeBridge.Docs.search(__MODULE__, query)
  end

  @doc false
  def doc(function) do
    SnakeBridge.Docs.get(__MODULE__, function)
  end
end
```

## Implementation

```elixir
defmodule SnakeBridge.Generator do
  @moduledoc """
  Generates Elixir source files from introspection data.
  """

  @doc """
  Generate source files for the given symbols.
  Groups symbols by library and generates one file per library.
  """
  def generate(to_generate, introspection_results, config) do
    File.mkdir_p!(config.generated_dir)

    # Group by library
    by_library = group_by_library(to_generate, config)

    # Generate each library
    Enum.each(by_library, fn {library, symbols} ->
      generate_library(library, symbols, introspection_results, config)
    end)
  end

  defp generate_library(library, new_symbols, introspection, config) do
    path = Path.join(config.generated_dir, "#{library.name}.ex")
    
    # Load existing functions (if file exists)
    existing = load_existing_functions(path)
    
    # Get introspection for new symbols
    new_info = get_introspection_info(new_symbols, introspection)
    
    # Merge: existing + new, sorted alphabetically
    all_functions = merge_functions(existing, new_info)
    
    # Generate module source
    source = generate_module(library, all_functions, config)
    
    # Write atomically
    write_atomic(path, source)
    
    if config.verbose do
      Mix.shell().info("SnakeBridge: Generated #{path}")
    end
  end

  defp generate_module(library, functions, config) do
    header = generate_header(library, config)
    moduledoc = generate_moduledoc(library)
    function_defs = functions |> Enum.map(&generate_function/1) |> Enum.join("\n\n")
    discovery = generate_discovery_functions(functions)

    """
    #{header}
    defmodule #{library.module_name} do
    #{moduledoc}
    #{function_defs}

    #{discovery}
    end
    """
  end

  defp generate_header(library, config) do
    """
    # Generated by SnakeBridge v#{config.version} - DO NOT EDIT MANUALLY
    # Regenerate with: mix snakebridge.generate
    # Library: #{library.python_name} #{library.version}
    """
  end

  defp generate_moduledoc(library) do
    ~s'''
      @moduledoc """
      SnakeBridge bindings for `#{library.python_name}`.

      This module provides Elixir wrappers for Python's #{library.python_name} library.
      Functions call Python through the Snakepit runtime.

      ## Discovery

          #{library.module_name}.__functions__()   # List all functions
          #{library.module_name}.__search__("term") # Search by keyword
          #{library.module_name}.doc(:array)       # Get documentation

      ## Usage

          {:ok, result} = #{library.module_name}.some_function(args)
      """
    '''
  end

  defp generate_function(info) do
    name = info["name"]
    params = info["parameters"] || []
    doc = info["docstring"] || ""
    
    # Build parameter list
    {param_names, _} = build_params(params)
    param_list = Enum.join(param_names, ", ")
    
    # Build @spec
    spec = generate_spec(name, params)
    
    """
      @doc \"\"\"
    #{indent(escape_heredoc(doc), 2)}
      \"\"\"
      #{spec}
      def #{name}(#{param_list}) do
        SnakeBridge.Runtime.call(__MODULE__, :#{name}, [#{param_list}])
      end
    """
  end

  defp build_params(params) do
    # Filter to required positional args only
    # Optional/keyword args become part of an opts keyword list
    params
    |> Enum.filter(&(&1["kind"] in ["POSITIONAL_ONLY", "POSITIONAL_OR_KEYWORD"]))
    |> Enum.reject(&Map.has_key?(&1, "default"))
    |> Enum.map(&{&1["name"], nil})
    |> Enum.unzip()
  end

  defp generate_spec(name, params) do
    arity = params
    |> Enum.filter(&(&1["kind"] in ["POSITIONAL_ONLY", "POSITIONAL_OR_KEYWORD"]))
    |> Enum.reject(&Map.has_key?(&1, "default"))
    |> length()

    args = List.duplicate("term()", arity) |> Enum.join(", ")
    "@spec #{name}(#{args}) :: {:ok, term()} | {:error, term()}"
  end

  defp generate_discovery_functions(functions) do
    function_list = functions
    |> Enum.map(fn info ->
      name = info["name"]
      arity = count_required_params(info["parameters"] || [])
      summary = info["docstring"] |> get_first_line() |> escape_string()
      ~s({:#{name}, #{arity}, __MODULE__, "#{summary}"})
    end)
    |> Enum.join(",\n      ")

    """
      # ── Discovery Functions ────────────────────────────────────────────

      @doc false
      def __functions__ do
        [
          #{function_list}
        ]
      end

      @doc false
      def __search__(query) do
        SnakeBridge.Docs.search(__MODULE__, query)
      end

      @doc false
      def doc(function) do
        SnakeBridge.Docs.get(__MODULE__, function)
      end
    """
  end

  defp count_required_params(params) do
    params
    |> Enum.filter(&(&1["kind"] in ["POSITIONAL_ONLY", "POSITIONAL_OR_KEYWORD"]))
    |> Enum.reject(&Map.has_key?(&1, "default"))
    |> length()
  end

  defp merge_functions(existing, new) do
    existing_map = Map.new(existing, &{&1["name"], &1})
    new_map = Map.new(new, &{&1["name"], &1})
    
    Map.merge(existing_map, new_map)
    |> Map.values()
    |> Enum.sort_by(&(&1["name"]))
  end

  defp write_atomic(path, content) do
    temp = "#{path}.tmp.#{:rand.uniform(100_000)}"
    File.write!(temp, content)
    File.rename!(temp, path)
  end

  defp escape_heredoc(text) do
    text
    |> String.replace(~s("""), ~s(\\"\\"\\"))
    |> String.trim()
  end

  defp get_first_line(nil), do: ""
  defp get_first_line(text) do
    text |> String.split("\n") |> List.first() |> String.slice(0..60)
  end

  defp escape_string(text) do
    text
    |> String.replace("\\", "\\\\")
    |> String.replace("\"", "\\\"")
  end

  defp indent(text, spaces) do
    prefix = String.duplicate(" ", spaces)
    text
    |> String.split("\n")
    |> Enum.map(&(prefix <> &1))
    |> Enum.join("\n")
  end
end
```

## Design Decisions

### One File Per Library

Instead of one file per function:

```
✗ lib/snakebridge_generated/numpy/array.ex
✗ lib/snakebridge_generated/numpy/mean.ex
✗ lib/snakebridge_generated/numpy/std.ex

✓ lib/snakebridge_generated/numpy.ex  # Contains all functions
```

Why:
- Fewer files = fewer git conflicts
- Faster compilation (Elixir compiles files in parallel, but fewer files means less overhead)
- Easier to review in PRs
- Simpler "go to definition" in IDEs

### Sorted Output

Functions are sorted alphabetically:

```elixir
defmodule Numpy do
  def array(...), do: ...
  def mean(...), do: ...   # always after array
  def std(...), do: ...    # always after mean
  def zeros(...), do: ...  # always after std
end
```

Why:
- Deterministic output regardless of detection order
- Minimal diffs when adding new functions
- Merge conflicts are rare and easy to resolve

### No Timestamps in Body

```elixir
# Good: header comment only
# Generated by SnakeBridge v3.0.0

# Bad: timestamps that change every generation
# Generated: 2025-12-25T10:30:00Z  ← Don't do this
```

Why:
- Avoids unnecessary diffs
- Content-addressed, not time-addressed
- Only changes when actual content changes

### Atomic Writes

```elixir
def write_atomic(path, content) do
  temp = "#{path}.tmp.#{:rand.uniform(100_000)}"
  File.write!(temp, content)
  File.rename!(temp, path)  # Atomic on POSIX
end
```

Why:
- No partial writes on crash
- No corrupted files
- Concurrent safety

## Submodule Generation

For libraries with submodules (e.g., `numpy.linalg`):

```elixir
# Detected: Numpy.Linalg.solve/2

# Option 1: Nested in parent file
# lib/snakebridge_generated/numpy.ex
defmodule Numpy do
  defmodule Linalg do
    def solve(a, b), do: ...
  end
end

# Option 2: Separate file (for large submodules)
# lib/snakebridge_generated/numpy_linalg.ex
defmodule Numpy.Linalg do
  def solve(a, b), do: ...
end
```

Configuration:

```elixir
libraries: [
  numpy: [
    version: "~> 1.26",
    submodules: :nested      # or :separate
  ]
]
```

## Regeneration

Full regeneration clears and rebuilds:

```bash
$ mix snakebridge.generate --force
Clearing lib/snakebridge_generated/
Scanning project...
Generating numpy.ex (5 functions)
Generating pandas.ex (3 functions)
Done.
```

Incremental generation (default) preserves existing functions:

```bash
$ mix snakebridge.generate
Scanning project...
numpy.ex: 2 new functions (5 total)
pandas.ex: unchanged
Done.
```
