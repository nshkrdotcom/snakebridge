# Code Generator

## Purpose

The generator produces Elixir source files from introspection data. Each library gets one `.ex` file containing all its generated functions, sorted alphabetically for deterministic output.

## Output Format

```elixir
# lib/snakebridge_generated/numpy.ex
# Generated by SnakeBridge v3.0.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix snakebridge.generate
# Library: numpy 1.26.4

defmodule Numpy do
  @moduledoc """
  SnakeBridge bindings for `numpy`.

  This module provides Elixir wrappers for Python's numpy library.
  Functions call Python through the Snakepit runtime.

  ## Discovery

      Numpy.__functions__()   # List all functions
      Numpy.__classes__()     # List all classes
      Numpy.__search__("term") # Search by keyword
      Numpy.doc(:array)       # Get documentation

  ## Usage

      {:ok, arr} = Numpy.array([1, 2, 3])
      {:ok, mean} = Numpy.mean(arr)
  """

  @doc """
  Create an array.

  ## Parameters

    - `object` - An array, any object exposing the array interface,
      or any (nested) sequence.

  ## Returns

    - `{:ok, result}` on success
    - `{:error, reason}` on failure
  """
  @spec array(term(), keyword()) :: {:ok, term()} | {:error, term()}
  def array(object, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :array, [object], opts)
  end

  @doc """
  Compute the arithmetic mean along the specified axis.
  """
  @spec mean(term(), keyword()) :: {:ok, term()} | {:error, term()}
  def mean(a, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :mean, [a], opts)
  end

  @doc """
  Compute the standard deviation along the specified axis.
  """
  @spec std(term(), keyword()) :: {:ok, term()} | {:error, term()}
  def std(a, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :std, [a], opts)
  end

  # ── Discovery Functions ────────────────────────────────────────────

  @doc false
  def __functions__ do
    [
      {:array, 1, __MODULE__, "Create an array."},
      {:mean, 1, __MODULE__, "Compute the arithmetic mean..."},
      {:std, 1, __MODULE__, "Compute the standard deviation..."}
    ]
  end

  @doc false
  def __search__(query) do
    SnakeBridge.Docs.search(__MODULE__, query)
  end

  @doc false
  def doc(function) do
    SnakeBridge.Docs.get(__MODULE__, function)
  end
end
```

## Implementation

```elixir
defmodule SnakeBridge.Generator do
  @moduledoc """
  Generates Elixir source files from introspection data.
  """

  @doc """
  Generate source files for the given symbols.
  Groups symbols by library and generates one file per library.
  """
  def generate(to_generate, introspection_results, config) do
    File.mkdir_p!(config.generated_dir)

    # Group by library
    by_library = group_by_library(to_generate, config)

    # Generate each library
    Enum.each(by_library, fn {library, symbols} ->
      generate_library(library, symbols, introspection_results, config)
    end)
  end

  defp generate_library(library, new_symbols, introspection, config) do
    path = Path.join(config.generated_dir, "#{library.name}.ex")
    
    # Load existing functions (if file exists)
    existing = load_existing_functions(path)
    
    # Get introspection for new symbols
    new_info = get_introspection_info(new_symbols, introspection)
    
    # Merge: existing + new, sorted alphabetically
    all_functions = merge_functions(existing, new_info)
    
    # Generate module source
    source = generate_module(library, all_functions, config)
    
    # Write atomically
    write_atomic(path, source)
    
    if config.verbose do
      Mix.shell().info("SnakeBridge: Generated #{path}")
    end
  end

  defp generate_module(library, functions, config) do
    header = generate_header(library, config)
    moduledoc = generate_moduledoc(library)
    function_defs = functions |> Enum.map(&generate_function/1) |> Enum.join("\n\n")
    discovery = generate_discovery_functions(functions)

    """
    #{header}
    defmodule #{library.module_name} do
    #{moduledoc}
    #{function_defs}

    #{discovery}
    end
    """
  end

  defp generate_header(library, config) do
    """
    # Generated by SnakeBridge v#{config.version} - DO NOT EDIT MANUALLY
    # Regenerate with: mix snakebridge.generate
    # Library: #{library.python_name} #{library.version}
    """
  end

  defp generate_moduledoc(library) do
    ~s'''
      @moduledoc """
      SnakeBridge bindings for `#{library.python_name}`.

      This module provides Elixir wrappers for Python's #{library.python_name} library.
      Functions call Python through the Snakepit runtime.

      ## Discovery

          #{library.module_name}.__functions__()   # List all functions
          #{library.module_name}.__classes__()     # List all classes
          #{library.module_name}.__search__("term") # Search by keyword
          #{library.module_name}.doc(:array)       # Get documentation

      ## Usage

          {:ok, result} = #{library.module_name}.some_function(args)
      """
    '''
  end

  defp generate_function(info) do
    name = info["name"]
    params = info["parameters"] || []
    doc = info["docstring"] || ""
    
    # Build parameter list
    {param_names, has_opts} = build_params(params)
    param_list =
      if has_opts do
        Enum.join(param_names ++ ["opts \\\\ []"], ", ")
      else
        Enum.join(param_names, ", ")
      end
    
    # Build @spec
    spec = generate_spec(name, params)
    
    """
      @doc \"\"\"
    #{indent(escape_heredoc(doc), 2)}
      \"\"\"
      #{spec}
      def #{name}(#{param_list}) do
        args = [#{Enum.join(param_names, ", ")}]
        #{if has_opts, do: "SnakeBridge.Runtime.call(__MODULE__, :#{name}, args, opts)", else: "SnakeBridge.Runtime.call(__MODULE__, :#{name}, args)"}
      end
    """
  end

  defp build_params(params) do
    # Required positional args become parameters.
    # Optional/keyword args are passed via opts keyword list.
    required =
      params
      |> Enum.filter(&(&1["kind"] in ["POSITIONAL_ONLY", "POSITIONAL_OR_KEYWORD"]))
      |> Enum.reject(&Map.has_key?(&1, "default"))

    optional_or_kw =
      params
      |> Enum.filter(&(&1["kind"] in ["KEYWORD_ONLY", "VAR_KEYWORD"]))

    param_names = Enum.map(required, & &1["name"])
    {param_names, optional_or_kw != []}
  end

  defp generate_spec(name, params) do
    arity = params
    |> Enum.filter(&(&1["kind"] in ["POSITIONAL_ONLY", "POSITIONAL_OR_KEYWORD"]))
    |> Enum.reject(&Map.has_key?(&1, "default"))
    |> length()

    args = List.duplicate("term()", arity) |> Enum.join(", ")
    has_opts =
      params
      |> Enum.any?(&(&1["kind"] in ["KEYWORD_ONLY", "VAR_KEYWORD"] || Map.has_key?(&1, "default")))

    spec_args = if has_opts, do: args <> ", keyword()", else: args
    "@spec #{name}(#{spec_args}) :: {:ok, term()} | {:error, term()}"
  end

  defp generate_discovery_functions(functions) do
    class_list = [] # generated from class metadata (see Class Generation)
    function_list = functions
    |> Enum.map(fn info ->
      name = info["name"]
      arity = count_required_params(info["parameters"] || [])
      summary = info["docstring"] |> get_first_line() |> escape_string()
      ~s({:#{name}, #{arity}, __MODULE__, "#{summary}"})
    end)
    |> Enum.join(",\n      ")

    """
      # ── Discovery Functions ────────────────────────────────────────────

      @doc false
      def __functions__ do
        [
          #{function_list}
        ]
      end

      @doc false
      def __classes__ do
        #{inspect(class_list)}
      end

      @doc false
      def __search__(query) do
        SnakeBridge.Docs.search(__MODULE__, query)
      end

      @doc false
      def doc(function) do
        SnakeBridge.Docs.get(__MODULE__, function)
      end
    """
  end

  defp count_required_params(params) do
    params
    |> Enum.filter(&(&1["kind"] in ["POSITIONAL_ONLY", "POSITIONAL_OR_KEYWORD"]))
    |> Enum.reject(&Map.has_key?(&1, "default"))
    |> length()
  end

  defp merge_functions(existing, new) do
    existing_map = Map.new(existing, &{&1["name"], &1})
    new_map = Map.new(new, &{&1["name"], &1})
    
    Map.merge(existing_map, new_map)
    |> Map.values()
    |> Enum.sort_by(&(&1["name"]))
  end

  defp write_atomic(path, content) do
    temp = "#{path}.tmp.#{:rand.uniform(100_000)}"
    File.write!(temp, content)
    File.rename!(temp, path)
  end

  defp escape_heredoc(text) do
    text
    |> String.replace(~s("""), ~s(\\"\\"\\"))
    |> String.trim()
  end

  defp get_first_line(nil), do: ""
  defp get_first_line(text) do
    text |> String.split("\n") |> List.first() |> String.slice(0..60)
  end

  defp escape_string(text) do
    text
    |> String.replace("\\", "\\\\")
    |> String.replace("\"", "\\\"")
  end

  defp indent(text, spaces) do
    prefix = String.duplicate(" ", spaces)
    text
    |> String.split("\n")
    |> Enum.map(&(prefix <> &1))
    |> Enum.join("\n")
  end
end
```

## Argument Handling and Keyword Options

SnakeBridge generates wrapper signatures that separate **required positional** arguments from **optional/keyword** arguments.

- Required positionals become explicit parameters.
- Optional and keyword-only args are passed via a `opts \\ []` keyword list.
- `opts` is converted into Python kwargs.
- `*args` (VAR_POSITIONAL) are passed via `opts[:__args__]` as a list.

Example:

```elixir
@spec reshape(term(), keyword()) :: {:ok, term()} | {:error, term()}
def reshape(a, opts \\ []) do
  # opts: [shape: {2, 3}, order: "C", __args__: []]
  SnakeBridge.Runtime.call(__MODULE__, :reshape, [a], opts)
end
```

Reserved keyword keys:

- `:__args__` — additional positional arguments for Python `*args`

## Submodule Generation

All submodules are **nested inside the same library file** (one file per library).

```elixir
# lib/snakebridge_generated/numpy.ex
defmodule Numpy do
  defmodule Linalg do
    def solve(a, b, opts \\ []) do
      SnakeBridge.Runtime.call(__MODULE__, :solve, [a, b], opts)
    end
  end
end
```

The introspector uses dotted Python names (`numpy.linalg`) and the generator writes nested modules that include a `__snakebridge_python_name__/0` function so runtime can resolve to `numpy.linalg`.

## Class Generation

Python classes become nested Elixir modules with explicit constructors and methods.

```elixir
defmodule Sympy do
  defmodule Symbol do
    @spec new(term(), keyword()) :: {:ok, SnakeBridge.PyRef.t()} | {:error, term()}
    def new(name, opts \\ []) do
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [name], opts)
    end

    @spec name(SnakeBridge.PyRef.t()) :: {:ok, term()} | {:error, term()}
    def name(ref) do
      SnakeBridge.Runtime.get_attr(ref, :name)
    end

    @spec simplify(SnakeBridge.PyRef.t(), keyword()) :: {:ok, SnakeBridge.PyRef.t()} | {:error, term()}
    def simplify(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :simplify, [], opts)
    end
  end
end
```

Rules:

- Instance methods take a `SnakeBridge.PyRef.t()` as the first argument.
- Static/class methods are generated as normal module functions.
- Attributes map to `get_attr/2` and `set_attr/3` helpers.

## Streaming Functions

If a Python tool supports streaming, the generator emits a streaming variant:

```elixir
@spec predict_stream(term(), keyword(), (map() -> any())) :: :ok | {:error, term()}
def predict_stream(input, opts \\ [], on_chunk) do
  SnakeBridge.Runtime.stream(__MODULE__, :predict, [input], opts, on_chunk)
end
```

Streaming support is declared in config:

```elixir
libraries: [
  torch: [version: "~> 2.1", streaming: ["predict"]]
]
```

## Typespec Generation

Typespecs are derived from Python annotations where possible and fall back to `term()` for unknowns. See [13-typespecs.md](13-typespecs.md).

## Design Decisions

### One File Per Library

Instead of one file per function:

```
✗ lib/snakebridge_generated/numpy/array.ex
✗ lib/snakebridge_generated/numpy/mean.ex
✗ lib/snakebridge_generated/numpy/std.ex

✓ lib/snakebridge_generated/numpy.ex  # Contains all functions
```

Why:
- Fewer files = fewer git conflicts
- Faster compilation (Elixir compiles files in parallel, but fewer files means less overhead)
- Easier to review in PRs
- Simpler "go to definition" in IDEs

### Sorted Output

Functions are sorted alphabetically:

```elixir
defmodule Numpy do
  def array(...), do: ...
  def mean(...), do: ...   # always after array
  def std(...), do: ...    # always after mean
  def zeros(...), do: ...  # always after std
end
```

Why:
- Deterministic output regardless of detection order
- Minimal diffs when adding new functions
- Merge conflicts are rare and easy to resolve

### No Timestamps in Body

```elixir
# Good: header comment only
# Generated by SnakeBridge v3.0.0

# Bad: timestamps that change every generation
# Generated: 2025-12-25T10:30:00Z  ← Don't do this
```

Why:
- Avoids unnecessary diffs
- Content-addressed, not time-addressed
- Only changes when actual content changes

### Atomic Writes

```elixir
def write_atomic(path, content) do
  temp = "#{path}.tmp.#{:rand.uniform(100_000)}"
  File.write!(temp, content)
  File.rename!(temp, path)  # Atomic on POSIX
end
```

Why:
- No partial writes on crash
- No corrupted files
- Concurrent safety

## Error Handling

- **Write failures**: compilation fails with a diagnostic (disk full, permission).
- **Docstring formatting errors**: docstrings are sanitized and truncated; generation continues.
- **Name collisions**: if a function name conflicts with an existing helper, generation fails and suggests a rename override.

## Submodule Generation (Recap)

Submodules are always nested in the library file to preserve the one-file-per-library rule:

```elixir
defmodule Numpy do
  defmodule Linalg do
    def solve(a, b, opts \\ []), do: ...
  end
end
```

## Regeneration

Full regeneration clears and rebuilds:

```bash
$ mix snakebridge.generate --force
Clearing lib/snakebridge_generated/
Scanning project...
Generating numpy.ex (5 functions)
Generating pandas.ex (3 functions)
Done.
```

Incremental generation (default) preserves existing functions:

```bash
$ mix snakebridge.generate
Scanning project...
numpy.ex: 2 new functions (5 total)
pandas.ex: unchanged
Done.
```
