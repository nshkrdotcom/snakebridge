# Accumulator Cache

## Philosophy

The cache follows an **append-only accumulation model**. Like a git repository, it only grows—deletions are explicit, intentional operations that require developer consent.

**Key Decision:** We cache **source files** (`.ex`), not BEAM bytecode. This ensures portability across OTP versions and development machines.

## Why Source-Based Caching?

### The Problem with BEAM Caching

BEAM bytecode has compatibility constraints:
- **OTP version**: BEAM files compiled on OTP 26 may not load on OTP 25
- **Elixir version**: Compilation changes can affect bytecode
- **Debug info**: Different environments have different debug settings
- **Compilation flags**: Warnings, optimization levels, etc.

If you cache BEAM and restore it on a different machine, you eventually hit "works on my machine" failures.

### The Source Solution

Caching generated source avoids all these issues:
- Source is portable across all environments
- Normal Elixir compilation handles bytecode generation
- Debug info, Dialyzer PLT, etc. work correctly
- Generated code is human-readable and auditable
- Git diffs show exactly what changed

## Cache Structure

### Directory Layout

```
my_app/
├── lib/
│   ├── my_app.ex                      # Your code
│   └── snakebridge_generated/          # Generated source (committed to git)
│       ├── numpy.ex                    # All Numpy functions, sorted
│       ├── pandas.ex                   # All Pandas functions, sorted
│       └── sympy.ex                    # All Sympy functions, sorted
├── .snakebridge/
│   ├── manifest.json                   # Symbol index
│   └── ledger.json                     # Runtime usage log (dev only, not committed)
├── snakebridge.lock                    # Environment identity (committed to git)
└── _build/                             # BEAM files (not committed, rebuilt locally)
```

### Generated Source Files

Each library gets one file with all its functions, sorted alphabetically:

```elixir
# lib/snakebridge_generated/numpy.ex
# Generated by SnakeBridge - DO NOT EDIT
# Regenerate with: mix snakebridge.generate
#
# Library: numpy 1.26.4
# Generated: 2025-12-25T10:30:00Z

defmodule Numpy do
  @moduledoc """
  SnakeBridge bindings for numpy.

  These functions call Python through the SnakeBridge runtime.
  """

  @doc """
  Create an array.

  Parameters
  ----------
  object : array_like
      An array, any object exposing the array interface, or any sequence.
  """
  def array(object) do
    SnakeBridge.Runtime.call(__MODULE__, :array, [object])
  end

  @doc """
  Dot product of two arrays.
  """
  def dot(a, b) do
    SnakeBridge.Runtime.call(__MODULE__, :dot, [a, b])
  end

  @doc """
  Return a new array of given shape and type, filled with zeros.
  """
  def zeros(shape) do
    SnakeBridge.Runtime.call(__MODULE__, :zeros, [shape])
  end
end
```

### Manifest File

The manifest tracks what symbols have been generated:

```json
{
  "version": "3.0.0",
  "generated_at": "2025-12-25T14:30:00Z",
  "symbols": {
    "Numpy.array/1": {
      "generated_at": "2025-12-25T10:05:00Z",
      "python_name": "array",
      "source_file": "lib/snakebridge_generated/numpy.ex"
    },
    "Numpy.dot/2": {
      "generated_at": "2025-12-25T10:05:00Z",
      "python_name": "dot",
      "source_file": "lib/snakebridge_generated/numpy.ex"
    },
    "Numpy.zeros/1": {
      "generated_at": "2025-12-25T12:00:00Z",
      "python_name": "zeros",
      "source_file": "lib/snakebridge_generated/numpy.ex"
    }
  }
}
```

### Lock File

The lock file captures complete environment identity:

```json
{
  "version": "3.0.0",
  "generated_at": "2025-12-25T14:30:00Z",
  "environment": {
    "snakebridge_version": "3.0.0",
    "python_version": "3.11.5",
    "python_platform": "linux-x86_64",
    "elixir_version": "1.16.0",
    "otp_version": "26.1"
  },
  "libraries": {
    "numpy": {
      "requested": "~> 1.26",
      "resolved": "1.26.4",
      "checksum": "sha256:abc123..."
    },
    "pandas": {
      "requested": "~> 2.0",
      "resolved": "2.1.4",
      "checksum": "sha256:def456..."
    }
  }
}
```

## Why Accumulation?

### The Problem with Auto-Cleanup

Imagine this scenario:

```
Day 1: Developer uses Numpy.fft
Day 2: Developer refactors, fft usage moves to a different module
Day 3: Auto-prune removes Numpy.fft (not detected in current compile)
Day 4: CI fails - the other module needed fft
```

Auto-cleanup creates **non-deterministic builds**. The same code can fail or succeed depending on what the cache saw previously.

### The Accumulation Model

```
Day 1: Developer uses Numpy.fft           → Cache: [fft]
Day 2: Developer adds Numpy.ifft          → Cache: [fft, ifft]
Day 3: Developer stops using fft          → Cache: [fft, ifft]  (unchanged)
Day 4: Developer explicitly prunes        → Cache: [ifft]
```

The cache is a **development artifact** that records everything you've ever used. It's your project's memory of its Python dependencies.

## Cache Operations

### Write (Accumulation)

When new functions are detected:

```elixir
defmodule SnakeBridge.Cache do
  def add_symbols(library, symbols, introspection) do
    # Read existing generated file (if any)
    existing = read_generated_source(library)

    # Merge new symbols
    all_functions = merge_functions(existing, symbols, introspection)

    # Sort for deterministic output
    sorted = Enum.sort_by(all_functions, & &1.name)

    # Generate complete module source
    source = generate_module_source(library, sorted)

    # Write atomically
    write_generated_source(library, source)

    # Update manifest
    update_manifest(library, symbols)

    :ok
  end

  defp write_generated_source(library, source) do
    path = "lib/snakebridge_generated/#{library.name}.ex"
    temp = path <> ".tmp"

    File.write!(temp, source)
    File.rename!(temp, path)
  end
end
```

### Read

Generated source is compiled normally by Elixir:

```
mix compile
→ Compiles lib/snakebridge_generated/*.ex
→ Produces _build/dev/lib/my_app/ebin/Elixir.Numpy.beam
```

No special loading needed—it's just source code.

### Invalidation (Not Deletion)

When a library version changes, the generated code becomes potentially stale:

```elixir
def check_invalidation do
  lock = SnakeBridge.Lock.load()
  current_env = SnakeBridge.Environment.current()

  cond do
    lock.environment.python_version != current_env.python_version ->
      {:invalidated, :python_version}

    lock.libraries.numpy.resolved != current_env.libraries.numpy.resolved ->
      {:invalidated, :library_version, :numpy}

    lock.environment.snakebridge_version != current_env.snakebridge_version ->
      {:invalidated, :snakebridge_version}

    true ->
      :ok
  end
end
```

Invalidated code is regenerated on next compile, but the old source remains readable in git history.

## Git Integration

### What to Commit

```gitignore
# .gitignore

# DO commit these:
# lib/snakebridge_generated/  (generated source)
# snakebridge.lock            (environment lock)
# .snakebridge/manifest.json  (symbol index)

# Do NOT commit:
.snakebridge/ledger.json      # Runtime usage, dev-only
_build/                        # Compiled BEAM, local
```

### Git Attributes

```gitattributes
# .gitattributes

# Mark as generated for cleaner PRs
lib/snakebridge_generated/* linguist-generated=true

# JSON files should merge cleanly due to sorted keys
.snakebridge/manifest.json merge=union
snakebridge.lock merge=union
```

### Merge Conflict Prevention

Generated files use deterministic ordering to minimize conflicts:

1. **Sorted function definitions** in each module file
2. **Sorted JSON keys** in manifest and lock
3. **Atomic file writes** to prevent partial states

When two developers add different functions:
```
Dev A: adds Numpy.sum/1
Dev B: adds Numpy.mean/1

# Both files have sorted functions, so:
# A's file: array, dot, sum, zeros
# B's file: array, dot, mean, zeros

# Merge produces: array, dot, mean, sum, zeros
# (Clean merge in most cases)
```

## Usage Tracking

### Compile-Time Tracking

The AST scanner records all detected library calls:

```elixir
def scan_and_record do
  detected = SnakeBridge.Scanner.scan_project()

  Enum.each(detected, fn {module, function, arity} ->
    SnakeBridge.Manifest.touch(module, function, arity)
  end)
end
```

### Runtime Ledger (Development Only)

For dynamic calls that AST scanning can't detect:

```elixir
# lib/snakebridge/runtime.ex
def call(module, function, args) do
  if Mix.env() == :dev do
    record_to_ledger(module, function, length(args))
  end

  # Actual Python call
  execute_call(module, function, args)
end

defp record_to_ledger(module, function, arity) do
  SnakeBridge.Ledger.append(%{
    module: module,
    function: function,
    arity: arity,
    timestamp: DateTime.utc_now()
  })
end
```

The ledger is NOT committed to git. It's local development data.

### Ledger Promotion

Developers explicitly promote ledger contents to the manifest:

```bash
$ mix snakebridge.ledger
Dynamic calls detected (not in manifest):
  Numpy.custom_op/3 - called 5 times
  Pandas.query/2 - called 2 times

$ mix snakebridge.promote
Promoting 2 symbols to manifest...
Regenerating lib/snakebridge_generated/numpy.ex
Regenerating lib/snakebridge_generated/pandas.ex
Done. Commit the changes.
```

## Cache Warming

### Development Scenario

During active development, the cache warms naturally:

```
$ mix compile
SnakeBridge: Scanning project...
SnakeBridge: Detected Numpy.array/1 (new)
SnakeBridge: Generating lib/snakebridge_generated/numpy.ex
Compiling 16 files (.ex)

$ mix compile
Compiling 0 files (.ex)  # All cached
```

### CI/CD Scenario

For CI, committed source means no regeneration:

```yaml
# .github/workflows/ci.yml
jobs:
  build:
    steps:
      - uses: actions/checkout@v3

      # No Python setup needed for compile!
      # Generated source is already in repo

      - name: Build
        run: mix compile

      - name: Test
        run: mix test  # Requires Python for runtime
```

### Pre-Warming New Projects

For new projects or after a clean clone:

```bash
# Generate bindings for all detected usage
$ mix snakebridge.generate

# Or generate specific libraries
$ mix snakebridge.generate numpy pandas
```

## Sharing Caches

### Team Workflow

Since generated source is committed to git:

```
Developer A                     GitHub                    Developer B
     │                            │                            │
     │  Generate Numpy.array/1    │                            │
     │  Commit + Push             │                            │
     │ ────────────────────────►  │                            │
     │                            │                            │
     │                            │  ◄──────────────────────── │
     │                            │             Pull           │
     │                            │                            │
     │                            │  B has Numpy.array/1 now   │
     │                            │  No regeneration needed    │
```

### Monorepo Workflow

```
apps/
  app_a/
    lib/snakebridge_generated/  # App A's bindings
  app_b/
    lib/snakebridge_generated/  # App B's bindings
  shared/
    lib/snakebridge_generated/  # Shared bindings
```

Each app manages its own generated code.

## Cache Integrity

### Checksums

Each library in the lock file has a checksum:

```json
{
  "libraries": {
    "numpy": {
      "resolved": "1.26.4",
      "checksum": "sha256:abc123..."
    }
  }
}
```

### Verification

```bash
$ mix snakebridge.verify
Verifying cache integrity...
  ✓ numpy.ex matches manifest
  ✓ pandas.ex matches manifest
  ✓ Lock file environment matches current
All OK.
```

### Repair

```bash
$ mix snakebridge.verify
Verifying cache integrity...
  ✗ numpy.ex missing functions: reshape/2
  ✓ pandas.ex matches manifest

$ mix snakebridge.repair
Regenerating numpy.ex...
Done.
```

## Memory Considerations

### No Runtime Cache

Generated code is just source files. At runtime:
- Compiled BEAM is loaded like any Elixir module
- No special caching layer
- No memory overhead beyond normal module loading

### Large Libraries

For libraries with many generated functions:
- Each function adds ~1KB to source file
- 100 functions ≈ 100KB source
- Compiled BEAM is similar size
- Normal Elixir module loading applies

## Configuration

```elixir
# config/config.exs
config :snakebridge,
  # Where to put generated source
  generated_dir: "lib/snakebridge_generated",

  # Where to store manifest and ledger
  metadata_dir: ".snakebridge",

  # Include test files in AST scanning
  scan_test_files: false,

  # Verbose output during compilation
  verbose: false
```

## Summary

| Aspect | Implementation |
|--------|----------------|
| What's cached | Generated `.ex` source files |
| Where | `lib/snakebridge_generated/` |
| Git status | Committed to repository |
| BEAM files | Generated locally by Mix, not cached |
| Accumulation | Yes, only grows |
| Deletion | Explicit prune only |
| Portability | Full (source is portable) |
| Determinism | Sorted keys, atomic writes |
