To achieve a **Universal FFI** where any Python library "just works," the current `SnakeBridge` architecture is a very strong foundationâ€”specifically the use of compile-time introspection paired with a reference-based runtime (`SnakeBridge.Ref`).

However, to move from a "generated binding" tool to a "Universal FFI" MVP, there are several design gaps and missing features that will hinder the "just works" experience.

---

## 1. Design Shortcomings & Issues

### A. The "Compile-Time Wall" (Dynamic Dispatch Gap)

Current design relies heavily on `Scanner` to find calls and `Generator` to create modules.

* **The Issue:** If a Python function returns an object of a class you didn't explicitly include in your config, you get a `SnakeBridge.Ref`, but you have no generated Elixir module to call methods on it.
* **Universal Requirement:** You need a **Dynamic Proxy**. If a module isn't generated, there should be a `SnakeBridge.Dynamic` module that can take any `Ref` and call any method via `__python_call__` without needing pre-generated code.

### B. Positional vs. Keyword Argument Fragility

In `snakebridge_adapter.py`, you currently try `func(**kwargs)` and fall back to `func(*args)`.

* **The Issue:** Python's `inspect.signature` is not always available for C-extensions (like some parts of NumPy or OpenCV). The fallback logic is "guess-y" and can fail on complex signatures with default values in the middle.
* **Shortcoming:** You lack a way to handle `*args` and `**kwargs` simultaneously in the Elixir-side generated function signatures.

### C. Reference Lifecycle (Memory Leaks)

The `_instance_registry` in Python uses a `dict` with a time-based `_prune_registry`.

* **The Issue:** This is dangerous for a "Universal" FFI. If Elixir holds a `Ref`, but Python prunes it because of a timeout, the Elixir side crashes on the next call. Conversely, if the timeout is too long, you leak memory.
* **Shortcoming:** You need **Ownership Tracking**. Ideally, use Elixir's `Process.monitor` or NIF-based resource tracking to tell Python to `del` an object specifically when the Elixir process holding the `Ref` dies.

### D. The "Any" Type Fallback

The `TypeMapper` defaults heavily to `term()` when it encounters complex Python types it doesn't recognize.

* **The Issue:** "Universal" libraries (like PySide, Django, or specialized scientific libs) use complex nested generics. The current mapper is a bit too "flat."

---

## 2. Essential MVP Features for "Universal" Support

To ensure a library like `transformers`, `opencv`, or `pandas` "just works," you need these specific features:

### 1. The "Ghost" Module (Dynamic Method Injection)

Instead of forcing users to list every class in `mix.exs`, the FFI should allow:

```elixir
# If this wasn't generated, call it dynamically
SnakeBridge.Dynamic.call(ref, :method_name, [args])

```

Better yet, generated `Ref` modules should implement `method_missing` logic (via a fallback clause) so any method can be attempted.

### 2. Standard Library "Auto-Bridge"

A universal FFI should have the Python `builtins` (list, dict, set, etc.) pre-bridged. If a Python function returns a Python `list` that isn't automatically converted to an Elixir `list`, the user should have easy helpers to interact with it as a `Ref`.

### 3. Automatic "Dunder" Mapping

Python relies on `__str__`, `__repr__`, `__len__`, and `__getitem__`.

* **Feature:** Automatically map `Enum` and `Inspect` protocols in Elixir to their Python dunder equivalents. If I call `Enum.count(python_ref)`, it should call `len(obj)` in Python.

### 4. Zero-Copy Binary Passing (Large Data)

Currently, `Encoder` base64-encodes non-UTF8 binaries.

* **The Issue:** Passing a 4K video frame or a large weights file via Base64 will kill performance.
* **Requirement:** Use **Shared Memory** or **Unix Domain Sockets** for raw binary transfer. Since you are using `Snakepit`, ensure it supports `ZeroCopyRef` for raw memory addresses.

### 5. Exception Hierarchy Mapping

Currently, you have a manual `ErrorTranslator`.

* **Feature:** A truly universal FFI should catch *any* Python exception, look at its `__class__.__name__`, and dynamically create an Elixir exception struct of that name if one doesn't exist.

---

## 3. Recommended MVP "Must-Haves"

| Feature | Importance | Why? |
| --- | --- | --- |
| **Dynamic Ref Dispatch** | **Critical** | Users can't predict every object type a library might return. |
| **Context/Session Isolation** | **High** | Multiple Elixir processes shouldn't share the same Python global state unless intended. |
| **Unified Binary Type** | **High** | To handle images/tensors without Base64 overhead. |
| **Interactive Shell (IEx)** | **Medium** | Ability to "tab-complete" Python methods on a Ref in IEx. |

---

## 4. Specific Code Fixes Needed

1. **`SnakeBridge.Types.Encoder`**: Add support for passing `Snakepit.PyRef` directly back into Python. Currently, it seems to re-wrap or inspect them in a way that might lose the internal pointer.
2. **`SnakeBridge.Generator`**: Add a `@derive {Inspect, SnakeBridge.Ref}` to all generated modules to make debugging easier.
3. **`snakebridge_adapter.py`**: The `_prune_registry` should probably be replaced with an explicit `release_ref` call triggered by an Elixir `GenServer` monitor.

**Would you like me to draft a specification for the "Dynamic Proxy" module so you can call un-generated Python methods?**
