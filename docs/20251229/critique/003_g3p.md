Based on a review of the provided codebase, here is an analysis of design issues, shortcomings, and absolute requirements to achieve the MVP goal of a "Universal FFI" where any Python library "just works."

### 1. Critical Design Flaws (Showstoppers)

**A. The "String Fallacy" in Serialization (Major)**
*   **Location:** `python/snakebridge_types.py` inside the `encode` function.
*   **The Issue:** At the end of the `encode` function, the fallback for any type that isn't explicitly handled (int, list, dict, datetime, etc.) is:
    ```python
    # For any other type, try to convert to string
    return str(value)
    ```
*   **Why it breaks the MVP:** If you use `pandas` and a function returns a `DataFrame`, or `requests` returning a `Session` object, SnakeBridge converts it to a string representation (e.g., `"<pandas.DataFrame object at 0x...>"`) or a string dump.
*   **The Fix:** The fallback **must** automatically register the object in the `_instance_registry` and return a `SnakeBridge.Ref` (reference handle). Without this, you cannot chain method calls, which is 90% of Python programming.

**B. Lack of Iterator/Generator Bridging**
*   **Location:** `snakebridge/runtime.ex` and `python/snakebridge_adapter.py`.
*   **The Issue:** Python heavily relies on generators (lazy evaluation). Currently, the adapter tries to serialize results immediately. If a Python function returns a generator that yields infinite items or huge datasets, the adapter will likely try to `list()` it (via JSON serialization) and crash/OOM, or return a string representation.
*   **The Fix:** Python Generators must be detected during encoding and wrapped in a specific `Ref` type that implements the Elixir `Enumerable` protocol, allowing `Stream` operations in Elixir to pull from the Python generator lazily.

### 2. Missing Features Absolutely Required for MVP

To make "most any" library work, you need to handle Python's structural idioms, not just data types.

**A. Automatic Reference Management (Auto-Ref)**
*   **Requirement:** When Python returns an object that isn't a primitive (JSON-serializable), it must return a handle `{ "__type__": "ref", "id": "...", ... }`.
*   **Elixir Side:** The generated Elixir code needs to wrap this handle in a struct.
*   **Garbage Collection:** You need a strategy to release these references. Implementing `impl Collectable` or using a `GenServer` that monitors the owner process to call `release_ref` on Python when the Elixir process dies is crucial to prevent memory leaks in long-running apps.

**B. Python Context Manager Support (`with` statement)**
*   **Requirement:** Many libraries (files, network connections, tensorflow sessions) require context managers.
*   **Implementation:** You need an Elixir macro (e.g., `SnakeBridge.with_python/2`) that:
    1. Calls the Python `__enter__` method on a Ref.
    2. Executes the Elixir block.
    3. Guarantees the call of `__exit__` on the Python Ref, even if the Elixir block crashes.

**C. Elixir Function Callbacks (Lambdas)**
*   **Requirement:** Libraries like `scipy.optimize` or UI frameworks often take a Python function as an argument: `sort(key=lambda x: x.id)`.
*   **Gap:** Currently, `SnakeBridge` sends data *to* Python. There is no obvious mechanism in `snakebridge_adapter.py` to handle an incoming argument of type `{ "__type__": "callback", "pid": ... }` and wrap it in a Python callable that sends a message back to Elixir.
*   **MVP Need:** Support passing an anonymous Elixir function `fn x -> ... end` to Python.

### 3. Codebase Shortcomings & Refactoring Needs

**A. Brittle Wheel/Hardware Selection**
*   **Location:** `snakebridge/wheel_selector.ex`
*   **Issue:** The hardcoded maps for CUDA versions (`@cuda_version_map`) and the manual lists of packages are brittle.
*   **Risk:** This requires constant maintenance. If a user tries to use a library not in that hardcoded list that *also* has hardware variants (e.g., `jax` or `tensorflow`), it might pull the wrong wheel.
*   **Refactor:** This logic should be pluggable or inferred from `pip` rather than hardcoded in Elixir.

**B. Race Condition in File Generation**
*   **Location:** `snakebridge/generator.ex` -> `write_if_changed`
*   **Issue:** The function writes to a `.tmp` file and renames it. While generally safe, on some filesystems or highly concurrent builds, `System.unique_integer` might not be enough entropy if the generated directory is shared.
*   **Refactor:** Use standard `File.write` if content changed (read first, compare, then write).

**C. Global State in Python Adapter**
*   **Location:** `python/snakebridge_adapter.py`
*   **Issue:** `_instance_registry` is a global global dictionary.
*   **Risk:** If `Snakepit` runs multiple concurrent requests (depending on the pool strategy), this global dict is not thread-safe without locking, or process-safe if workers are forked.
*   **Fix:** Ensure the `session_id` logic creates strictly isolated scopes for references to avoid one user accessing another's objects, or ensure the Python runtime is single-threaded per process.

### 4. Summary of MVP Action Plan

1.  **Modify `python/snakebridge_types.py`**: Change the fallback encoding behavior. Instead of `return str(value)`, call `_make_ref` and return the tagged reference object.
2.  **Update `SnakeBridge.Types.Decoder`**: Add a decoder for `__type__ == "ref"` that instantiates a `SnakeBridge.Ref` struct immediately.
3.  **Implement `Enumerate` for Refs**: Allow Elixir to iterate over Python iterables via `SnakeBridge.Runtime.stream` logic automatically when a Ref is detected as iterable.
4.  **Implement Callback Support**: Allow passing `fn` to Python, which the Python adapter wraps in a callable proxy.

Without **#1 (Auto-Ref)**, the library is currently only an RPC client for primitive data, not a Universal FFI.
