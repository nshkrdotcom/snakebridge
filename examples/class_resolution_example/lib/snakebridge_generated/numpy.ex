# Generated by SnakeBridge v0.10.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: numpy stdlib

defmodule Numpy do
  @moduledoc """
  SnakeBridge bindings for `numpy`.

  ## Runtime Options

  All functions accept a `__runtime__` option for controlling execution behavior:

      Elixir.Numpy.some_function(args, __runtime__: [timeout: 120_000])

  ### Supported runtime options

  - `:timeout` - Call timeout in milliseconds (default: 120,000ms / 2 minutes)
  - `:timeout_profile` - Use a named profile (`:default`, `:ml_inference`, `:batch_job`, `:streaming`)
  - `:stream_timeout` - Timeout for streaming operations (default: 1,800,000ms / 30 minutes)
  - `:session_id` - Override the session ID for this call
  - `:pool_name` - Target a specific Snakepit pool (multi-pool setups)
  - `:affinity` - Override session affinity (`:hint`, `:strict_queue`, `:strict_fail_fast`)

  ### Timeout Profiles

  - `:default` - 2 minute timeout for regular calls
  - `:ml_inference` - 10 minute timeout for ML/LLM workloads
  - `:batch_job` - Unlimited timeout for long-running jobs
  - `:streaming` - 2 minute timeout, 30 minute stream_timeout

  ### Example with timeout override

      # For a long-running ML inference call
      Elixir.Numpy.predict(data, __runtime__: [timeout_profile: :ml_inference])

      # Or explicit timeout
      Elixir.Numpy.predict(data, __runtime__: [timeout: 600_000])

      # Route to a pool and enforce strict affinity
      Elixir.Numpy.predict(data, __runtime__: [pool_name: :strict_pool, affinity: :strict_queue])

  See `SnakeBridge.Defaults` for global timeout configuration.
  """

  def __snakebridge_python_name__, do: "numpy"
  def __snakebridge_library__, do: "numpy"

  @doc """
  array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,

  ndmax=0, like=None)

  Create an array.

  ## Parameters

  - `object` - array_like An array, any object exposing the array interface, an object whose ``__array__`` method returns an array, or any (nested) sequence. If object is a scalar, a 0-dimensional array containing object is returned.
  - `dtype` - data-type, optional The desired data-type for the array. If not given, NumPy will try to use a default ``dtype`` that can represent the values (by applying promotion rules when necessary.)
  - `copy` - bool, optional If ``True`` (default), then the array data is copied. If ``None``, a copy will only be made if ``__array__`` returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (``dtype``, ``order``, etc.). Note that any copy of the data is shallow, i.e., for arrays with object dtype, the new array will point to the same objects. See Examples for `ndarray.copy`. For ``False`` it raises a ``ValueError`` if a copy cannot be avoided. Default: ``True``.
  - `order` - {'K', 'A', 'C', 'F'}, optional Specify the memory layout of the array. If object is not an array, the newly created array will be in C order (row major) unless 'F' is specified, in which case it will be in Fortran order (column major). If object is an array the following holds.
  - `subok` - bool, optional If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).
  - `ndmin` - int, optional Specifies the minimum number of dimensions that the resulting array should have.  Ones will be prepended to the shape as needed to meet this requirement.
  - `ndmax` - int, optional Specifies the maximum number of dimensions to create when inferring shape from nested sequences. By default (ndmax=0), NumPy recurses through all nesting levels (up to the compile-time constant ``NPY_MAXDIMS``). Setting ``ndmax`` stops recursion at the specified depth, preserving deeper nested structures as objects instead of promoting them to higher-dimensional arrays. In this case, ``dtype=object`` is required.
  - `like` - array_like, optional Reference object to allow the creation of arrays which are not NumPy arrays. If an array-like passed in as ``like`` supports the ``__array_function__`` protocol, the result will be defined by it. In this case, it ensures the creation of an array object compatible with that passed in via this argument.

  ## Returns

  Returns `out`. ndarray An array object satisfying the specified requirements.

  ## Examples

    iex> import numpy as np
    iex> np.array([1, 2, 3])
    array([1, 2, 3])

    Upcasting:

    iex> np.array([1, 2, 3.0])
    array([ 1.,  2.,  3.])

    More than one dimension:

    iex> np.array([[1, 2], [3, 4]])
    array([[1, 2],
    [3, 4]])

    Minimum dimensions 2:

    iex> np.array([1, 2, 3], ndmin=2)
    array([[1, 2, 3]])

    Type provided:

    iex> np.array([1, 2, 3], dtype=complex)
    array([ 1.+0.j,  2.+0.j,  3.+0.j])

    Data-type consisting of more than one element:

    iex> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')])
    iex> x['a']
    array([1, 3], dtype=int32)

    Creating an array from sub-classes:

    iex> np.array(np.asmatrix('1 2; 3 4'))
    array([[1, 2],
    [3, 4]])

    iex> np.array(np.asmatrix('1 2; 3 4'), subok=True)
    matrix([[1, 2],
    [3, 4]])

    Limiting the maximum dimensions with ``ndmax``:

    iex> a = np.array([[1, 2], [3, 4]], dtype=object, ndmax=2)
    iex> a
    array([[1, 2],
    [3, 4]], dtype=object)
    iex> a.shape
    (2, 2)

    iex> b = np.array([[1, 2], [3, 4]], dtype=object, ndmax=1)
    iex> b
    array([list([1, 2]), list([3, 4])], dtype=object)
    iex> b.shape
    (2,)

  ## Notes

  When order is 'A' and ``object`` is an array in neither 'C' nor 'F' order,
  and a copy is forced by a change in dtype, then the order of the result is
  not necessarily 'C' as expected. This is likely a bug.

  Parameters:
  - `object` (term())
  - `dtype` (term() default: None)
  - `copy` (term() keyword-only default: True)
  - `order` (term() keyword-only default: 'K')
  - `subok` (term() keyword-only default: False)
  - `ndmin` (term() keyword-only default: 0)
  - `ndmax` (term() keyword-only default: 0)
  - `like` (term() keyword-only default: None)

  Returns:
  - `term()`
  """
  @spec array(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec array(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec array(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec array(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def array(object) do
    SnakeBridge.Runtime.call(__MODULE__, :array, [object], [])
  end

  def array(object, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :array, [object], opts)
  end

  def array(object, dtype) do
    SnakeBridge.Runtime.call(__MODULE__, :array, [object, dtype], [])
  end

  def array(object, dtype, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :array, [object, dtype], opts)
  end

  @doc """
  Convert a string or number to a floating point number, if possible.

  Returns:
  - `float()`
  """
  @spec nan() :: {:ok, float()} | {:error, Snakepit.Error.t()}
  def nan() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :nan)
  end

  defmodule Ndarray do
    def __snakebridge_python_name__, do: "numpy"
    def __snakebridge_python_class__, do: "ndarray"
    def __snakebridge_library__, do: "numpy"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec byteswap(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def byteswap(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :byteswap, [] ++ List.wrap(args), opts)
    end

    @spec diagonal(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def diagonal(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :diagonal, [] ++ List.wrap(args), opts)
    end

    @spec astype(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def astype(ref, dtype, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :astype, [dtype] ++ List.wrap(args), opts)
    end

    @spec reshape(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def reshape(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :reshape, [] ++ List.wrap(args), opts)
    end

    @spec prod(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def prod(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :prod, [] ++ List.wrap(args), opts)
    end

    @spec squeeze(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def squeeze(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :squeeze, [] ++ List.wrap(args), opts)
    end

    @spec max(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def max(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :max, [] ++ List.wrap(args), opts)
    end

    @spec tofile(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def tofile(ref, fid, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :tofile, [fid] ++ List.wrap(args), opts)
    end

    @spec compress(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def compress(ref, condition, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :compress, [condition] ++ List.wrap(args), opts)
    end

    @spec copy(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def copy(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :copy, [] ++ List.wrap(args), opts)
    end

    @spec argmin(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def argmin(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :argmin, [] ++ List.wrap(args), opts)
    end

    @spec getfield(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def getfield(ref, dtype, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :getfield, [dtype] ++ List.wrap(args), opts)
    end

    @spec fill(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def fill(ref, value, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :fill, [value], opts)
    end

    @spec choose(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def choose(ref, choices, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :choose, [choices] ++ List.wrap(args), opts)
    end

    @spec cumprod(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def cumprod(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :cumprod, [] ++ List.wrap(args), opts)
    end

    @spec setflags(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def setflags(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :setflags, [], opts)
    end

    @spec all(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def all(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :all, [] ++ List.wrap(args), opts)
    end

    @spec any(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def any(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :any, [] ++ List.wrap(args), opts)
    end

    @spec put(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def put(ref, indices, values, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :put, [indices, values] ++ List.wrap(args), opts)
    end

    @spec item(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def item(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :item, [] ++ List.wrap(args), opts)
    end

    @spec view(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def view(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :view, [] ++ List.wrap(args), opts)
    end

    @spec resize(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def resize(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :resize, [] ++ List.wrap(args), opts)
    end

    @spec to_device(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def to_device(ref, device, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :to_device, [device], opts)
    end

    @spec tolist(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def tolist(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :tolist, [], opts)
    end

    @spec sum(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def sum(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :sum, [] ++ List.wrap(args), opts)
    end

    @spec sort(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def sort(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :sort, [] ++ List.wrap(args), opts)
    end

    @spec tobytes(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def tobytes(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :tobytes, [] ++ List.wrap(args), opts)
    end

    @spec min(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def min(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :min, [] ++ List.wrap(args), opts)
    end

    @spec conjugate(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def conjugate(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :conjugate, [], opts)
    end

    @spec nonzero(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def nonzero(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :nonzero, [], opts)
    end

    @spec trace(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def trace(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :trace, [] ++ List.wrap(args), opts)
    end

    @spec conj(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def conj(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :conj, [], opts)
    end

    @spec argmax(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def argmax(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :argmax, [] ++ List.wrap(args), opts)
    end

    @spec clip(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def clip(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :clip, [] ++ List.wrap(args), opts)
    end

    @spec searchsorted(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def searchsorted(ref, v, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :searchsorted, [v] ++ List.wrap(args), opts)
    end

    @spec round(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def round(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :round, [] ++ List.wrap(args), opts)
    end

    @spec flatten(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def flatten(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :flatten, [] ++ List.wrap(args), opts)
    end

    @spec partition(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def partition(ref, kth, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :partition, [kth] ++ List.wrap(args), opts)
    end

    @spec setfield(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def setfield(ref, val, dtype, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :setfield, [val, dtype] ++ List.wrap(args), opts)
    end

    @spec repeat(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def repeat(ref, repeats, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :repeat, [repeats] ++ List.wrap(args), opts)
    end

    @spec mean(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def mean(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :mean, [] ++ List.wrap(args), opts)
    end

    @spec std(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def std(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :std, [] ++ List.wrap(args), opts)
    end

    @spec take(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def take(ref, indices, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :take, [indices] ++ List.wrap(args), opts)
    end

    @spec var(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def var(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :var, [] ++ List.wrap(args), opts)
    end

    @spec transpose(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def transpose(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :transpose, [] ++ List.wrap(args), opts)
    end

    @spec cumsum(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def cumsum(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :cumsum, [] ++ List.wrap(args), opts)
    end

    @spec swapaxes(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def swapaxes(ref, axis1, axis2, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :swapaxes, [axis1, axis2], opts)
    end

    @spec dot(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dot(ref, other, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :dot, [other] ++ List.wrap(args), opts)
    end

    @spec dump(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def dump(ref, file, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dump, [file], opts)
    end

    @spec argpartition(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def argpartition(ref, kth, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :argpartition, [kth] ++ List.wrap(args), opts)
    end

    @spec ravel(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def ravel(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :ravel, [] ++ List.wrap(args), opts)
    end

    @spec argsort(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def argsort(ref, args, opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :argsort, [] ++ List.wrap(args), opts)
    end

    @spec dumps(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dumps(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :dumps, [], opts)
    end

    @spec t(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def t(ref) do
      SnakeBridge.Runtime.get_attr(ref, :T)
    end

    @spec base(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def base(ref) do
      SnakeBridge.Runtime.get_attr(ref, :base)
    end

    @spec ctypes(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def ctypes(ref) do
      SnakeBridge.Runtime.get_attr(ref, :ctypes)
    end

    @spec data(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def data(ref) do
      SnakeBridge.Runtime.get_attr(ref, :data)
    end

    @spec device(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def device(ref) do
      SnakeBridge.Runtime.get_attr(ref, :device)
    end

    @spec dtype(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def dtype(ref) do
      SnakeBridge.Runtime.get_attr(ref, :dtype)
    end

    @spec flags(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def flags(ref) do
      SnakeBridge.Runtime.get_attr(ref, :flags)
    end

    @spec flat(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def flat(ref) do
      SnakeBridge.Runtime.get_attr(ref, :flat)
    end

    @spec imag(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def imag(ref) do
      SnakeBridge.Runtime.get_attr(ref, :imag)
    end

    @spec itemsize(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def itemsize(ref) do
      SnakeBridge.Runtime.get_attr(ref, :itemsize)
    end

    @spec m_t(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def m_t(ref) do
      SnakeBridge.Runtime.get_attr(ref, :mT)
    end

    @spec nbytes(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def nbytes(ref) do
      SnakeBridge.Runtime.get_attr(ref, :nbytes)
    end

    @spec ndim(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def ndim(ref) do
      SnakeBridge.Runtime.get_attr(ref, :ndim)
    end

    @spec real(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def real(ref) do
      SnakeBridge.Runtime.get_attr(ref, :real)
    end

    @spec shape(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def shape(ref) do
      SnakeBridge.Runtime.get_attr(ref, :shape)
    end

    @spec size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def size(ref) do
      SnakeBridge.Runtime.get_attr(ref, :size)
    end

    @spec strides(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def strides(ref) do
      SnakeBridge.Runtime.get_attr(ref, :strides)
    end
  end

  @doc false
  def __functions__ do
    [
      {:array, 1, __MODULE__,
       "array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,"},
      {:nan, 0, __MODULE__, "Convert a string or number to a floating point number, if possible."}
    ]
  end

  @doc false
  def __classes__ do
    [
      {Numpy.Ndarray,
       "ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None)\n\nAn array object represents a multidimensional, homogeneous array\nof fixed-size items.  An associated data-type object describes the\nformat of each element in the array (its byte-order, how many bytes it\noccupies in memory, whether it is an integer, a floating point number,\nor something else, etc.)\n\nArrays should be constructed using `array`, `zeros` or `empty` (refer\nto the See Also section below).  The parameters given here refer to\na low-level method (`ndarray(...)`) for instantiating an array.\n\nFor more information, refer to the `numpy` module and examine the\nmethods and attributes of an array.\n\nParameters\n----------\n(for the __new__ method; see Notes below)\n\nshape : tuple of ints\n    Shape of created array.\ndtype : data-type, optional\n    Any object that can be interpreted as a numpy data type.\n    Default is `numpy.float64`.\nbuffer : object exposing buffer interface, optional\n    Used to fill the array with data.\noffset : int, optional\n    Offset of array data in buffer.\nstrides : tuple of ints, optional\n    Strides of data in memory.\norder : {'C', 'F'}, optional\n    Row-major (C-style) or column-major (Fortran-style) order.\n\nAttributes\n----------\nT : ndarray\n    Transpose of the array.\ndata : buffer\n    The array's elements, in memory.\ndtype : dtype object\n    Describes the format of the elements in the array.\nflags : dict\n    Dictionary containing information related to memory use, e.g.,\n    'C_CONTIGUOUS', 'OWNDATA', 'WRITEABLE', etc.\nflat : numpy.flatiter object\n    Flattened version of the array as an iterator.  The iterator\n    allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for\n    assignment examples; TODO).\nimag : ndarray\n    Imaginary part of the array.\nreal : ndarray\n    Real part of the array.\nsize : int\n    Number of elements in the array.\nitemsize : int\n    The memory use of each array element in bytes.\nnbytes : int\n    The total number of bytes required to store the array data,\n    i.e., ``itemsize * size``.\nndim : int\n    The array's number of dimensions.\nshape : tuple of ints\n    Shape of the array.\nstrides : tuple of ints\n    The step-size required to move from one element to the next in\n    memory. For example, a contiguous ``(3, 4)`` array of type\n    ``int16`` in C-order has strides ``(8, 2)``.  This implies that\n    to move from element to element in memory requires jumps of 2 bytes.\n    To move from row-to-row, one needs to jump 8 bytes at a time\n    (``2 * 4``).\nctypes : ctypes object\n    Class containing properties of the array needed for interaction\n    with ctypes.\nbase : ndarray\n    If the array is a view into another array, that array is its `base`\n    (unless that array is also a view).  The `base` array is where the\n    array data is actually stored.\n\nSee Also\n--------\narray : Construct an array.\nzeros : Create an array, each element of which is zero.\nempty : Create an array, but leave its allocated memory unchanged (i.e.,\n        it contains \"garbage\").\ndtype : Create a data-type.\nnumpy.typing.NDArray : An ndarray alias :term:`generic <generic type>`\n                       w.r.t. its `dtype.type <numpy.dtype.type>`.\n\nNotes\n-----\nThere are two modes of creating an array using ``__new__``:\n\n1. If `buffer` is None, then only `shape`, `dtype`, and `order`\n   are used.\n2. If `buffer` is an object exposing the buffer interface, then\n   all keywords are interpreted.\n\nNo ``__init__`` method is needed because the array is fully initialized\nafter the ``__new__`` method.\n\nExamples\n--------\nThese examples illustrate the low-level `ndarray` constructor.  Refer\nto the `See Also` section above for easier ways of constructing an\nndarray.\n\nFirst mode, `buffer` is None:\n\n>>> import numpy as np\n>>> np.ndarray(shape=(2,2), dtype=float, order='F')\narray([[0.0e+000, 0.0e+000], # random\n       [     nan, 2.5e-323]])\n\nSecond mode:\n\n>>> np.ndarray((2,), buffer=np.array([1,2,3]),\n...            offset=np.int_().itemsize,\n...            dtype=int) # offset = 1*itemsize, i.e. skip first element\narray([2, 3])"}
    ]
  end

  @doc false
  def __search__(query) do
    SnakeBridge.Docs.search(__MODULE__, query)
  end

  @doc false
  def doc(function) do
    SnakeBridge.Docs.get(__MODULE__, function)
  end
end
