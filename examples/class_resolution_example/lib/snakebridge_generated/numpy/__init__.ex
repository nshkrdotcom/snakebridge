# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: numpy stdlib
# Python module: numpy

defmodule Numpy do
  @moduledoc """
  NumPy

  =====

  Provides
    1. An array object of arbitrary homogeneous items
    2. Fast mathematical operations over arrays
    3. Linear Algebra, Fourier Transforms, Random Number Generation

  How to use the documentation
  ----------------------------
  Documentation is available in two forms: docstrings provided
  with the code, and a loose standing reference guide, available from
  `the NumPy homepage <https://numpy.org>`_.

  We recommend exploring the docstrings using
  `IPython <https://ipython.org>`_, an advanced Python shell with
  TAB-completion and introspection capabilities.  See below for further
  instructions.

  The docstring examples assume that `numpy` has been imported as ``np``::

    >>> import numpy as np

  Code snippets are indicated by three greater-than signs::

    >>> x = 42
    >>> x = x + 1

  Use the built-in ``help`` function to view a function's docstring::

    >>> help(np.sort)
    ... # doctest: +SKIP

  For some objects, ``np.info(obj)`` may provide additional help.  This is
  particularly true if you see the line "Help on ufunc object:" at the top
  of the help() page.  Ufuncs are implemented in C, not Python, for speed.
  The native Python help() does not know how to view their help, but our
  np.info() function does.

  Available subpackages
  ---------------------
  lib
      Basic functions used by several sub-packages.
  random
      Core Random Tools
  linalg
      Core Linear Algebra Tools
  fft
      Core FFT routines
  polynomial
      Polynomial tools
  testing
      NumPy testing tools
  distutils
      Enhancements to distutils with support for
      Fortran compilers support and more (for Python <= 3.11)

  Utilities
  ---------
  test
      Run numpy unittests
  show_config
      Show numpy build configuration
  __version__
      NumPy version string

  Viewing documentation using IPython
  -----------------------------------

  Start IPython and import `numpy` usually under the alias ``np``: `import
  numpy as np`.  Then, directly past or use the ``%cpaste`` magic to paste
  examples into the shell.  To see which functions are available in `numpy`,
  type ``np.<TAB>`` (where ``<TAB>`` refers to the TAB key), or use
  ``np.*cos*?<ENTER>`` (where ``<ENTER>`` refers to the ENTER key) to narrow
  down the list.  To view the docstring for a function, use
  ``np.cos?<ENTER>`` (to view the docstring) and ``np.cos??<ENTER>`` (to view
  the source code).

  Copies vs. in-place operation
  -----------------------------
  Most of the functions in `numpy` return a copy of the array argument
  (e.g., `np.sort`).  In-place versions of these functions are often
  available as array methods, i.e. ``x = np.array([1,2,3]); x.sort()``.
  Exceptions to this rule are documented.

  ## Python Docs

  - [Python docs](https://docs.python.org/3/library/numpy.html)

  ## Version

  - Python stdlib (Python 3.12.3)

  ## Runtime Options

  All functions accept a `__runtime__` option for controlling execution behavior:

      Numpy.some_function(args, __runtime__: [timeout: 120_000])

  ### Supported runtime options

  - `:timeout` - Call timeout in milliseconds (default: 120,000ms / 2 minutes)
  - `:timeout_profile` - Use a named profile (`:default`, `:ml_inference`, `:batch_job`, `:streaming`)
  - `:stream_timeout` - Timeout for streaming operations (default: 1,800,000ms / 30 minutes)
  - `:session_id` - Override the session ID for this call
  - `:pool_name` - Target a specific Snakepit pool (multi-pool setups)
  - `:affinity` - Override session affinity (`:hint`, `:strict_queue`, `:strict_fail_fast`)

  ### Timeout Profiles

  - `:default` - 2 minute timeout for regular calls
  - `:ml_inference` - 10 minute timeout for ML/LLM workloads
  - `:batch_job` - Unlimited timeout for long-running jobs
  - `:streaming` - 2 minute timeout, 30 minute stream_timeout

  ### Example with timeout override

      # For a long-running ML inference call
      Numpy.predict(data, __runtime__: [timeout_profile: :ml_inference])

      # Or explicit timeout
      Numpy.predict(data, __runtime__: [timeout: 600_000])

      # Route to a pool and enforce strict affinity
      Numpy.predict(data, __runtime__: [pool_name: :strict_pool, affinity: :strict_queue])

  See `SnakeBridge.Defaults` for global timeout configuration.

  """

  @doc false
  def __snakebridge_python_name__, do: "numpy"
  @doc false
  def __snakebridge_library__, do: "numpy"

  @doc """
  array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,

  ndmax=0, like=None)

  Create an array.

  ## Parameters

  - `object` - array_like An array, any object exposing the array interface, an object whose ``__array__`` method returns an array, or any (nested) sequence. If object is a scalar, a 0-dimensional array containing object is returned.
  - `dtype` - data-type, optional The desired data-type for the array. If not given, NumPy will try to use a default ``dtype`` that can represent the values (by applying promotion rules when necessary.)
  - `copy` - bool, optional If ``True`` (default), then the array data is copied. If ``None``, a copy will only be made if ``__array__`` returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (``dtype``, ``order``, etc.). Note that any copy of the data is shallow, i.e., for arrays with object dtype, the new array will point to the same objects. See Examples for `ndarray.copy`. For ``False`` it raises a ``ValueError`` if a copy cannot be avoided. Default: ``True``.
  - `order` - {'K', 'A', 'C', 'F'}, optional Specify the memory layout of the array. If object is not an array, the newly created array will be in C order (row major) unless 'F' is specified, in which case it will be in Fortran order (column major). If object is an array the following holds.
  - `subok` - bool, optional If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).
  - `ndmin` - int, optional Specifies the minimum number of dimensions that the resulting array should have.  Ones will be prepended to the shape as needed to meet this requirement.
  - `ndmax` - int, optional Specifies the maximum number of dimensions to create when inferring shape from nested sequences. By default (ndmax=0), NumPy recurses through all nesting levels (up to the compile-time constant ``NPY_MAXDIMS``). Setting ``ndmax`` stops recursion at the specified depth, preserving deeper nested structures as objects instead of promoting them to higher-dimensional arrays. In this case, ``dtype=object`` is required.
  - `like` - array_like, optional Reference object to allow the creation of arrays which are not NumPy arrays. If an array-like passed in as ``like`` supports the ``__array_function__`` protocol, the result will be defined by it. In this case, it ensures the creation of an array object compatible with that passed in via this argument.

  ## Returns

  Returns `out`. ndarray An array object satisfying the specified requirements.

  ## Examples

    iex> import numpy as np
    iex> np.array([1, 2, 3])
    array([1, 2, 3])

    Upcasting:

    iex> np.array([1, 2, 3.0])
    array([ 1.,  2.,  3.])

    More than one dimension:

    iex> np.array([[1, 2], [3, 4]])
    array([[1, 2],
    [3, 4]])

    Minimum dimensions 2:

    iex> np.array([1, 2, 3], ndmin=2)
    array([[1, 2, 3]])

    Type provided:

    iex> np.array([1, 2, 3], dtype=complex)
    array([ 1.+0.j,  2.+0.j,  3.+0.j])

    Data-type consisting of more than one element:

    iex> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')])
    iex> x['a']
    array([1, 3], dtype=int32)

    Creating an array from sub-classes:

    iex> np.array(np.asmatrix('1 2; 3 4'))
    array([[1, 2],
    [3, 4]])

    iex> np.array(np.asmatrix('1 2; 3 4'), subok=True)
    matrix([[1, 2],
    [3, 4]])

    Limiting the maximum dimensions with ``ndmax``:

    iex> a = np.array([[1, 2], [3, 4]], dtype=object, ndmax=2)
    iex> a
    array([[1, 2],
    [3, 4]], dtype=object)
    iex> a.shape
    (2, 2)

    iex> b = np.array([[1, 2], [3, 4]], dtype=object, ndmax=1)
    iex> b
    array([list([1, 2]), list([3, 4])], dtype=object)
    iex> b.shape
    (2,)

  ## Notes

  When order is 'A' and ``object`` is an array in neither 'C' nor 'F' order,
  and a copy is forced by a change in dtype, then the order of the result is
  not necessarily 'C' as expected. This is likely a bug.
  """
  @spec array(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec array(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec array(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec array(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def array(object) do
    SnakeBridge.Runtime.call(__MODULE__, :array, [object], [])
  end

  def array(object, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :array, [object], opts)
  end

  def array(object, dtype) do
    SnakeBridge.Runtime.call(__MODULE__, :array, [object, dtype], [])
  end

  def array(object, dtype, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :array, [object, dtype], opts)
  end

  @doc """
  Convert a string or number to a floating point number, if possible.

  ## Returns

  - `float()`
  """
  @spec nan() :: {:ok, float()} | {:error, Snakepit.Error.t()}
  def nan() do
    SnakeBridge.Runtime.get_module_attr(__MODULE__, :nan)
  end

  @doc false
  def __functions__ do
    [
      {:array, 1, __MODULE__,
       "array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,"},
      {:nan, 0, __MODULE__, "Convert a string or number to a floating point number, if possible."}
    ]
  end

  @doc false
  def __classes__ do
    [
      {Numpy.Ndarray,
       "ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None)\n\nAn array object represents a multidimensional, homogeneous array\nof fixed-size items.  An associated data-type object describes the\nformat of each element in the array (its byte-order, how many bytes it\noccupies in memory, whether it is an integer, a floating point number,\nor something else, etc.)\n\nArrays should be constructed using `array`, `zeros` or `empty` (refer\nto the See Also section below).  The parameters given here refer to\na low-level method (`ndarray(...)`) for instantiating an array.\n\nFor more information, refer to the `numpy` module and examine the\nmethods and attributes of an array.\n\nParameters\n----------\n(for the __new__ method; see Notes below)\n\nshape : tuple of ints\n    Shape of created array.\ndtype : data-type, optional\n    Any object that can be interpreted as a numpy data type.\n    Default is `numpy.float64`.\nbuffer : object exposing buffer interface, optional\n    Used to fill the array with data.\noffset : int, optional\n    Offset of array data in buffer.\nstrides : tuple of ints, optional\n    Strides of data in memory.\norder : {'C', 'F'}, optional\n    Row-major (C-style) or column-major (Fortran-style) order.\n\nAttributes\n----------\nT : ndarray\n    Transpose of the array.\ndata : buffer\n    The array's elements, in memory.\ndtype : dtype object\n    Describes the format of the elements in the array.\nflags : dict\n    Dictionary containing information related to memory use, e.g.,\n    'C_CONTIGUOUS', 'OWNDATA', 'WRITEABLE', etc.\nflat : numpy.flatiter object\n    Flattened version of the array as an iterator.  The iterator\n    allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for\n    assignment examples; TODO).\nimag : ndarray\n    Imaginary part of the array.\nreal : ndarray\n    Real part of the array.\nsize : int\n    Number of elements in the array.\nitemsize : int\n    The memory use of each array element in bytes.\nnbytes : int\n    The total number of bytes required to store the array data,\n    i.e., ``itemsize * size``.\nndim : int\n    The array's number of dimensions.\nshape : tuple of ints\n    Shape of the array.\nstrides : tuple of ints\n    The step-size required to move from one element to the next in\n    memory. For example, a contiguous ``(3, 4)`` array of type\n    ``int16`` in C-order has strides ``(8, 2)``.  This implies that\n    to move from element to element in memory requires jumps of 2 bytes.\n    To move from row-to-row, one needs to jump 8 bytes at a time\n    (``2 * 4``).\nctypes : ctypes object\n    Class containing properties of the array needed for interaction\n    with ctypes.\nbase : ndarray\n    If the array is a view into another array, that array is its `base`\n    (unless that array is also a view).  The `base` array is where the\n    array data is actually stored.\n\nSee Also\n--------\narray : Construct an array.\nzeros : Create an array, each element of which is zero.\nempty : Create an array, but leave its allocated memory unchanged (i.e.,\n        it contains \"garbage\").\ndtype : Create a data-type.\nnumpy.typing.NDArray : An ndarray alias :term:`generic <generic type>`\n                       w.r.t. its `dtype.type <numpy.dtype.type>`.\n\nNotes\n-----\nThere are two modes of creating an array using ``__new__``:\n\n1. If `buffer` is None, then only `shape`, `dtype`, and `order`\n   are used.\n2. If `buffer` is an object exposing the buffer interface, then\n   all keywords are interpreted.\n\nNo ``__init__`` method is needed because the array is fully initialized\nafter the ``__new__`` method.\n\nExamples\n--------\nThese examples illustrate the low-level `ndarray` constructor.  Refer\nto the `See Also` section above for easier ways of constructing an\nndarray.\n\nFirst mode, `buffer` is None:\n\n>>> import numpy as np\n>>> np.ndarray(shape=(2,2), dtype=float, order='F')\narray([[0.0e+000, 0.0e+000], # random\n       [     nan, 2.5e-323]])\n\nSecond mode:\n\n>>> np.ndarray((2,), buffer=np.array([1,2,3]),\n...            offset=np.int_().itemsize,\n...            dtype=int) # offset = 1*itemsize, i.e. skip first element\narray([2, 3])"}
    ]
  end

  @doc false
  def __search__(query) do
    SnakeBridge.Docs.search(__MODULE__, query)
  end

  @doc false
  def doc(function) do
    SnakeBridge.Docs.get(__MODULE__, function)
  end
end
