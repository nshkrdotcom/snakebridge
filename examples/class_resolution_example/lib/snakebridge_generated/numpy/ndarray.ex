# Generated by SnakeBridge v0.12.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: numpy stdlib
# Python module: numpy
# Python class: ndarray

defmodule Numpy.Ndarray do
  def __snakebridge_python_name__, do: "numpy"
  def __snakebridge_python_class__, do: "ndarray"
  def __snakebridge_library__, do: "numpy"
  @opaque t :: SnakeBridge.Ref.t()

  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @spec byteswap(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def byteswap(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :byteswap, [] ++ List.wrap(args), opts)
  end

  @spec diagonal(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def diagonal(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :diagonal, [] ++ List.wrap(args), opts)
  end

  @spec astype(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def astype(ref, dtype, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :astype, [dtype] ++ List.wrap(args), opts)
  end

  @spec reshape(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def reshape(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :reshape, [] ++ List.wrap(args), opts)
  end

  @spec prod(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def prod(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :prod, [] ++ List.wrap(args), opts)
  end

  @spec squeeze(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def squeeze(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :squeeze, [] ++ List.wrap(args), opts)
  end

  @spec max(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def max(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :max, [] ++ List.wrap(args), opts)
  end

  @spec tofile(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def tofile(ref, fid, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :tofile, [fid] ++ List.wrap(args), opts)
  end

  @spec compress(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def compress(ref, condition, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :compress, [condition] ++ List.wrap(args), opts)
  end

  @spec copy(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def copy(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :copy, [] ++ List.wrap(args), opts)
  end

  @spec argmin(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def argmin(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :argmin, [] ++ List.wrap(args), opts)
  end

  @spec getfield(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def getfield(ref, dtype, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :getfield, [dtype] ++ List.wrap(args), opts)
  end

  @spec fill(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def fill(ref, value, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :fill, [value], opts)
  end

  @spec choose(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def choose(ref, choices, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :choose, [choices] ++ List.wrap(args), opts)
  end

  @spec cumprod(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def cumprod(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :cumprod, [] ++ List.wrap(args), opts)
  end

  @spec setflags(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def setflags(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :setflags, [], opts)
  end

  @spec all(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def all(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :all, [] ++ List.wrap(args), opts)
  end

  @spec any(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def any(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :any, [] ++ List.wrap(args), opts)
  end

  @spec put(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def put(ref, indices, values, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :put, [indices, values] ++ List.wrap(args), opts)
  end

  @spec item(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def item(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :item, [] ++ List.wrap(args), opts)
  end

  @spec view(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def view(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :view, [] ++ List.wrap(args), opts)
  end

  @spec resize(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def resize(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :resize, [] ++ List.wrap(args), opts)
  end

  @spec to_device(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def to_device(ref, device, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :to_device, [device], opts)
  end

  @spec tolist(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def tolist(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :tolist, [], opts)
  end

  @spec sum(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def sum(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :sum, [] ++ List.wrap(args), opts)
  end

  @spec sort(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def sort(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :sort, [] ++ List.wrap(args), opts)
  end

  @spec tobytes(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def tobytes(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :tobytes, [] ++ List.wrap(args), opts)
  end

  @spec min(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def min(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :min, [] ++ List.wrap(args), opts)
  end

  @spec conjugate(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def conjugate(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :conjugate, [], opts)
  end

  @spec nonzero(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def nonzero(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :nonzero, [], opts)
  end

  @spec trace(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def trace(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :trace, [] ++ List.wrap(args), opts)
  end

  @spec conj(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def conj(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :conj, [], opts)
  end

  @spec argmax(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def argmax(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :argmax, [] ++ List.wrap(args), opts)
  end

  @spec clip(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def clip(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :clip, [] ++ List.wrap(args), opts)
  end

  @spec searchsorted(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def searchsorted(ref, v, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :searchsorted, [v] ++ List.wrap(args), opts)
  end

  @spec round(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def round(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :round, [] ++ List.wrap(args), opts)
  end

  @spec flatten(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def flatten(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :flatten, [] ++ List.wrap(args), opts)
  end

  @spec partition(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def partition(ref, kth, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :partition, [kth] ++ List.wrap(args), opts)
  end

  @spec setfield(SnakeBridge.Ref.t(), term(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def setfield(ref, val, dtype, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :setfield, [val, dtype] ++ List.wrap(args), opts)
  end

  @spec repeat(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def repeat(ref, repeats, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :repeat, [repeats] ++ List.wrap(args), opts)
  end

  @spec mean(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def mean(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :mean, [] ++ List.wrap(args), opts)
  end

  @spec std(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def std(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :std, [] ++ List.wrap(args), opts)
  end

  @spec take(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def take(ref, indices, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :take, [indices] ++ List.wrap(args), opts)
  end

  @spec var(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def var(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :var, [] ++ List.wrap(args), opts)
  end

  @spec transpose(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def transpose(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :transpose, [] ++ List.wrap(args), opts)
  end

  @spec cumsum(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def cumsum(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :cumsum, [] ++ List.wrap(args), opts)
  end

  @spec swapaxes(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def swapaxes(ref, axis1, axis2, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :swapaxes, [axis1, axis2], opts)
  end

  @spec dot(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def dot(ref, other, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :dot, [other] ++ List.wrap(args), opts)
  end

  @spec dump(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def dump(ref, file, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :dump, [file], opts)
  end

  @spec argpartition(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def argpartition(ref, kth, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :argpartition, [kth] ++ List.wrap(args), opts)
  end

  @spec ravel(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def ravel(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :ravel, [] ++ List.wrap(args), opts)
  end

  @spec argsort(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def argsort(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :argsort, [] ++ List.wrap(args), opts)
  end

  @spec dumps(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def dumps(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :dumps, [], opts)
  end

  @spec t(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def t(ref) do
    SnakeBridge.Runtime.get_attr(ref, :T)
  end

  @spec base(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def base(ref) do
    SnakeBridge.Runtime.get_attr(ref, :base)
  end

  @spec ctypes(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def ctypes(ref) do
    SnakeBridge.Runtime.get_attr(ref, :ctypes)
  end

  @spec data(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def data(ref) do
    SnakeBridge.Runtime.get_attr(ref, :data)
  end

  @spec device(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def device(ref) do
    SnakeBridge.Runtime.get_attr(ref, :device)
  end

  @spec dtype(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def dtype(ref) do
    SnakeBridge.Runtime.get_attr(ref, :dtype)
  end

  @spec flags(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def flags(ref) do
    SnakeBridge.Runtime.get_attr(ref, :flags)
  end

  @spec flat(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def flat(ref) do
    SnakeBridge.Runtime.get_attr(ref, :flat)
  end

  @spec imag(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def imag(ref) do
    SnakeBridge.Runtime.get_attr(ref, :imag)
  end

  @spec itemsize(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def itemsize(ref) do
    SnakeBridge.Runtime.get_attr(ref, :itemsize)
  end

  @spec m_t(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def m_t(ref) do
    SnakeBridge.Runtime.get_attr(ref, :mT)
  end

  @spec nbytes(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def nbytes(ref) do
    SnakeBridge.Runtime.get_attr(ref, :nbytes)
  end

  @spec ndim(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def ndim(ref) do
    SnakeBridge.Runtime.get_attr(ref, :ndim)
  end

  @spec real(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def real(ref) do
    SnakeBridge.Runtime.get_attr(ref, :real)
  end

  @spec shape(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def shape(ref) do
    SnakeBridge.Runtime.get_attr(ref, :shape)
  end

  @spec size(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def size(ref) do
    SnakeBridge.Runtime.get_attr(ref, :size)
  end

  @spec strides(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def strides(ref) do
    SnakeBridge.Runtime.get_attr(ref, :strides)
  end
end
