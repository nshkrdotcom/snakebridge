# Generated by SnakeBridge v0.7.7 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: pathlib stdlib

defmodule Pathlib do
  @moduledoc """
  SnakeBridge bindings for `pathlib`.

  ## Runtime Options

  All functions accept a `__runtime__` option for controlling execution behavior:

      Elixir.Pathlib.some_function(args, __runtime__: [timeout: 120_000])

  ### Supported runtime options

  - `:timeout` - Call timeout in milliseconds (default: 120,000ms / 2 minutes)
  - `:timeout_profile` - Use a named profile (`:default`, `:ml_inference`, `:batch_job`, `:streaming`)
  - `:stream_timeout` - Timeout for streaming operations (default: 1,800,000ms / 30 minutes)
  - `:session_id` - Override the session ID for this call

  ### Timeout Profiles

  - `:default` - 2 minute timeout for regular calls
  - `:ml_inference` - 10 minute timeout for ML/LLM workloads
  - `:batch_job` - Unlimited timeout for long-running jobs
  - `:streaming` - 2 minute timeout, 30 minute stream_timeout

  ### Example with timeout override

      # For a long-running ML inference call
      Elixir.Pathlib.predict(data, __runtime__: [timeout_profile: :ml_inference])

      # Or explicit timeout
      Elixir.Pathlib.predict(data, __runtime__: [timeout: 600_000])

  See `SnakeBridge.Defaults` for global timeout configuration.
  """

  def __snakebridge_python_name__, do: "pathlib"
  def __snakebridge_library__, do: "pathlib"

  defmodule Path do
    def __snakebridge_python_name__, do: "pathlib"
    def __snakebridge_python_class__, do: "Path"
    def __snakebridge_library__, do: "pathlib"
    @opaque t :: SnakeBridge.Ref.t()

    @spec new(list(term()), keyword()) ::
            {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
    def new(args \\ [], opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
    end

    @spec _format_parsed_parts(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _format_parsed_parts(ref, drv, root, tail, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_format_parsed_parts, [drv, root, tail], opts)
    end

    @spec _from_parsed_parts(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _from_parsed_parts(ref, drv, root, tail, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_from_parsed_parts, [drv, root, tail], opts)
    end

    @spec _load_parts(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _load_parts(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_load_parts, [], opts)
    end

    @spec _make_child_relpath(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _make_child_relpath(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_make_child_relpath, [name], opts)
    end

    @spec _parse_path(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parse_path(ref, path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_parse_path, [path], opts)
    end

    @spec _scandir(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _scandir(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :_scandir, [], opts)
    end

    @spec absolute(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def absolute(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :absolute, [], opts)
    end

    @spec as_posix(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def as_posix(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :as_posix, [], opts)
    end

    @spec as_uri(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def as_uri(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :as_uri, [], opts)
    end

    @spec chmod(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def chmod(ref, mode, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :chmod, [mode], opts)
    end

    @spec cwd(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def cwd(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :cwd, [], opts)
    end

    @spec exists(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def exists(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :exists, [], opts)
    end

    @spec expanduser(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def expanduser(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :expanduser, [], opts)
    end

    @spec glob(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def glob(ref, pattern, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :glob, [pattern], opts)
    end

    @spec group(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def group(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :group, [], opts)
    end

    @spec hardlink_to(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def hardlink_to(ref, target, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :hardlink_to, [target], opts)
    end

    @spec home(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def home(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :home, [], opts)
    end

    @spec is_absolute(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def is_absolute(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_absolute, [], opts)
    end

    @spec is_block_device(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def is_block_device(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_block_device, [], opts)
    end

    @spec is_char_device(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def is_char_device(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_char_device, [], opts)
    end

    @spec is_dir(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def is_dir(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_dir, [], opts)
    end

    @spec is_fifo(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def is_fifo(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_fifo, [], opts)
    end

    @spec is_file(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def is_file(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_file, [], opts)
    end

    @spec is_junction(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def is_junction(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_junction, [], opts)
    end

    @spec is_mount(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def is_mount(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_mount, [], opts)
    end

    @spec is_relative_to(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def is_relative_to(ref, other, args \\ [], opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :is_relative_to, [other] ++ List.wrap(args), opts)
    end

    @spec is_reserved(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def is_reserved(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_reserved, [], opts)
    end

    @spec is_socket(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def is_socket(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_socket, [], opts)
    end

    @spec is_symlink(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def is_symlink(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :is_symlink, [], opts)
    end

    @spec iterdir(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def iterdir(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :iterdir, [], opts)
    end

    @spec joinpath(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def joinpath(ref, args \\ [], opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :joinpath, [] ++ List.wrap(args), opts)
    end

    @spec lchmod(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def lchmod(ref, mode, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :lchmod, [mode], opts)
    end

    @spec lstat(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def lstat(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :lstat, [], opts)
    end

    @spec match(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def match(ref, path_pattern, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :match, [path_pattern], opts)
    end

    @spec mkdir(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def mkdir(ref, args \\ [], opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :mkdir, [] ++ List.wrap(args), opts)
    end

    @spec open(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def open(ref, args \\ [], opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :open, [] ++ List.wrap(args), opts)
    end

    @spec owner(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def owner(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :owner, [], opts)
    end

    @spec read_bytes(SnakeBridge.Ref.t(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def read_bytes(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :read_bytes, [], opts)
    end

    @spec read_text(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def read_text(ref, args \\ [], opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :read_text, [] ++ List.wrap(args), opts)
    end

    @spec readlink(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def readlink(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :readlink, [], opts)
    end

    @spec relative_to(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def relative_to(ref, other, args \\ [], opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :relative_to, [other] ++ List.wrap(args), opts)
    end

    @spec rename(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def rename(ref, target, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :rename, [target], opts)
    end

    @spec replace(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def replace(ref, target, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :replace, [target], opts)
    end

    @spec resolve(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def resolve(ref, args \\ [], opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :resolve, [] ++ List.wrap(args), opts)
    end

    @spec rglob(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def rglob(ref, pattern, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :rglob, [pattern], opts)
    end

    @spec rmdir(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def rmdir(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :rmdir, [], opts)
    end

    @spec samefile(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def samefile(ref, other_path, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :samefile, [other_path], opts)
    end

    @spec stat(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def stat(ref, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :stat, [], opts)
    end

    @spec symlink_to(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def symlink_to(ref, target, args \\ [], opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :symlink_to, [target] ++ List.wrap(args), opts)
    end

    @spec touch(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def touch(ref, args \\ [], opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :touch, [] ++ List.wrap(args), opts)
    end

    @spec unlink(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def unlink(ref, args \\ [], opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :unlink, [] ++ List.wrap(args), opts)
    end

    @spec walk(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def walk(ref, args \\ [], opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :walk, [] ++ List.wrap(args), opts)
    end

    @spec with_name(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_name(ref, name, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_name, [name], opts)
    end

    @spec with_segments(SnakeBridge.Ref.t(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_segments(ref, args \\ [], opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :with_segments, [] ++ List.wrap(args), opts)
    end

    @spec with_stem(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_stem(ref, stem, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_stem, [stem], opts)
    end

    @spec with_suffix(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def with_suffix(ref, suffix, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :with_suffix, [suffix], opts)
    end

    @spec write_bytes(SnakeBridge.Ref.t(), term(), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def write_bytes(ref, data, opts \\ []) do
      SnakeBridge.Runtime.call_method(ref, :write_bytes, [data], opts)
    end

    @spec write_text(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def write_text(ref, data, args \\ [], opts \\ []) do
      {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
      SnakeBridge.Runtime.call_method(ref, :write_text, [data] ++ List.wrap(args), opts)
    end

    @spec _drv(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _drv(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_drv)
    end

    @spec _flavour(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _flavour(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_flavour)
    end

    @spec _hash(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _hash(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_hash)
    end

    @spec _lines(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _lines(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_lines)
    end

    @spec _lines_cached(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _lines_cached(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_lines_cached)
    end

    @spec _parts_normcase(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parts_normcase(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_parts_normcase)
    end

    @spec _parts_normcase_cached(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _parts_normcase_cached(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_parts_normcase_cached)
    end

    @spec _raw_paths(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _raw_paths(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_raw_paths)
    end

    @spec _root(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _root(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_root)
    end

    @spec _str(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _str(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_str)
    end

    @spec _str_normcase(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _str_normcase(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_str_normcase)
    end

    @spec _str_normcase_cached(SnakeBridge.Ref.t()) ::
            {:ok, term()} | {:error, Snakepit.Error.t()}
    def _str_normcase_cached(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_str_normcase_cached)
    end

    @spec _tail(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _tail(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_tail)
    end

    @spec _tail_cached(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def _tail_cached(ref) do
      SnakeBridge.Runtime.get_attr(ref, :_tail_cached)
    end

    @spec anchor(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def anchor(ref) do
      SnakeBridge.Runtime.get_attr(ref, :anchor)
    end

    @spec drive(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def drive(ref) do
      SnakeBridge.Runtime.get_attr(ref, :drive)
    end

    @spec name(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def name(ref) do
      SnakeBridge.Runtime.get_attr(ref, :name)
    end

    @spec parent(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def parent(ref) do
      SnakeBridge.Runtime.get_attr(ref, :parent)
    end

    @spec parents(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def parents(ref) do
      SnakeBridge.Runtime.get_attr(ref, :parents)
    end

    @spec parts(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def parts(ref) do
      SnakeBridge.Runtime.get_attr(ref, :parts)
    end

    @spec root(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def root(ref) do
      SnakeBridge.Runtime.get_attr(ref, :root)
    end

    @spec stem(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def stem(ref) do
      SnakeBridge.Runtime.get_attr(ref, :stem)
    end

    @spec suffix(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def suffix(ref) do
      SnakeBridge.Runtime.get_attr(ref, :suffix)
    end

    @spec suffixes(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
    def suffixes(ref) do
      SnakeBridge.Runtime.get_attr(ref, :suffixes)
    end
  end

  @doc false
  def __functions__ do
    []
  end

  @doc false
  def __classes__ do
    [
      {Pathlib.Path,
       "PurePath subclass that can make system calls.\n\nPath represents a filesystem path but unlike PurePath, also offers\nmethods to do system calls on path objects. Depending on your system,\ninstantiating a Path will return either a PosixPath or a WindowsPath\nobject. You can also instantiate a PosixPath or WindowsPath directly,\nbut cannot instantiate a WindowsPath on a POSIX system or vice versa."}
    ]
  end

  @doc false
  def __search__(query) do
    SnakeBridge.Docs.search(__MODULE__, query)
  end

  @doc false
  def doc(function) do
    SnakeBridge.Docs.get(__MODULE__, function)
  end
end
