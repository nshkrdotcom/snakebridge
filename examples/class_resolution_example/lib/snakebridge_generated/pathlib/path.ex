# Generated by SnakeBridge v0.14.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: pathlib stdlib
# Python module: pathlib
# Python class: Path

defmodule Pathlib.Path do
  @moduledoc """
  PurePath subclass that can make system calls.

  Path represents a filesystem path but unlike PurePath, also offers
  methods to do system calls on path objects. Depending on your system,
  instantiating a Path will return either a PosixPath or a WindowsPath
  object. You can also instantiate a PosixPath or WindowsPath directly,
  but cannot instantiate a WindowsPath on a POSIX system or vice versa.
  """
  def __snakebridge_python_name__, do: "pathlib"
  def __snakebridge_python_class__, do: "Path"
  def __snakebridge_library__, do: "pathlib"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `args` (term())
  - `kwargs` (term())
  """
  @spec new(list(term()), keyword()) :: {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [] ++ List.wrap(args), opts)
  end

  @doc """
  Change the permissions of the path, like os.chmod().

  ## Parameters

  - `mode` (term())
  - `follow_symlinks` (term() keyword-only default: True)

  ## Returns

  - `term()`
  """
  @spec chmod(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def chmod(ref, mode, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :chmod, [mode], opts)
  end

  @doc """
  Return the path as a 'file' URI.

  ## Returns

  - `term()`
  """
  @spec as_uri(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def as_uri(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :as_uri, [], opts)
  end

  @doc """
  Create this file with the given access mode, if it doesn't exist.

  ## Parameters

  - `mode` (term() default: 438)
  - `exist_ok` (term() default: True)

  ## Returns

  - `term()`
  """
  @spec touch(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def touch(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :touch, [] ++ List.wrap(args), opts)
  end

  @doc """
  Open the file in text mode, write to it, and close the file.

  ## Parameters

  - `data` (term())
  - `encoding` (term() default: None)
  - `errors` (term() default: None)
  - `newline` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec write_text(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def write_text(ref, data, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :write_text, [data] ++ List.wrap(args), opts)
  end

  @doc """
  Rename this path to the target path.

  The target path may be absolute or relative. Relative paths are
  interpreted relative to the current working directory, *not* the
  directory of the Path object.

  Returns the new Path instance pointing to the target path.

  ## Parameters

  - `target` (term())

  ## Returns

  - `term()`
  """
  @spec rename(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def rename(ref, target, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :rename, [target], opts)
  end

  @doc """
  Whether this path is a FIFO.

  ## Returns

  - `term()`
  """
  @spec is_fifo(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_fifo(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_fifo, [], opts)
  end

  @doc """
  Like chmod(), except if the path points to a symlink, the symlink's

  permissions are changed, rather than its target's.

  ## Parameters

  - `mode` (term())

  ## Returns

  - `term()`
  """
  @spec lchmod(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def lchmod(ref, mode, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :lchmod, [mode], opts)
  end

  @doc """
  Combine this path with one or several arguments, and return a

  new path representing either a subpath (if all arguments are relative
  paths) or a totally different path (if one of the arguments is
  anchored).

  ## Parameters

  - `pathsegments` (term())

  ## Returns

  - `term()`
  """
  @spec joinpath(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def joinpath(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :joinpath, [] ++ List.wrap(args), opts)
  end

  @doc """
  Make the path absolute, resolving all symlinks on the way and also

  normalizing it.

  ## Parameters

  - `strict` (term() default: False)

  ## Returns

  - `term()`
  """
  @spec resolve(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def resolve(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :resolve, [] ++ List.wrap(args), opts)
  end

  @doc """
  Whether this path is a directory.

  ## Returns

  - `term()`
  """
  @spec is_dir(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_dir(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_dir, [], opts)
  end

  @doc """
  Python method `Path._format_parsed_parts`.

  ## Parameters

  - `drv` (term())
  - `root` (term())
  - `tail` (term())

  ## Returns

  - `term()`
  """
  @spec _format_parsed_parts(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _format_parsed_parts(ref, drv, root, tail, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_format_parsed_parts, [drv, root, tail], opts)
  end

  @doc """
  Open the file in bytes mode, read it, and close the file.

  ## Returns

  - `term()`
  """
  @spec read_bytes(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def read_bytes(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :read_bytes, [], opts)
  end

  @doc """
  Return the group name of the file gid.

  ## Returns

  - `term()`
  """
  @spec group(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def group(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :group, [], opts)
  end

  @doc """
  Python method `Path._make_child_relpath`.

  ## Parameters

  - `name` (term())

  ## Returns

  - `term()`
  """
  @spec _make_child_relpath(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _make_child_relpath(ref, name, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_make_child_relpath, [name], opts)
  end

  @doc """
  Recursively yield all existing files (of any kind, including

  directories) matching the given relative pattern, anywhere in
  this subtree.

  ## Parameters

  - `pattern` (term())
  - `case_sensitive` (term() keyword-only default: None)

  ## Returns

  - `term()`
  """
  @spec rglob(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def rglob(ref, pattern, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :rglob, [pattern], opts)
  end

  @doc """
  Make this path a hard link pointing to the same file as *target*.

  Note the order of arguments (self, target) is the reverse of os.link's.

  ## Parameters

  - `target` (term())

  ## Returns

  - `term()`
  """
  @spec hardlink_to(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def hardlink_to(ref, target, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :hardlink_to, [target], opts)
  end

  @doc """
  Return an absolute version of this path by prepending the current

  working directory. No normalization or symlink resolution is performed.

  Use resolve() to get the canonical path to a file.

  ## Returns

  - `term()`
  """
  @spec absolute(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def absolute(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :absolute, [], opts)
  end

  @doc """
  Return the relative path to another path identified by the passed

  arguments.  If the operation is not possible (because this is not
  related to the other path), raise ValueError.

  The *walk_up* parameter controls whether `..` may be used to resolve
  the path.

  ## Parameters

  - `other` (term())
  - `deprecated` (term())
  - `walk_up` (term() keyword-only default: False)

  ## Returns

  - `term()`
  """
  @spec relative_to(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def relative_to(ref, other, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :relative_to, [other] ++ List.wrap(args), opts)
  end

  @doc """
  Return the path to which the symbolic link points.

  ## Returns

  - `term()`
  """
  @spec readlink(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def readlink(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :readlink, [], opts)
  end

  @doc """
  Check if this path is a mount point

  ## Returns

  - `term()`
  """
  @spec is_mount(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_mount(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_mount, [], opts)
  end

  @doc """
  Whether this path is a junction.

  ## Returns

  - `term()`
  """
  @spec is_junction(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_junction(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_junction, [], opts)
  end

  @doc """
  Return whether other_path is the same or not as this file

  (as returned by os.path.samefile()).

  ## Parameters

  - `other_path` (term())

  ## Returns

  - `term()`
  """
  @spec samefile(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def samefile(ref, other_path, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :samefile, [other_path], opts)
  end

  @doc """
  Make this path a symlink pointing to the target path.

  Note the order of arguments (link, target) is the reverse of os.symlink.

  ## Parameters

  - `target` (term())
  - `target_is_directory` (term() default: False)

  ## Returns

  - `term()`
  """
  @spec symlink_to(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def symlink_to(ref, target, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :symlink_to, [target] ++ List.wrap(args), opts)
  end

  @doc """
  Return the string representation of the path with forward (/)

  slashes.

  ## Returns

  - `term()`
  """
  @spec as_posix(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def as_posix(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :as_posix, [], opts)
  end

  @doc """
  Walk the directory tree from this directory, similar to os.walk().

  ## Parameters

  - `top_down` (term() default: True)
  - `on_error` (term() default: None)
  - `follow_symlinks` (term() default: False)

  ## Returns

  - `term()`
  """
  @spec walk(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def walk(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :walk, [] ++ List.wrap(args), opts)
  end

  @doc """
  Return True if this path matches the given pattern.

  ## Parameters

  - `path_pattern` (term())
  - `case_sensitive` (term() keyword-only default: None)

  ## Returns

  - `term()`
  """
  @spec match(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def match(ref, path_pattern, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :match, [path_pattern], opts)
  end

  @doc """
  Return the login name of the file owner.

  ## Returns

  - `term()`
  """
  @spec owner(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def owner(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :owner, [], opts)
  end

  @doc """
  Whether this path is a regular file (also True for symlinks pointing

  to regular files).

  ## Returns

  - `term()`
  """
  @spec is_file(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_file(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_file, [], opts)
  end

  @doc """
  Open the file in bytes mode, write to it, and close the file.

  ## Parameters

  - `data` (term())

  ## Returns

  - `term()`
  """
  @spec write_bytes(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def write_bytes(ref, data, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :write_bytes, [data], opts)
  end

  @doc """
  Remove this file or link.

  If the path is a directory, use rmdir() instead.

  ## Parameters

  - `missing_ok` (term() default: False)

  ## Returns

  - `term()`
  """
  @spec unlink(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def unlink(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :unlink, [] ++ List.wrap(args), opts)
  end

  @doc """
  Yield path objects of the directory contents.

  The children are yielded in arbitrary order, and the
  special entries '.' and '..' are not included.

  ## Returns

  - `term()`
  """
  @spec iterdir(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def iterdir(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :iterdir, [], opts)
  end

  @doc """
  Open the file pointed by this path and return a file object, as

  the built-in open() function does.

  ## Parameters

  - `mode` (term() default: 'r')
  - `buffering` (term() default: -1)
  - `encoding` (term() default: None)
  - `errors` (term() default: None)
  - `newline` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec open(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def open(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :open, [] ++ List.wrap(args), opts)
  end

  @doc """
  Return True if the path contains one of the special names reserved

  by the system, if any.

  ## Returns

  - `term()`
  """
  @spec is_reserved(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_reserved(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_reserved, [], opts)
  end

  @doc """
  Return a new path pointing to the user's home directory (as

  returned by os.path.expanduser('~')).

  ## Returns

  - `term()`
  """
  @spec home(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def home(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :home, [], opts)
  end

  @doc """
  Return a new path with the file suffix changed.  If the path

  has no suffix, add given suffix.  If the given suffix is an empty
  string, remove the suffix from the path.

  ## Parameters

  - `suffix` (term())

  ## Returns

  - `term()`
  """
  @spec with_suffix(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def with_suffix(ref, suffix, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :with_suffix, [suffix], opts)
  end

  @doc """
  True if the path is absolute (has both a root and, if applicable,

  a drive).

  ## Returns

  - `term()`
  """
  @spec is_absolute(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_absolute(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_absolute, [], opts)
  end

  @doc """
  Return True if the path is relative to another path or False.

  ## Parameters

  - `other` (term())
  - `deprecated` (term())

  ## Returns

  - `term()`
  """
  @spec is_relative_to(SnakeBridge.Ref.t(), term(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_relative_to(ref, other, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :is_relative_to, [other] ++ List.wrap(args), opts)
  end

  @doc """
  Return a new path with the stem changed.

  ## Parameters

  - `stem` (term())

  ## Returns

  - `term()`
  """
  @spec with_stem(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def with_stem(ref, stem, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :with_stem, [stem], opts)
  end

  @doc """
  Python method `Path._parse_path`.

  ## Parameters

  - `path` (term())

  ## Returns

  - `term()`
  """
  @spec _parse_path(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _parse_path(ref, path, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_parse_path, [path], opts)
  end

  @doc """
  Construct a new path object from any number of path-like objects.

  Subclasses may override this method to customize how new path objects
  are created from methods like `iterdir()`.

  ## Parameters

  - `pathsegments` (term())

  ## Returns

  - `term()`
  """
  @spec with_segments(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def with_segments(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :with_segments, [] ++ List.wrap(args), opts)
  end

  @doc """
  Rename this path to the target path, overwriting if that path exists.

  The target path may be absolute or relative. Relative paths are
  interpreted relative to the current working directory, *not* the
  directory of the Path object.

  Returns the new Path instance pointing to the target path.

  ## Parameters

  - `target` (term())

  ## Returns

  - `term()`
  """
  @spec replace(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def replace(ref, target, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :replace, [target], opts)
  end

  @doc """
  Like stat(), except if the path points to a symlink, the symlink's

  status information is returned, rather than its target's.

  ## Returns

  - `term()`
  """
  @spec lstat(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def lstat(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :lstat, [], opts)
  end

  @doc """
  Return the result of the stat() system call on this path, like

  os.stat() does.

  ## Parameters

  - `follow_symlinks` (term() keyword-only default: True)

  ## Returns

  - `term()`
  """
  @spec stat(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def stat(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :stat, [], opts)
  end

  @doc """
  Whether this path exists.

  This method normally follows symlinks; to check whether a symlink exists,
  add the argument follow_symlinks=False.

  ## Parameters

  - `follow_symlinks` (term() keyword-only default: True)

  ## Returns

  - `term()`
  """
  @spec exists(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def exists(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :exists, [], opts)
  end

  @doc """
  Return a new path with expanded ~ and ~user constructs

  (as returned by os.path.expanduser)

  ## Returns

  - `term()`
  """
  @spec expanduser(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def expanduser(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :expanduser, [], opts)
  end

  @doc """
  Whether this path is a symbolic link.

  ## Returns

  - `term()`
  """
  @spec is_symlink(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_symlink(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_symlink, [], opts)
  end

  @doc """
  Python method `Path._scandir`.

  ## Returns

  - `term()`
  """
  @spec _scandir(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _scandir(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_scandir, [], opts)
  end

  @doc """
  Return a new path with the file name changed.

  ## Parameters

  - `name` (term())

  ## Returns

  - `term()`
  """
  @spec with_name(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def with_name(ref, name, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :with_name, [name], opts)
  end

  @doc """
  Whether this path is a character device.

  ## Returns

  - `term()`
  """
  @spec is_char_device(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_char_device(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_char_device, [], opts)
  end

  @doc """
  Open the file in text mode, read it, and close the file.

  ## Parameters

  - `encoding` (term() default: None)
  - `errors` (term() default: None)

  ## Returns

  - `term()`
  """
  @spec read_text(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def read_text(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :read_text, [] ++ List.wrap(args), opts)
  end

  @doc """
  Remove this directory.  The directory must be empty.

  ## Returns

  - `term()`
  """
  @spec rmdir(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def rmdir(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :rmdir, [], opts)
  end

  @doc """
  Iterate over this subtree and yield all existing files (of any

  kind, including directories) matching the given relative pattern.

  ## Parameters

  - `pattern` (term())
  - `case_sensitive` (term() keyword-only default: None)

  ## Returns

  - `term()`
  """
  @spec glob(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def glob(ref, pattern, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :glob, [pattern], opts)
  end

  @doc """
  Whether this path is a block device.

  ## Returns

  - `term()`
  """
  @spec is_block_device(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_block_device(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_block_device, [], opts)
  end

  @doc """
  Python method `Path._from_parsed_parts`.

  ## Parameters

  - `drv` (term())
  - `root` (term())
  - `tail` (term())

  ## Returns

  - `term()`
  """
  @spec _from_parsed_parts(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _from_parsed_parts(ref, drv, root, tail, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_from_parsed_parts, [drv, root, tail], opts)
  end

  @doc """
  Return a new path pointing to the current working directory.

  ## Returns

  - `term()`
  """
  @spec cwd(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def cwd(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :cwd, [], opts)
  end

  @doc """
  Create a new directory at this given path.

  ## Parameters

  - `mode` (term() default: 511)
  - `parents` (term() default: False)
  - `exist_ok` (term() default: False)

  ## Returns

  - `term()`
  """
  @spec mkdir(SnakeBridge.Ref.t(), list(term()), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def mkdir(ref, args, opts \\ []) do
    {args, opts} = SnakeBridge.Runtime.normalize_args_opts(args, opts)
    SnakeBridge.Runtime.call_method(ref, :mkdir, [] ++ List.wrap(args), opts)
  end

  @doc """
  Whether this path is a socket.

  ## Returns

  - `term()`
  """
  @spec is_socket(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def is_socket(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :is_socket, [], opts)
  end

  @doc """
  Python method `Path._load_parts`.

  ## Returns

  - `term()`
  """
  @spec _load_parts(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _load_parts(ref, opts \\ []) do
    SnakeBridge.Runtime.call_method(ref, :_load_parts, [], opts)
  end

  @spec _drv(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _drv(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_drv)
  end

  @spec _flavour(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _flavour(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_flavour)
  end

  @spec _hash(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _hash(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_hash)
  end

  @spec _lines(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _lines(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_lines)
  end

  @spec _lines_cached(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _lines_cached(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_lines_cached)
  end

  @spec _parts_normcase(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _parts_normcase(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_parts_normcase)
  end

  @spec _parts_normcase_cached(SnakeBridge.Ref.t()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def _parts_normcase_cached(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_parts_normcase_cached)
  end

  @spec _raw_paths(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _raw_paths(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_raw_paths)
  end

  @spec _root(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _root(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_root)
  end

  @spec _str(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _str(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_str)
  end

  @spec _str_normcase(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _str_normcase(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_str_normcase)
  end

  @spec _str_normcase_cached(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _str_normcase_cached(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_str_normcase_cached)
  end

  @spec _tail(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _tail(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_tail)
  end

  @spec _tail_cached(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def _tail_cached(ref) do
    SnakeBridge.Runtime.get_attr(ref, :_tail_cached)
  end

  @spec anchor(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def anchor(ref) do
    SnakeBridge.Runtime.get_attr(ref, :anchor)
  end

  @spec drive(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def drive(ref) do
    SnakeBridge.Runtime.get_attr(ref, :drive)
  end

  @spec name(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def name(ref) do
    SnakeBridge.Runtime.get_attr(ref, :name)
  end

  @spec parent(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def parent(ref) do
    SnakeBridge.Runtime.get_attr(ref, :parent)
  end

  @spec parents(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def parents(ref) do
    SnakeBridge.Runtime.get_attr(ref, :parents)
  end

  @spec parts(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def parts(ref) do
    SnakeBridge.Runtime.get_attr(ref, :parts)
  end

  @spec root(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def root(ref) do
    SnakeBridge.Runtime.get_attr(ref, :root)
  end

  @spec stem(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def stem(ref) do
    SnakeBridge.Runtime.get_attr(ref, :stem)
  end

  @spec suffix(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def suffix(ref) do
    SnakeBridge.Runtime.get_attr(ref, :suffix)
  end

  @spec suffixes(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def suffixes(ref) do
    SnakeBridge.Runtime.get_attr(ref, :suffixes)
  end
end
