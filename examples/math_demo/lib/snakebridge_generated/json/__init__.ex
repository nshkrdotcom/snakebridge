# Generated by SnakeBridge v0.12.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: json stdlib
# Python module: json

defmodule Json do
  @moduledoc """
  SnakeBridge bindings for `json`.

  ## Runtime Options

  All functions accept a `__runtime__` option for controlling execution behavior:

      Elixir.Json.some_function(args, __runtime__: [timeout: 120_000])

  ### Supported runtime options

  - `:timeout` - Call timeout in milliseconds (default: 120,000ms / 2 minutes)
  - `:timeout_profile` - Use a named profile (`:default`, `:ml_inference`, `:batch_job`, `:streaming`)
  - `:stream_timeout` - Timeout for streaming operations (default: 1,800,000ms / 30 minutes)
  - `:session_id` - Override the session ID for this call
  - `:pool_name` - Target a specific Snakepit pool (multi-pool setups)
  - `:affinity` - Override session affinity (`:hint`, `:strict_queue`, `:strict_fail_fast`)

  ### Timeout Profiles

  - `:default` - 2 minute timeout for regular calls
  - `:ml_inference` - 10 minute timeout for ML/LLM workloads
  - `:batch_job` - Unlimited timeout for long-running jobs
  - `:streaming` - 2 minute timeout, 30 minute stream_timeout

  ### Example with timeout override

      # For a long-running ML inference call
      Elixir.Json.predict(data, __runtime__: [timeout_profile: :ml_inference])

      # Or explicit timeout
      Elixir.Json.predict(data, __runtime__: [timeout: 600_000])

      # Route to a pool and enforce strict affinity
      Elixir.Json.predict(data, __runtime__: [pool_name: :strict_pool, affinity: :strict_queue])

  See `SnakeBridge.Defaults` for global timeout configuration.
  """

  def __snakebridge_python_name__, do: "json"
  def __snakebridge_library__, do: "json"

  @doc """
  Serialize ``obj`` as a JSON formatted stream to ``fp`` (a

  ``.write()``-supporting file-like object).

  If ``skipkeys`` is true then ``dict`` keys that are not basic types
  (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped
  instead of raising a ``TypeError``.

  If ``ensure_ascii`` is false, then the strings written to ``fp`` can
  contain non-ASCII characters if they appear in strings contained in
  ``obj``. Otherwise, all such characters are escaped in JSON strings.

  If ``check_circular`` is false, then the circular reference check
  for container types will be skipped and a circular reference will
  result in an ``RecursionError`` (or worse).

  If ``allow_nan`` is false, then it will be a ``ValueError`` to
  serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``)
  in strict compliance of the JSON specification, instead of using the
  JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).

  If ``indent`` is a non-negative integer, then JSON array elements and
  object members will be pretty-printed with that indent level. An indent
  level of 0 will only insert newlines. ``None`` is the most compact
  representation.

  If specified, ``separators`` should be an ``(item_separator, key_separator)``
  tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and
  ``(',', ': ')`` otherwise.  To get the most compact JSON representation,
  you should specify ``(',', ':')`` to eliminate whitespace.

  ``default(obj)`` is a function that should return a serializable version
  of obj or raise TypeError. The default simply raises TypeError.

  If *sort_keys* is true (default: ``False``), then the output of
  dictionaries will be sorted by key.

  To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the
  ``.default()`` method to serialize additional types), specify it with
  the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.

  Parameters:
  - `obj` (term())
  - `fp` (term())
  - `skipkeys` (term() keyword-only default: False)
  - `ensure_ascii` (term() keyword-only default: True)
  - `check_circular` (term() keyword-only default: True)
  - `allow_nan` (term() keyword-only default: True)
  - `cls` (term() keyword-only default: None)
  - `indent` (term() keyword-only default: None)
  - `separators` (term() keyword-only default: None)
  - `default` (term() keyword-only default: None)
  - `sort_keys` (term() keyword-only default: False)
  - `kw` (term())

  Returns:
  - `term()`
  """
  @spec dump(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def dump(obj, fp, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :dump, [obj, fp], opts)
  end

  @doc """
  Serialize ``obj`` to a JSON formatted ``str``.

  If ``skipkeys`` is true then ``dict`` keys that are not basic types
  (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped
  instead of raising a ``TypeError``.

  If ``ensure_ascii`` is false, then the return value can contain non-ASCII
  characters if they appear in strings contained in ``obj``. Otherwise, all
  such characters are escaped in JSON strings.

  If ``check_circular`` is false, then the circular reference check
  for container types will be skipped and a circular reference will
  result in an ``RecursionError`` (or worse).

  If ``allow_nan`` is false, then it will be a ``ValueError`` to
  serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in
  strict compliance of the JSON specification, instead of using the
  JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).

  If ``indent`` is a non-negative integer, then JSON array elements and
  object members will be pretty-printed with that indent level. An indent
  level of 0 will only insert newlines. ``None`` is the most compact
  representation.

  If specified, ``separators`` should be an ``(item_separator, key_separator)``
  tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and
  ``(',', ': ')`` otherwise.  To get the most compact JSON representation,
  you should specify ``(',', ':')`` to eliminate whitespace.

  ``default(obj)`` is a function that should return a serializable version
  of obj or raise TypeError. The default simply raises TypeError.

  If *sort_keys* is true (default: ``False``), then the output of
  dictionaries will be sorted by key.

  To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the
  ``.default()`` method to serialize additional types), specify it with
  the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.

  Parameters:
  - `obj` (term())
  - `skipkeys` (term() keyword-only default: False)
  - `ensure_ascii` (term() keyword-only default: True)
  - `check_circular` (term() keyword-only default: True)
  - `allow_nan` (term() keyword-only default: True)
  - `cls` (term() keyword-only default: None)
  - `indent` (term() keyword-only default: None)
  - `separators` (term() keyword-only default: None)
  - `default` (term() keyword-only default: None)
  - `sort_keys` (term() keyword-only default: False)
  - `kw` (term())

  Returns:
  - `term()`
  """
  @spec dumps(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def dumps(obj, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :dumps, [obj], opts)
  end

  @doc """
  Deserialize ``fp`` (a ``.read()``-supporting file-like object containing

  a JSON document) to a Python object.

  ``object_hook`` is an optional function that will be called with the
  result of any object literal decode (a ``dict``). The return value of
  ``object_hook`` will be used instead of the ``dict``. This feature
  can be used to implement custom decoders (e.g. JSON-RPC class hinting).

  ``object_pairs_hook`` is an optional function that will be called with the
  result of any object literal decoded with an ordered list of pairs.  The
  return value of ``object_pairs_hook`` will be used instead of the ``dict``.
  This feature can be used to implement custom decoders.  If ``object_hook``
  is also defined, the ``object_pairs_hook`` takes priority.

  To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``
  kwarg; otherwise ``JSONDecoder`` is used.

  Parameters:
  - `fp` (term())
  - `cls` (term() keyword-only default: None)
  - `object_hook` (term() keyword-only default: None)
  - `parse_float` (term() keyword-only default: None)
  - `parse_int` (term() keyword-only default: None)
  - `parse_constant` (term() keyword-only default: None)
  - `object_pairs_hook` (term() keyword-only default: None)
  - `kw` (term())

  Returns:
  - `term()`
  """
  @spec load(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def load(fp, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :load, [fp], opts)
  end

  @doc """
  Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance

  containing a JSON document) to a Python object.

  ``object_hook`` is an optional function that will be called with the
  result of any object literal decode (a ``dict``). The return value of
  ``object_hook`` will be used instead of the ``dict``. This feature
  can be used to implement custom decoders (e.g. JSON-RPC class hinting).

  ``object_pairs_hook`` is an optional function that will be called with the
  result of any object literal decoded with an ordered list of pairs.  The
  return value of ``object_pairs_hook`` will be used instead of the ``dict``.
  This feature can be used to implement custom decoders.  If ``object_hook``
  is also defined, the ``object_pairs_hook`` takes priority.

  ``parse_float``, if specified, will be called with the string
  of every JSON float to be decoded. By default this is equivalent to
  float(num_str). This can be used to use another datatype or parser
  for JSON floats (e.g. decimal.Decimal).

  ``parse_int``, if specified, will be called with the string
  of every JSON int to be decoded. By default this is equivalent to
  int(num_str). This can be used to use another datatype or parser
  for JSON integers (e.g. float).

  ``parse_constant``, if specified, will be called with one of the
  following strings: -Infinity, Infinity, NaN.
  This can be used to raise an exception if invalid JSON numbers
  are encountered.

  To use a custom ``JSONDecoder`` subclass, specify it with the ``cls``
  kwarg; otherwise ``JSONDecoder`` is used.

  Parameters:
  - `s` (term())
  - `cls` (term() keyword-only default: None)
  - `object_hook` (term() keyword-only default: None)
  - `parse_float` (term() keyword-only default: None)
  - `parse_int` (term() keyword-only default: None)
  - `parse_constant` (term() keyword-only default: None)
  - `object_pairs_hook` (term() keyword-only default: None)
  - `kw` (term())

  Returns:
  - `term()`
  """
  @spec loads(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def loads(s, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :loads, [s], opts)
  end

  @doc false
  def __functions__ do
    [
      {:py_encode_basestring, 1, __MODULE__, "Return a JSON representation of a Python string"},
      {:py_encode_basestring_ascii, 1, __MODULE__,
       "Return an ASCII-only JSON representation of a Python string"},
      {:main, 0, __MODULE__, "Command-line tool to validate and pretty-print JSON"},
      {:dump, 2, __MODULE__, "Serialize ``obj`` as a JSON formatted stream to ``fp`` (a"},
      {:dumps, 1, __MODULE__, "Serialize ``obj`` to a JSON formatted ``str``."},
      {:load, 1, __MODULE__,
       "Deserialize ``fp`` (a ``.read()``-supporting file-like object containing"},
      {:loads, 1, __MODULE__, "Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance"}
    ]
  end

  @doc false
  def __classes__ do
    [
      {Json.Decoder.JSONDecodeError,
       "Subclass of ValueError with the following additional properties:\n\nmsg: The unformatted error message\ndoc: The JSON document being parsed\npos: The start index of doc where parsing failed\nlineno: The line corresponding to pos\ncolno: The column corresponding to pos"},
      {Json.Decoder.JSONDecoder,
       "Simple JSON <https://json.org> decoder\n\nPerforms the following translations in decoding by default:\n\n+---------------+-------------------+\n| JSON          | Python            |\n+===============+===================+\n| object        | dict              |\n+---------------+-------------------+\n| array         | list              |\n+---------------+-------------------+\n| string        | str               |\n+---------------+-------------------+\n| number (int)  | int               |\n+---------------+-------------------+\n| number (real) | float             |\n+---------------+-------------------+\n| true          | True              |\n+---------------+-------------------+\n| false         | False             |\n+---------------+-------------------+\n| null          | None              |\n+---------------+-------------------+\n\nIt also understands ``NaN``, ``Infinity``, and ``-Infinity`` as\ntheir corresponding ``float`` values, which is outside the JSON spec."},
      {Json.Encoder.JSONEncoder,
       "Extensible JSON <https://json.org> encoder for Python data structures.\n\nSupports the following objects and types by default:\n\n+-------------------+---------------+\n| Python            | JSON          |\n+===================+===============+\n| dict              | object        |\n+-------------------+---------------+\n| list, tuple       | array         |\n+-------------------+---------------+\n| str               | string        |\n+-------------------+---------------+\n| int, float        | number        |\n+-------------------+---------------+\n| True              | true          |\n+-------------------+---------------+\n| False             | false         |\n+-------------------+---------------+\n| None              | null          |\n+-------------------+---------------+\n\nTo extend this to recognize other objects, subclass and implement a\n``.default()`` method with another method that returns a serializable\nobject for ``o`` if possible, otherwise it should call the superclass\nimplementation (to raise ``TypeError``)."},
      {Json.JSONDecodeError,
       "Subclass of ValueError with the following additional properties:\n\nmsg: The unformatted error message\ndoc: The JSON document being parsed\npos: The start index of doc where parsing failed\nlineno: The line corresponding to pos\ncolno: The column corresponding to pos"},
      {Json.JSONDecoder,
       "Simple JSON <https://json.org> decoder\n\nPerforms the following translations in decoding by default:\n\n+---------------+-------------------+\n| JSON          | Python            |\n+===============+===================+\n| object        | dict              |\n+---------------+-------------------+\n| array         | list              |\n+---------------+-------------------+\n| string        | str               |\n+---------------+-------------------+\n| number (int)  | int               |\n+---------------+-------------------+\n| number (real) | float             |\n+---------------+-------------------+\n| true          | True              |\n+---------------+-------------------+\n| false         | False             |\n+---------------+-------------------+\n| null          | None              |\n+---------------+-------------------+\n\nIt also understands ``NaN``, ``Infinity``, and ``-Infinity`` as\ntheir corresponding ``float`` values, which is outside the JSON spec."},
      {Json.JSONEncoder,
       "Extensible JSON <https://json.org> encoder for Python data structures.\n\nSupports the following objects and types by default:\n\n+-------------------+---------------+\n| Python            | JSON          |\n+===================+===============+\n| dict              | object        |\n+-------------------+---------------+\n| list, tuple       | array         |\n+-------------------+---------------+\n| str               | string        |\n+-------------------+---------------+\n| int, float        | number        |\n+-------------------+---------------+\n| True              | true          |\n+-------------------+---------------+\n| False             | false         |\n+-------------------+---------------+\n| None              | null          |\n+-------------------+---------------+\n\nTo extend this to recognize other objects, subclass and implement a\n``.default()`` method with another method that returns a serializable\nobject for ``o`` if possible, otherwise it should call the superclass\nimplementation (to raise ``TypeError``)."},
      {Json.Scanner.MakeScanner, "JSON scanner object"}
    ]
  end

  @doc false
  def __search__(query) do
    SnakeBridge.Docs.search(__MODULE__, query)
  end

  @doc false
  def doc(function) do
    SnakeBridge.Docs.get(__MODULE__, function)
  end
end
