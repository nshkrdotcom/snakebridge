# Generated by SnakeBridge v0.14.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: json stdlib
# Python module: json.decoder
# Python class: JSONDecodeError

defmodule Json.Decoder.JSONDecodeError do
  @moduledoc """
  Subclass of ValueError with the following additional properties:

  msg: The unformatted error message
  doc: The JSON document being parsed
  pos: The start index of doc where parsing failed
  lineno: The line corresponding to pos
  colno: The column corresponding to pos
  """
  def __snakebridge_python_name__, do: "json.decoder"
  def __snakebridge_python_class__, do: "JSONDecodeError"
  def __snakebridge_library__, do: "json"
  @opaque t :: SnakeBridge.Ref.t()

  @doc """
  Initialize self.  See help(type(self)) for accurate signature.

  ## Parameters

  - `msg` (term())
  - `doc` (term())
  - `pos` (term())
  """
  @spec new(term(), term(), term(), keyword()) ::
          {:ok, SnakeBridge.Ref.t()} | {:error, Snakepit.Error.t()}
  def new(msg, doc, pos, opts \\ []) do
    SnakeBridge.Runtime.call_class(__MODULE__, :__init__, [msg, doc, pos], opts)
  end

  @doc """
  Exception.add_note(note) --

  add a note to the exception

  ## Returns

  - `term()`
  """
  @spec add_note(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec add_note(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def add_note(ref) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [], [])
  end

  def add_note(ref, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [], opts)
  end

  def add_note(ref, arg1) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1], [])
  end

  def add_note(ref, arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1], opts)
  end

  def add_note(ref, arg1, arg2) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2], [])
  end

  def add_note(ref, arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2], opts)
  end

  def add_note(ref, arg1, arg2, arg3) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3], [])
  end

  def add_note(ref, arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3], opts)
  end

  def add_note(ref, arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4], [])
  end

  def add_note(ref, arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4], opts)
  end

  def add_note(ref, arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def add_note(ref, arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5, arg6], [])
  end

  def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :add_note, [arg1, arg2, arg3, arg4, arg5, arg6], opts)
  end

  def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call_method(
      ref,
      :add_note,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      []
    )
  end

  def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :add_note,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      opts
    )
  end

  def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call_method(
      ref,
      :add_note,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def add_note(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :add_note,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @doc """
  Exception.with_traceback(tb) --

  set self.__traceback__ to tb and return self.

  ## Returns

  - `term()`
  """
  @spec with_traceback(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(SnakeBridge.Ref.t(), term(), term(), term(), term(), term(), term()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec with_traceback(
          SnakeBridge.Ref.t(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          term(),
          keyword()
        ) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def with_traceback(ref) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [], [])
  end

  def with_traceback(ref, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [], opts)
  end

  def with_traceback(ref, arg1) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1], [])
  end

  def with_traceback(ref, arg1, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1], opts)
  end

  def with_traceback(ref, arg1, arg2) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2], [])
  end

  def with_traceback(ref, arg1, arg2, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2], opts)
  end

  def with_traceback(ref, arg1, arg2, arg3) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3], [])
  end

  def with_traceback(ref, arg1, arg2, arg3, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3], opts)
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4], [])
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4], opts)
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, arg5) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4, arg5], [])
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(ref, :with_traceback, [arg1, arg2, arg3, arg4, arg5], opts)
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6) do
    SnakeBridge.Runtime.call_method(
      ref,
      :with_traceback,
      [arg1, arg2, arg3, arg4, arg5, arg6],
      []
    )
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :with_traceback,
      [arg1, arg2, arg3, arg4, arg5, arg6],
      opts
    )
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7) do
    SnakeBridge.Runtime.call_method(
      ref,
      :with_traceback,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      []
    )
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :with_traceback,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7],
      opts
    )
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) do
    SnakeBridge.Runtime.call_method(
      ref,
      :with_traceback,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      []
    )
  end

  def with_traceback(ref, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call_method(
      ref,
      :with_traceback,
      [arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8],
      opts
    )
  end

  @spec args(SnakeBridge.Ref.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def args(ref) do
    SnakeBridge.Runtime.get_attr(ref, :args)
  end
end
