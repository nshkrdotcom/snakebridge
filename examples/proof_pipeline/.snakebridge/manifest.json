{
  "classes": {
    "PyLatexEnc.Latexwalker.LatexWalker": {
      "attributes": [],
      "class": "LatexWalker",
      "docstring": "Walk a LaTeX string and parse nodes.",
      "methods": [
        {
          "docstring": "",
          "name": "__init__",
          "parameters": [
            {
              "kind": "POSITIONAL_OR_KEYWORD",
              "name": "latex"
            }
          ]
        },
        {
          "docstring": "Parse the LaTeX string into nodes.",
          "name": "get_latex_nodes",
          "parameters": []
        }
      ],
      "module": "PyLatexEnc.Latexwalker.LatexWalker",
      "python_module": "pylatexenc.latexwalker"
    }
  },
  "modules": {
    "math_verify": {
      "doc_missing_reason": "docstring missing",
      "doc_source": "empty",
      "docstring": "",
      "python_module": "math_verify"
    },
    "pylatexenc": {
      "doc_missing_reason": null,
      "doc_source": "runtime",
      "docstring": "Utilities for LaTeX to/from Unicode Text conversion.\n\nMain Site:\n\n    https://github.com/phfaist/pylatexenc/",
      "module_version": "2.10",
      "python_module": "pylatexenc"
    },
    "pylatexenc.latexencode": {
      "doc_missing_reason": null,
      "doc_source": "runtime",
      "docstring": "The `latexencode` module provides a set of routines that allows you to\nconvert a unicode string to LaTeX escape sequences.\n\nFor basic usage you can use the :py:func:`unicode_to_latex()` function\ndirectly::\n\n  >>> from pylatexenc.latexencode import unicode_to_latex\n  >>> print(unicode_to_latex('À votre santé'))\n  \\`A votre sant\\'e\n  >>> print(unicode_to_latex('The length of samples #3 & #4 is 3μm'))\n  The length of samples \\#3 \\& \\#4 is 3\\ensuremath{\\mu}m\n\nThe conversion is handled by the class :py:class:`UnicodeToLatexEncoder`.  If\nyou are converting multiple strings, you may create an instance with the flags\nyou like and invoke its method\n:py:meth:`~UnicodeToLatexEncoder.unicode_to_latex()` as many times as necessary::\n\n  >>> from pylatexenc.latexencode import UnicodeToLatexEncoder\n  >>> u = UnicodeToLatexEncoder(unknown_char_policy='replace')\n  >>> print(u.unicode_to_latex('À votre santé'))\n  \\`A votre sant\\'e\n  >>> print(u.unicode_to_latex('The length of samples #3 & #4 is 3μm'))\n  The length of samples \\#3 \\& \\#4 is 3\\ensuremath{\\mu}m\n  >>> print(u.unicode_to_latex('À votre santé: 乾杯'))\n  No known latex representation for character: U+4E7E - ‘乾’\n  No known latex representation for character: U+676F - ‘杯’\n  \\`A votre sant\\'e: {\\bfseries ?}{\\bfseries ?}\n\nExample using custom conversion rules::\n\n  >>> from pylatexenc.latexencode import UnicodeToLatexEncoder, \\\n  ...     UnicodeToLatexConversionRule, RULE_REGEX\n  >>> u = UnicodeToLatexEncoder(\n  ...     conversion_rules=[\n  ...         UnicodeToLatexConversionRule(rule_type=RULE_REGEX, rule=[\n  ...             (re.compile(r'-->'), r'\\\\textrightarrow'),\n  ...             (re.compile(r'<--'), r'\\\\textleftarrow'),\n  ...         ]),\n  ...         'defaults'\n  ...     ]\n  ... )\n  >>> print(u.unicode_to_latex(\"Cheers --> À votre santé\"))\n  Cheers {\\textrightarrow} \\`A votre sant\\'e\n\nSee :py:class:`UnicodeToLatexEncoder` and\n:py:class:`UnicodeToLatexConversionRule`.  Note for regex rules, the replacement\ntext is expanded like the second argument of `re.sub()` and backslashes need to\nbe escaped even inside raw strings.\n\n.. versionadded:: 2.0\n\n   The class :py:class:`UnicodeToLatexEncoder` along with its helper functions\n   and classes were introduced in `pylatexenc 2.0`.\n\n   The earlier function :py:func:`utf8tolatex()` that was available in\n   `pylatexenc 1.x` is still provided unchanged, so code written for `pylatexenc\n   1.x` should work without changes.  New code is however strongly encouraged to\n   employ the new API.",
      "python_module": "pylatexenc.latexencode"
    },
    "pylatexenc.latexwalker": {
      "doc_missing_reason": null,
      "doc_source": "runtime",
      "docstring": "The ``latexwalker`` module provides a simple API for parsing LaTeX snippets,\nand representing the contents using a data structure based on node classes.\n\nLatexWalker will understand the syntax of most common macros.  However,\n``latexwalker`` is NOT a replacement for a full LaTeX engine.  (Originally,\n``latexwalker`` was designed to extract useful text for indexing for text\ndatabase searches of LaTeX content.)\n\nSimple example usage::\n\n    >>> from pylatexenc.latexwalker import LatexWalker, LatexEnvironmentNode\n    >>> w = LatexWalker(r\"\"\"\n    ... \\textbf{Hi there!} Here is \\emph{a list}:\n    ... \\begin{enumerate}[label=(i)]\n    ... \\item One\n    ... \\item Two\n    ... \\end{enumerate}\n    ... and $x$ is a variable.\n    ... \"\"\")\n    >>> (nodelist, pos, len_) = w.get_latex_nodes(pos=0)\n    >>> nodelist[0]\n    LatexCharsNode(pos=0, len=1, chars='\\n')\n    >>> nodelist[1]\n    LatexMacroNode(pos=1, len=18, macroname='textbf',\n    nodeargd=ParsedMacroArgs(argnlist=[LatexGroupNode(pos=8, len=11,\n    nodelist=[LatexCharsNode(pos=9, len=9, chars='Hi there!')],\n    delimiters=('{', '}'))], argspec='{'), macro_post_space='')\n    >>> nodelist[5].isNodeType(LatexEnvironmentNode)\n    True\n    >>> nodelist[5].environmentname\n    'enumerate'\n    >>> nodelist[5].nodeargd.argspec\n    '['\n    >>> nodelist[5].nodeargd.argnlist\n    [LatexGroupNode(pos=60, len=11, nodelist=[LatexCharsNode(pos=61, len=9,\n    chars='label=(i)')], delimiters=('[', ']'))]\n    >>> nodelist[7].latex_verbatim()\n    '$x$'\n\nYou can also use `latexwalker` directly in command-line, producing JSON or a\nhuman-readable node tree::\n\n    $ echo '\\textit{italic} text' | latexwalker --output-format=json\n    {\n      \"nodelist\": [\n        {\n          \"nodetype\": \"LatexMacroNode\",\n          \"pos\": 0,\n          \"len\": 15,\n          \"macroname\": \"textit\",\n    [...]\n\n    $ latexwalker --help\n    [...]\n\nThe parser can be influenced by specifying a collection of known macros and\nenvironments (the \"latex context\") that are specified using\n:py:class:`pylatexenc.macrospec.MacroSpec` and\n:py:class:`pylatexenc.macrospec.EnvironmentSpec` objects in a\n:py:class:`pylatexenc.macrospec.LatexContextDb` object.  See the doc of the\nmodule :py:mod:`pylatexenc.macrospec` for more information.",
      "python_module": "pylatexenc.latexwalker"
    },
    "sympy": {
      "doc_missing_reason": null,
      "doc_source": "runtime",
      "docstring": "SymPy is a Python library for symbolic mathematics. It aims to become a\nfull-featured computer algebra system (CAS) while keeping the code as simple\nas possible in order to be comprehensible and easily extensible.  SymPy is\nwritten entirely in Python. It depends on mpmath, and other external libraries\nmay be optionally for things like plotting support.\n\nSee the webpage for more information and documentation:\n\n    https://sympy.org",
      "module_version": "1.14.0",
      "python_module": "sympy"
    }
  },
  "symbols": {
    "MathVerify.grade/2": {
      "docstring": "Score an answer against the gold expression.",
      "function": "grade",
      "module": "MathVerify",
      "name": "grade",
      "parameters": [
        {
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "gold"
        },
        {
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "answer"
        }
      ],
      "python_module": "math_verify",
      "return_annotation": null
    },
    "MathVerify.parse/1": {
      "docstring": "Extracts and parses mathematical expressions from a prediction string.\n\nThis function attempts to extract mathematical expressions from text using various strategies\n(LaTeX, plain expressions, etc.) and converts them to SymPy objects.\n\nArgs:\n    pred (str): The prediction string to parse.\n    extraction_config (Sequence[ExtractionTarget], optional): Configuration for what types of expressions\n        to extract and how to extract them. Defaults to [LatexExtractionConfig(), ExprExtractionConfig()].\n    fallback_mode (Literal[\"no_fallback\", \"first_match\"], optional): How to handle extraction failures. Defaults to \"first_match\".\n        - \"no_fallback\": Return only successfully parsed expressions\n        - \"first_match\": Include the first string match even if parsing failed\n    extraction_mode (Literal[\"first_match\", \"any_match\"], optional): Strategy for extracting matches. Defaults to \"any_match\".\n        - \"first_match\": Stop after finding the first match\n        - \"any_match\": Try to extract all possible matches, stops after first sucesful parsing attempt\n    parsing_timeout (int, optional): Maximum time in seconds to spend parsing each expression. Defaults to 3. Any timeout seconds > 0 or not None will result in the function to raise a ValueError if it's called in a threaded environment.\n    raise_on_error (bool, optional): Whether to raise an exception if an error occurs during parsing or return an empty list. Defaults to False.\n\nReturns:\n    list: List of extracted predictions. Each prediction can be:\n        - SymPy expression (for successfully parsed mathematical expressions)\n        - String (for fallback matches when fallback_mode=\"first_match\")\n        Empty list if no matches are found.\n\nExamples:\n    >>> parse(\"The answer is $\\frac{1}{2}$\")\n    [Rational(1, 2)]\n    >>> parse(\"The answer is 1/2\")\n    [Rational(1, 2)]\n    >>> parse(\"The answer is A\", extraction_config=[StringExtractionConfig()])\n    ['a']",
      "elixir_name": "parse",
      "function": "parse",
      "has_var_keyword": false,
      "has_var_positional": false,
      "maximum_arity": 3,
      "minimum_arity": 1,
      "module": "MathVerify",
      "name": "parse",
      "optional_keyword_only": [],
      "parameters": [
        {
          "annotation": "str",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "pred",
          "type": {
            "type": "string"
          }
        },
        {
          "annotation": "Sequence",
          "default": "[LatexExtractionConfig(try_extract_without_anchor=True, boxed_match_priority=50, normalization_config=NormalizationConfig(basic_latex=True, units=True, malformed_operators=True, nits=True, boxed='all', equations=False)), ExprExtractionConfig(try_extract_without_anchor=True)]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "extraction_config",
          "type": {
            "args": [
              {
                "args": [
                  {
                    "module": "math_verify.parser",
                    "name": "LatexExtractionConfig",
                    "type": "class"
                  },
                  {
                    "module": "math_verify.parser",
                    "name": "ExprExtractionConfig",
                    "type": "class"
                  },
                  {
                    "module": "math_verify.parser",
                    "name": "StringExtractionConfig",
                    "type": "class"
                  }
                ],
                "origin": "<class 'types.UnionType'>",
                "type": "generic"
              }
            ],
            "origin": "<class 'collections.abc.Sequence'>",
            "type": "generic"
          }
        },
        {
          "annotation": "Literal",
          "default": "'first_match'",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "fallback_mode",
          "type": {
            "args": [
              {
                "raw": "no_fallback",
                "type": "any"
              },
              {
                "raw": "first_match",
                "type": "any"
              }
            ],
            "origin": "typing.Literal",
            "type": "generic"
          }
        },
        {
          "annotation": "Literal",
          "default": "'any_match'",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "extraction_mode",
          "type": {
            "args": [
              {
                "raw": "first_match",
                "type": "any"
              },
              {
                "raw": "any_match",
                "type": "any"
              }
            ],
            "origin": "typing.Literal",
            "type": "generic"
          }
        },
        {
          "annotation": "int",
          "default": "5",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "parsing_timeout",
          "type": {
            "type": "int"
          }
        },
        {
          "annotation": "bool",
          "default": "False",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "raise_on_error",
          "type": {
            "type": "boolean"
          }
        }
      ],
      "python_module": "math_verify",
      "python_name": "parse",
      "required_arity": 1,
      "required_keyword_only": [],
      "return_annotation": null,
      "return_type": {
        "type": "any"
      },
      "signature_available": true
    },
    "MathVerify.verify/2": {
      "docstring": "Verifies if the target expression matches the gold expression using multiple comparison strategies.\n\nThis function implements a comprehensive comparison system for mathematical expressions,\nhandling various types of mathematical objects (numbers, expressions, sets, matrices, etc.)\nwith multiple fallback strategies.\n\nNote:\n    - It's expected that both gold and pred has been parsed with math_verify.parse function.\n    - Function is not symmetric, gold answer should be passed as gold and prediction as pred. The non-symmetric nature appears at assignment simplification and equation interval conversion.\n\nArgs:\n    gold: The reference/correct expression(s). Can be:\n        - A single SymPy expression (Basic or MatrixBase)\n        - A string\n        - A list of any of the above\n    target: The expression(s) to verify. Same types as gold.\n    float_rounding: Number of decimal places to round floats to. Defaults to 6.\n    numeric_precision: Number of decimal places to consider for numeric comparisons. Defaults to 15.\n        - If you know the evaluated expressions will be small, you should increase this. See: https://docs.sympy.org/latest/modules/evalf.html\n    strict: Whether to enforce strict comparison mode. Defaults to True.\n        - In strict mode: Variables matter and sets are not comparable with tuples\n        - In non-strict mode: Variables are matched by position and sets can be compared with tuples\n    timeout_seconds: Maximum time in seconds to spend on any single comparison operation.\n        Defaults to 5 seconds. Any timeout seconds > 0 or not None will result in the function to raise a ValueError if it's called in a threaded environment.\n    allow_set_relation_comp: Whether to allow set - relation (e.g 1 < x < 2 and (1, 2)) comparison. Defaults to False.\n        - If True, set - relation comparison will be allowed in all cases.\n        - If False, set - relation comparison will be allowed only if the prediction is a set.\n    raise_on_error: Whether to raise an exception if an error occurs during comparison or return False. Defaults to False.\n\nReturns:\n    bool: True if target matches gold according to any of the comparison strategies,\n          False otherwise.\n\nComparison Strategy:\n    1. String to String comparison\n    2. Numeric expressions: Comparison within specified precision\n    3. Symbolic equality through simplification\n    4. Special handling for:\n        - Relational expressions (equations/inequalities)\n        - Sets and intervals\n        - Matrices and vectors\n        - Complex numbers\n    5. Robust error handling with timeout protection\n\nExample:\n    >>> verify(sympy.Rational(1, 3), 0.333333)  # Numeric comparison\n    True\n    >>> verify(sympy.Symbol('x') + 1, sympy.Symbol('y') + 1, strict=False)  # Variable matching\n    True\n    >>> verify(sympy.FiniteSet(1, 2), sympy.Tuple(1, 2), strict=False)  # Set-tuple comparison\n    True",
      "elixir_name": "verify",
      "function": "verify",
      "has_var_keyword": false,
      "has_var_positional": false,
      "maximum_arity": 4,
      "minimum_arity": 2,
      "module": "MathVerify",
      "name": "verify",
      "optional_keyword_only": [],
      "parameters": [
        {
          "annotation": "list[sympy.core.basic.Basic | sympy.matrices.matrixbase.MatrixBase | str] | sympy.core.basic.Basic | sympy.matrices.matrixbase.MatrixBase | str",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "gold",
          "type": {
            "args": [
              {
                "element_type": {
                  "args": [
                    {
                      "module": "sympy.core.basic",
                      "name": "Basic",
                      "type": "class"
                    },
                    {
                      "module": "sympy.matrices.matrixbase",
                      "name": "MatrixBase",
                      "type": "class"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "origin": "<class 'types.UnionType'>",
                  "type": "generic"
                },
                "type": "list"
              },
              {
                "module": "sympy.core.basic",
                "name": "Basic",
                "type": "class"
              },
              {
                "module": "sympy.matrices.matrixbase",
                "name": "MatrixBase",
                "type": "class"
              },
              {
                "type": "string"
              }
            ],
            "origin": "<class 'types.UnionType'>",
            "type": "generic"
          }
        },
        {
          "annotation": "list[sympy.core.basic.Basic | sympy.matrices.matrixbase.MatrixBase | str] | sympy.core.basic.Basic | sympy.matrices.matrixbase.MatrixBase | str",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "target",
          "type": {
            "args": [
              {
                "element_type": {
                  "args": [
                    {
                      "module": "sympy.core.basic",
                      "name": "Basic",
                      "type": "class"
                    },
                    {
                      "module": "sympy.matrices.matrixbase",
                      "name": "MatrixBase",
                      "type": "class"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "origin": "<class 'types.UnionType'>",
                  "type": "generic"
                },
                "type": "list"
              },
              {
                "module": "sympy.core.basic",
                "name": "Basic",
                "type": "class"
              },
              {
                "module": "sympy.matrices.matrixbase",
                "name": "MatrixBase",
                "type": "class"
              },
              {
                "type": "string"
              }
            ],
            "origin": "<class 'types.UnionType'>",
            "type": "generic"
          }
        },
        {
          "annotation": "int",
          "default": "6",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "float_rounding",
          "type": {
            "type": "int"
          }
        },
        {
          "annotation": "int",
          "default": "15",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "numeric_precision",
          "type": {
            "type": "int"
          }
        },
        {
          "annotation": "bool",
          "default": "True",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "strict",
          "type": {
            "type": "boolean"
          }
        },
        {
          "annotation": "bool",
          "default": "False",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "allow_set_relation_comp",
          "type": {
            "type": "boolean"
          }
        },
        {
          "annotation": "int | None",
          "default": "5",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "timeout_seconds",
          "type": {
            "args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ],
            "origin": "<class 'types.UnionType'>",
            "type": "generic"
          }
        },
        {
          "annotation": "bool",
          "default": "False",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "raise_on_error",
          "type": {
            "type": "boolean"
          }
        }
      ],
      "python_module": "math_verify",
      "python_name": "verify",
      "required_arity": 2,
      "required_keyword_only": [],
      "return_annotation": "bool",
      "return_type": {
        "type": "boolean"
      },
      "signature_available": true
    },
    "PyLatexEnc.Latexencode.unicode_to_latex/1": {
      "docstring": "Convert unicode text to LaTeX.",
      "function": "unicode_to_latex",
      "module": "PyLatexEnc.Latexencode",
      "name": "unicode_to_latex",
      "parameters": [
        {
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "text"
        }
      ],
      "python_module": "pylatexenc.latexencode",
      "return_annotation": null
    },
    "Sympy.latex/1": {
      "docstring": "Return a LaTeX representation of an expression.",
      "function": "latex",
      "module": "Sympy",
      "name": "latex",
      "parameters": [
        {
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "expr"
        }
      ],
      "python_module": "sympy",
      "return_annotation": null
    },
    "Sympy.simplify/1": {
      "docstring": "Simplify a symbolic expression.",
      "function": "simplify",
      "module": "Sympy",
      "name": "simplify",
      "parameters": [
        {
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "expr"
        }
      ],
      "python_module": "sympy",
      "return_annotation": null
    },
    "Sympy.sympify/1": {
      "docstring": "Convert text to a SymPy expression.",
      "function": "sympify",
      "module": "Sympy",
      "name": "sympify",
      "parameters": [
        {
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "expr"
        }
      ],
      "python_module": "sympy",
      "return_annotation": null
    }
  },
  "version": "0.14.0"
}