{
  "classes": {
    "PyLatexEnc.Latexwalker.LatexWalker": {
      "attributes": [],
      "class": "LatexWalker",
      "docstring": "Walk a LaTeX string and parse nodes.",
      "methods": [
        {
          "docstring": "",
          "name": "__init__",
          "parameters": [
            {
              "kind": "POSITIONAL_OR_KEYWORD",
              "name": "latex"
            }
          ]
        },
        {
          "docstring": "Parse the LaTeX string into nodes.",
          "name": "get_latex_nodes",
          "parameters": []
        }
      ],
      "module": "PyLatexEnc.Latexwalker.LatexWalker",
      "python_module": "pylatexenc.latexwalker"
    }
  },
  "symbols": {
    "MathVerify.grade/2": {
      "docstring": "Score an answer against the gold expression.",
      "function": "grade",
      "module": "MathVerify",
      "name": "grade",
      "parameters": [
        {
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "gold"
        },
        {
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "answer"
        }
      ],
      "python_module": "math_verify",
      "return_annotation": null
    },
    "MathVerify.parse/1": {
      "docstring": "Extracts and parses mathematical expressions from a prediction string.\n\nThis function attempts to extract mathematical expressions from text using various strategies\n(LaTeX, plain expressions, etc.) and converts them to SymPy objects.\n\nArgs:\n    pred (str): The prediction string to parse.\n    extraction_config (Sequence[ExtractionTarget], optional): Configuration for what types of expressions\n        to extract and how to extract them. Defaults to [LatexExtractionConfig(), ExprExtractionConfig()].\n    fallback_mode (Literal[\"no_fallback\", \"first_match\"], optional): How to handle extraction failures. Defaults to \"first_match\".\n        - \"no_fallback\": Return only successfully parsed expressions\n        - \"first_match\": Include the first string match even if parsing failed\n    extraction_mode (Literal[\"first_match\", \"any_match\"], optional): Strategy for extracting matches. Defaults to \"any_match\".\n        - \"first_match\": Stop after finding the first match\n        - \"any_match\": Try to extract all possible matches, stops after first sucesful parsing attempt\n    parsing_timeout (int, optional): Maximum time in seconds to spend parsing each expression. Defaults to 3. Any timeout seconds > 0 or not None will result in the function to raise a ValueError if it's called in a threaded environment.\n    raise_on_error (bool, optional): Whether to raise an exception if an error occurs during parsing or return an empty list. Defaults to False.\n\nReturns:\n    list: List of extracted predictions. Each prediction can be:\n        - SymPy expression (for successfully parsed mathematical expressions)\n        - String (for fallback matches when fallback_mode=\"first_match\")\n        Empty list if no matches are found.\n\nExamples:\n    >>> parse(\"The answer is $\\frac{1}{2}$\")\n    [Rational(1, 2)]\n    >>> parse(\"The answer is 1/2\")\n    [Rational(1, 2)]\n    >>> parse(\"The answer is A\", extraction_config=[StringExtractionConfig()])\n    ['a']",
      "elixir_name": "parse",
      "function": "parse",
      "has_var_keyword": false,
      "has_var_positional": false,
      "maximum_arity": 3,
      "minimum_arity": 1,
      "module": "MathVerify",
      "name": "parse",
      "optional_keyword_only": [],
      "parameters": [
        {
          "annotation": "str",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "pred",
          "type": {
            "type": "string"
          }
        },
        {
          "annotation": "Sequence",
          "default": "[LatexExtractionConfig(try_extract_without_anchor=True, boxed_match_priority=50, normalization_config=NormalizationConfig(basic_latex=True, units=True, malformed_operators=True, nits=True, boxed='all', equations=False)), ExprExtractionConfig(try_extract_without_anchor=True)]",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "extraction_config",
          "type": {
            "args": [
              {
                "args": [
                  {
                    "module": "math_verify.parser",
                    "name": "LatexExtractionConfig",
                    "type": "class"
                  },
                  {
                    "module": "math_verify.parser",
                    "name": "ExprExtractionConfig",
                    "type": "class"
                  },
                  {
                    "module": "math_verify.parser",
                    "name": "StringExtractionConfig",
                    "type": "class"
                  }
                ],
                "origin": "<class 'types.UnionType'>",
                "type": "generic"
              }
            ],
            "origin": "<class 'collections.abc.Sequence'>",
            "type": "generic"
          }
        },
        {
          "annotation": "Literal",
          "default": "'first_match'",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "fallback_mode",
          "type": {
            "args": [
              {
                "raw": "no_fallback",
                "type": "any"
              },
              {
                "raw": "first_match",
                "type": "any"
              }
            ],
            "origin": "typing.Literal",
            "type": "generic"
          }
        },
        {
          "annotation": "Literal",
          "default": "'any_match'",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "extraction_mode",
          "type": {
            "args": [
              {
                "raw": "first_match",
                "type": "any"
              },
              {
                "raw": "any_match",
                "type": "any"
              }
            ],
            "origin": "typing.Literal",
            "type": "generic"
          }
        },
        {
          "annotation": "int",
          "default": "5",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "parsing_timeout",
          "type": {
            "type": "int"
          }
        },
        {
          "annotation": "bool",
          "default": "False",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "raise_on_error",
          "type": {
            "type": "boolean"
          }
        }
      ],
      "python_module": "math_verify",
      "python_name": "parse",
      "required_arity": 1,
      "required_keyword_only": [],
      "return_annotation": null,
      "return_type": {
        "type": "any"
      },
      "signature_available": true
    },
    "MathVerify.verify/2": {
      "docstring": "Verifies if the target expression matches the gold expression using multiple comparison strategies.\n\nThis function implements a comprehensive comparison system for mathematical expressions,\nhandling various types of mathematical objects (numbers, expressions, sets, matrices, etc.)\nwith multiple fallback strategies.\n\nNote:\n    - It's expected that both gold and pred has been parsed with math_verify.parse function.\n    - Function is not symmetric, gold answer should be passed as gold and prediction as pred. The non-symmetric nature appears at assignment simplification and equation interval conversion.\n\nArgs:\n    gold: The reference/correct expression(s). Can be:\n        - A single SymPy expression (Basic or MatrixBase)\n        - A string\n        - A list of any of the above\n    target: The expression(s) to verify. Same types as gold.\n    float_rounding: Number of decimal places to round floats to. Defaults to 6.\n    numeric_precision: Number of decimal places to consider for numeric comparisons. Defaults to 15.\n        - If you know the evaluated expressions will be small, you should increase this. See: https://docs.sympy.org/latest/modules/evalf.html\n    strict: Whether to enforce strict comparison mode. Defaults to True.\n        - In strict mode: Variables matter and sets are not comparable with tuples\n        - In non-strict mode: Variables are matched by position and sets can be compared with tuples\n    timeout_seconds: Maximum time in seconds to spend on any single comparison operation.\n        Defaults to 5 seconds. Any timeout seconds > 0 or not None will result in the function to raise a ValueError if it's called in a threaded environment.\n    allow_set_relation_comp: Whether to allow set - relation (e.g 1 < x < 2 and (1, 2)) comparison. Defaults to False.\n        - If True, set - relation comparison will be allowed in all cases.\n        - If False, set - relation comparison will be allowed only if the prediction is a set.\n    raise_on_error: Whether to raise an exception if an error occurs during comparison or return False. Defaults to False.\n\nReturns:\n    bool: True if target matches gold according to any of the comparison strategies,\n          False otherwise.\n\nComparison Strategy:\n    1. String to String comparison\n    2. Numeric expressions: Comparison within specified precision\n    3. Symbolic equality through simplification\n    4. Special handling for:\n        - Relational expressions (equations/inequalities)\n        - Sets and intervals\n        - Matrices and vectors\n        - Complex numbers\n    5. Robust error handling with timeout protection\n\nExample:\n    >>> verify(sympy.Rational(1, 3), 0.333333)  # Numeric comparison\n    True\n    >>> verify(sympy.Symbol('x') + 1, sympy.Symbol('y') + 1, strict=False)  # Variable matching\n    True\n    >>> verify(sympy.FiniteSet(1, 2), sympy.Tuple(1, 2), strict=False)  # Set-tuple comparison\n    True",
      "elixir_name": "verify",
      "function": "verify",
      "has_var_keyword": false,
      "has_var_positional": false,
      "maximum_arity": 4,
      "minimum_arity": 2,
      "module": "MathVerify",
      "name": "verify",
      "optional_keyword_only": [],
      "parameters": [
        {
          "annotation": "list[sympy.core.basic.Basic | sympy.matrices.matrixbase.MatrixBase | str] | sympy.core.basic.Basic | sympy.matrices.matrixbase.MatrixBase | str",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "gold",
          "type": {
            "args": [
              {
                "element_type": {
                  "args": [
                    {
                      "module": "sympy.core.basic",
                      "name": "Basic",
                      "type": "class"
                    },
                    {
                      "module": "sympy.matrices.matrixbase",
                      "name": "MatrixBase",
                      "type": "class"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "origin": "<class 'types.UnionType'>",
                  "type": "generic"
                },
                "type": "list"
              },
              {
                "module": "sympy.core.basic",
                "name": "Basic",
                "type": "class"
              },
              {
                "module": "sympy.matrices.matrixbase",
                "name": "MatrixBase",
                "type": "class"
              },
              {
                "type": "string"
              }
            ],
            "origin": "<class 'types.UnionType'>",
            "type": "generic"
          }
        },
        {
          "annotation": "list[sympy.core.basic.Basic | sympy.matrices.matrixbase.MatrixBase | str] | sympy.core.basic.Basic | sympy.matrices.matrixbase.MatrixBase | str",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "target",
          "type": {
            "args": [
              {
                "element_type": {
                  "args": [
                    {
                      "module": "sympy.core.basic",
                      "name": "Basic",
                      "type": "class"
                    },
                    {
                      "module": "sympy.matrices.matrixbase",
                      "name": "MatrixBase",
                      "type": "class"
                    },
                    {
                      "type": "string"
                    }
                  ],
                  "origin": "<class 'types.UnionType'>",
                  "type": "generic"
                },
                "type": "list"
              },
              {
                "module": "sympy.core.basic",
                "name": "Basic",
                "type": "class"
              },
              {
                "module": "sympy.matrices.matrixbase",
                "name": "MatrixBase",
                "type": "class"
              },
              {
                "type": "string"
              }
            ],
            "origin": "<class 'types.UnionType'>",
            "type": "generic"
          }
        },
        {
          "annotation": "int",
          "default": "6",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "float_rounding",
          "type": {
            "type": "int"
          }
        },
        {
          "annotation": "int",
          "default": "15",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "numeric_precision",
          "type": {
            "type": "int"
          }
        },
        {
          "annotation": "bool",
          "default": "True",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "strict",
          "type": {
            "type": "boolean"
          }
        },
        {
          "annotation": "bool",
          "default": "False",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "allow_set_relation_comp",
          "type": {
            "type": "boolean"
          }
        },
        {
          "annotation": "int | None",
          "default": "5",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "timeout_seconds",
          "type": {
            "args": [
              {
                "type": "int"
              },
              {
                "type": "none"
              }
            ],
            "origin": "<class 'types.UnionType'>",
            "type": "generic"
          }
        },
        {
          "annotation": "bool",
          "default": "False",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "raise_on_error",
          "type": {
            "type": "boolean"
          }
        }
      ],
      "python_module": "math_verify",
      "python_name": "verify",
      "required_arity": 2,
      "required_keyword_only": [],
      "return_annotation": "bool",
      "return_type": {
        "type": "boolean"
      },
      "signature_available": true
    },
    "PyLatexEnc.Latexencode.unicode_to_latex/1": {
      "docstring": "Convert unicode text to LaTeX.",
      "function": "unicode_to_latex",
      "module": "PyLatexEnc.Latexencode",
      "name": "unicode_to_latex",
      "parameters": [
        {
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "text"
        }
      ],
      "python_module": "pylatexenc.latexencode",
      "return_annotation": null
    },
    "Sympy.latex/1": {
      "docstring": "Return a LaTeX representation of an expression.",
      "function": "latex",
      "module": "Sympy",
      "name": "latex",
      "parameters": [
        {
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "expr"
        }
      ],
      "python_module": "sympy",
      "return_annotation": null
    },
    "Sympy.simplify/1": {
      "docstring": "Simplify a symbolic expression.",
      "function": "simplify",
      "module": "Sympy",
      "name": "simplify",
      "parameters": [
        {
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "expr"
        }
      ],
      "python_module": "sympy",
      "return_annotation": null
    },
    "Sympy.sympify/1": {
      "docstring": "Convert text to a SymPy expression.",
      "function": "sympify",
      "module": "Sympy",
      "name": "sympify",
      "parameters": [
        {
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "expr"
        }
      ],
      "python_module": "sympy",
      "return_annotation": null
    }
  },
  "version": "3.0.0"
}