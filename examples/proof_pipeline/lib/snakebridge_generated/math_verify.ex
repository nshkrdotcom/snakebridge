# Generated by SnakeBridge v0.11.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: math_verify ~> 0.1

defmodule MathVerify do
  @moduledoc """
  SnakeBridge bindings for `math_verify`.

  ## Runtime Options

  All functions accept a `__runtime__` option for controlling execution behavior:

      Elixir.MathVerify.some_function(args, __runtime__: [timeout: 120_000])

  ### Supported runtime options

  - `:timeout` - Call timeout in milliseconds (default: 120,000ms / 2 minutes)
  - `:timeout_profile` - Use a named profile (`:default`, `:ml_inference`, `:batch_job`, `:streaming`)
  - `:stream_timeout` - Timeout for streaming operations (default: 1,800,000ms / 30 minutes)
  - `:session_id` - Override the session ID for this call
  - `:pool_name` - Target a specific Snakepit pool (multi-pool setups)
  - `:affinity` - Override session affinity (`:hint`, `:strict_queue`, `:strict_fail_fast`)

  ### Timeout Profiles

  - `:default` - 2 minute timeout for regular calls
  - `:ml_inference` - 10 minute timeout for ML/LLM workloads
  - `:batch_job` - Unlimited timeout for long-running jobs
  - `:streaming` - 2 minute timeout, 30 minute stream_timeout

  ### Example with timeout override

      # For a long-running ML inference call
      Elixir.MathVerify.predict(data, __runtime__: [timeout_profile: :ml_inference])

      # Or explicit timeout
      Elixir.MathVerify.predict(data, __runtime__: [timeout: 600_000])

      # Route to a pool and enforce strict affinity
      Elixir.MathVerify.predict(data, __runtime__: [pool_name: :strict_pool, affinity: :strict_queue])

  See `SnakeBridge.Defaults` for global timeout configuration.
  """

  def __snakebridge_python_name__, do: "math_verify"
  def __snakebridge_library__, do: "math_verify"

  @doc """
  Score an answer against the gold expression.

  Parameters:
  - `gold` (term())
  - `answer` (term())

  Returns:
  - `term()`
  """
  @spec grade(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def grade(gold, answer, opts \\ []) do
    SnakeBridge.Runtime.call(__MODULE__, :grade, [gold, answer], opts)
  end

  @doc """
  Extracts and parses mathematical expressions from a prediction string.

  This function attempts to extract mathematical expressions from text using various strategies
  (LaTeX, plain expressions, etc.) and converts them to SymPy objects.

  ## Parameters

  - `pred` - The prediction string to parse. (type: `String.t()`)
  - `extraction_config` - Configuration for what types of expressions to extract and how to extract them. Defaults to [LatexExtractionConfig(), ExprExtractionConfig()]. (type: `Sequence[ExtractionTarget]`)
  - `fallback_mode` - How to handle extraction failures. Defaults to "first_match". - "no_fallback": Return only successfully parsed expressions - "first_match": Include the first string match even if parsing failed (type: `Literal["no_fallback", "first_match"]`)
  - `extraction_mode` - Strategy for extracting matches. Defaults to "any_match". - "first_match": Stop after finding the first match - "any_match": Try to extract all possible matches, stops after first sucesful parsing attempt (type: `Literal["first_match", "any_match"]`)
  - `parsing_timeout` - Maximum time in seconds to spend parsing each expression. Defaults to 3. Any timeout seconds > 0 or not None will result in the function to raise a ValueError if it's called in a threaded environment. (type: `integer()`)
  - `raise_on_error` - Whether to raise an exception if an error occurs during parsing or return an empty list. Defaults to False. (type: `boolean()`)

  ## Returns

  Returns `list()`. List of extracted predictions. Each prediction can be: - SymPy expression (for successfully parsed mathematical expressions) - String (for fallback matches when fallback_mode="first_match") Empty list if no matches are found.

  ## Examples

    iex> parse("The answer is $\frac{1}{2}$")
    [Rational(1, 2)]
    iex> parse("The answer is 1/2")
    [Rational(1, 2)]
    iex> parse("The answer is A", extraction_config=[StringExtractionConfig()])
    ['a']

  Parameters:
  - `pred` (String.t())
  - `extraction_config` (term() default: [LatexExtractionConfig(try_extract_without_anchor=True, boxed_match_priority=50, normalization_config=NormalizationConfig(basic_latex=True, units=True, malformed_operators=True, nits=True, boxed='all', equations=False)), ExprExtractionConfig(try_extract_without_anchor=True)])
  - `fallback_mode` (term() default: 'first_match')
  - `extraction_mode` (term() default: 'any_match')
  - `parsing_timeout` (integer() default: 5)
  - `raise_on_error` (boolean() default: False)

  Returns:
  - `term()`
  """
  @spec parse(String.t()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec parse(String.t(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec parse(String.t(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec parse(String.t(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec parse(String.t(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec parse(String.t(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec parse(String.t(), term(), term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec parse(String.t(), term(), term(), term(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec parse(String.t(), term(), term(), term(), integer()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec parse(String.t(), term(), term(), term(), integer(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec parse(String.t(), term(), term(), term(), integer(), boolean()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec parse(String.t(), term(), term(), term(), integer(), boolean(), keyword()) ::
          {:ok, term()} | {:error, Snakepit.Error.t()}
  def parse(pred) do
    SnakeBridge.Runtime.call(__MODULE__, :parse, [pred], [])
  end

  def parse(pred, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :parse, [pred], opts)
  end

  def parse(pred, extraction_config) do
    SnakeBridge.Runtime.call(__MODULE__, :parse, [pred, extraction_config], [])
  end

  def parse(pred, extraction_config, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :parse, [pred, extraction_config], opts)
  end

  def parse(pred, extraction_config, fallback_mode) do
    SnakeBridge.Runtime.call(__MODULE__, :parse, [pred, extraction_config, fallback_mode], [])
  end

  def parse(pred, extraction_config, fallback_mode, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :parse, [pred, extraction_config, fallback_mode], opts)
  end

  def parse(pred, extraction_config, fallback_mode, extraction_mode) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :parse,
      [pred, extraction_config, fallback_mode, extraction_mode],
      []
    )
  end

  def parse(pred, extraction_config, fallback_mode, extraction_mode, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :parse,
      [pred, extraction_config, fallback_mode, extraction_mode],
      opts
    )
  end

  def parse(pred, extraction_config, fallback_mode, extraction_mode, parsing_timeout) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :parse,
      [pred, extraction_config, fallback_mode, extraction_mode, parsing_timeout],
      []
    )
  end

  def parse(pred, extraction_config, fallback_mode, extraction_mode, parsing_timeout, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :parse,
      [pred, extraction_config, fallback_mode, extraction_mode, parsing_timeout],
      opts
    )
  end

  def parse(
        pred,
        extraction_config,
        fallback_mode,
        extraction_mode,
        parsing_timeout,
        raise_on_error
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :parse,
      [pred, extraction_config, fallback_mode, extraction_mode, parsing_timeout, raise_on_error],
      []
    )
  end

  def parse(
        pred,
        extraction_config,
        fallback_mode,
        extraction_mode,
        parsing_timeout,
        raise_on_error,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :parse,
      [pred, extraction_config, fallback_mode, extraction_mode, parsing_timeout, raise_on_error],
      opts
    )
  end

  @doc """
  Verifies if the target expression matches the gold expression using multiple comparison strategies.

  This function implements a comprehensive comparison system for mathematical expressions,
  handling various types of mathematical objects (numbers, expressions, sets, matrices, etc.)
  with multiple fallback strategies.

  ## Parameters

  - `gold` - The reference/correct expression(s). Can be: - A single SymPy expression (Basic or MatrixBase) - A string - A list of any of the above
  - `target` - The expression(s) to verify. Same types as gold.
  - `float_rounding` - Number of decimal places to round floats to. Defaults to 6.
  - `numeric_precision` - Number of decimal places to consider for numeric comparisons. Defaults to 15. - If you know the evaluated expressions will be small, you should increase this. See: https://docs.sympy.org/latest/modules/evalf.html
  - `strict` - Whether to enforce strict comparison mode. Defaults to True. - In strict mode: Variables matter and sets are not comparable with tuples - In non-strict mode: Variables are matched by position and sets can be compared with tuples
  - `timeout_seconds` - Maximum time in seconds to spend on any single comparison operation. Defaults to 5 seconds. Any timeout seconds > 0 or not None will result in the function to raise a ValueError if it's called in a threaded environment.
  - `allow_set_relation_comp` - Whether to allow set - relation (e.g 1 < x < 2 and (1, 2)) comparison. Defaults to False. - If True, set - relation comparison will be allowed in all cases. - If False, set - relation comparison will be allowed only if the prediction is a set.
  - `raise_on_error` - Whether to raise an exception if an error occurs during comparison or return False. Defaults to False.

  ## Returns

  Returns `boolean()`. True if target matches gold according to any of the comparison strategies, False otherwise.

  ## Examples

    iex> verify(sympy.Rational(1, 3), 0.333333)  # Numeric comparison
    True
    iex> verify(sympy.Symbol('x') + 1, sympy.Symbol('y') + 1, strict=False)  # Variable matching
    True
    iex> verify(sympy.FiniteSet(1, 2), sympy.Tuple(1, 2), strict=False)  # Set-tuple comparison
    True

  ## Notes

  - It's expected that both gold and pred has been parsed with math_verify.parse function.
    - Function is not symmetric, gold answer should be passed as gold and prediction as pred. The non-symmetric nature appears at assignment simplification and equation interval conversion.

  Parameters:
  - `gold` (term())
  - `target` (term())
  - `float_rounding` (integer() default: 6)
  - `numeric_precision` (integer() default: 15)
  - `strict` (boolean() default: True)
  - `allow_set_relation_comp` (boolean() default: False)
  - `timeout_seconds` (term() default: 5)
  - `raise_on_error` (boolean() default: False)

  Returns:
  - `boolean()`
  """
  @spec verify(term(), term()) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
  @spec verify(term(), term(), keyword()) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
  @spec verify(term(), term(), integer()) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
  @spec verify(term(), term(), integer(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  @spec verify(term(), term(), integer(), integer()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  @spec verify(term(), term(), integer(), integer(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  @spec verify(term(), term(), integer(), integer(), boolean()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  @spec verify(term(), term(), integer(), integer(), boolean(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  @spec verify(term(), term(), integer(), integer(), boolean(), boolean()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  @spec verify(term(), term(), integer(), integer(), boolean(), boolean(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  @spec verify(term(), term(), integer(), integer(), boolean(), boolean(), term()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  @spec verify(term(), term(), integer(), integer(), boolean(), boolean(), term(), keyword()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  @spec verify(term(), term(), integer(), integer(), boolean(), boolean(), term(), boolean()) ::
          {:ok, boolean()} | {:error, Snakepit.Error.t()}
  @spec verify(
          term(),
          term(),
          integer(),
          integer(),
          boolean(),
          boolean(),
          term(),
          boolean(),
          keyword()
        ) :: {:ok, boolean()} | {:error, Snakepit.Error.t()}
  def verify(gold, target) do
    SnakeBridge.Runtime.call(__MODULE__, :verify, [gold, target], [])
  end

  def verify(gold, target, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :verify, [gold, target], opts)
  end

  def verify(gold, target, float_rounding) do
    SnakeBridge.Runtime.call(__MODULE__, :verify, [gold, target, float_rounding], [])
  end

  def verify(gold, target, float_rounding, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :verify, [gold, target, float_rounding], opts)
  end

  def verify(gold, target, float_rounding, numeric_precision) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :verify,
      [gold, target, float_rounding, numeric_precision],
      []
    )
  end

  def verify(gold, target, float_rounding, numeric_precision, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :verify,
      [gold, target, float_rounding, numeric_precision],
      opts
    )
  end

  def verify(gold, target, float_rounding, numeric_precision, strict) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :verify,
      [gold, target, float_rounding, numeric_precision, strict],
      []
    )
  end

  def verify(gold, target, float_rounding, numeric_precision, strict, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :verify,
      [gold, target, float_rounding, numeric_precision, strict],
      opts
    )
  end

  def verify(gold, target, float_rounding, numeric_precision, strict, allow_set_relation_comp) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :verify,
      [gold, target, float_rounding, numeric_precision, strict, allow_set_relation_comp],
      []
    )
  end

  def verify(
        gold,
        target,
        float_rounding,
        numeric_precision,
        strict,
        allow_set_relation_comp,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :verify,
      [gold, target, float_rounding, numeric_precision, strict, allow_set_relation_comp],
      opts
    )
  end

  def verify(
        gold,
        target,
        float_rounding,
        numeric_precision,
        strict,
        allow_set_relation_comp,
        timeout_seconds
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :verify,
      [
        gold,
        target,
        float_rounding,
        numeric_precision,
        strict,
        allow_set_relation_comp,
        timeout_seconds
      ],
      []
    )
  end

  def verify(
        gold,
        target,
        float_rounding,
        numeric_precision,
        strict,
        allow_set_relation_comp,
        timeout_seconds,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :verify,
      [
        gold,
        target,
        float_rounding,
        numeric_precision,
        strict,
        allow_set_relation_comp,
        timeout_seconds
      ],
      opts
    )
  end

  def verify(
        gold,
        target,
        float_rounding,
        numeric_precision,
        strict,
        allow_set_relation_comp,
        timeout_seconds,
        raise_on_error
      ) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :verify,
      [
        gold,
        target,
        float_rounding,
        numeric_precision,
        strict,
        allow_set_relation_comp,
        timeout_seconds,
        raise_on_error
      ],
      []
    )
  end

  def verify(
        gold,
        target,
        float_rounding,
        numeric_precision,
        strict,
        allow_set_relation_comp,
        timeout_seconds,
        raise_on_error,
        opts
      )
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(
      __MODULE__,
      :verify,
      [
        gold,
        target,
        float_rounding,
        numeric_precision,
        strict,
        allow_set_relation_comp,
        timeout_seconds,
        raise_on_error
      ],
      opts
    )
  end

  @doc false
  def __functions__ do
    [
      {:grade, 2, __MODULE__, "Score an answer against the gold expression."},
      {:parse, 1, __MODULE__,
       "Extracts and parses mathematical expressions from a prediction string."},
      {:verify, 2, __MODULE__,
       "Verifies if the target expression matches the gold expression using multiple comparison strategies."}
    ]
  end

  @doc false
  def __classes__ do
    []
  end

  @doc false
  def __search__(query) do
    SnakeBridge.Docs.search(__MODULE__, query)
  end

  @doc false
  def doc(function) do
    SnakeBridge.Docs.get(__MODULE__, function)
  end
end
