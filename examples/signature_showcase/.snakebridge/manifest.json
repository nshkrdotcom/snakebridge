{
  "classes": {},
  "modules": {
    "math": {
      "doc_missing_reason": null,
      "doc_source": "runtime",
      "docstring": "This module provides access to the mathematical functions\ndefined by the C standard.",
      "python_module": "math"
    },
    "numpy": {
      "doc_missing_reason": null,
      "doc_source": "runtime",
      "docstring": "NumPy\n=====\n\nProvides\n  1. An array object of arbitrary homogeneous items\n  2. Fast mathematical operations over arrays\n  3. Linear Algebra, Fourier Transforms, Random Number Generation\n\nHow to use the documentation\n----------------------------\nDocumentation is available in two forms: docstrings provided\nwith the code, and a loose standing reference guide, available from\n`the NumPy homepage <https://numpy.org>`_.\n\nWe recommend exploring the docstrings using\n`IPython <https://ipython.org>`_, an advanced Python shell with\nTAB-completion and introspection capabilities.  See below for further\ninstructions.\n\nThe docstring examples assume that `numpy` has been imported as ``np``::\n\n  >>> import numpy as np\n\nCode snippets are indicated by three greater-than signs::\n\n  >>> x = 42\n  >>> x = x + 1\n\nUse the built-in ``help`` function to view a function's docstring::\n\n  >>> help(np.sort)\n  ... # doctest: +SKIP\n\nFor some objects, ``np.info(obj)`` may provide additional help.  This is\nparticularly true if you see the line \"Help on ufunc object:\" at the top\nof the help() page.  Ufuncs are implemented in C, not Python, for speed.\nThe native Python help() does not know how to view their help, but our\nnp.info() function does.\n\nAvailable subpackages\n---------------------\nlib\n    Basic functions used by several sub-packages.\nrandom\n    Core Random Tools\nlinalg\n    Core Linear Algebra Tools\nfft\n    Core FFT routines\npolynomial\n    Polynomial tools\ntesting\n    NumPy testing tools\ndistutils\n    Enhancements to distutils with support for\n    Fortran compilers support and more (for Python <= 3.11)\n\nUtilities\n---------\ntest\n    Run numpy unittests\nshow_config\n    Show numpy build configuration\n__version__\n    NumPy version string\n\nViewing documentation using IPython\n-----------------------------------\n\nStart IPython and import `numpy` usually under the alias ``np``: `import\nnumpy as np`.  Then, directly past or use the ``%cpaste`` magic to paste\nexamples into the shell.  To see which functions are available in `numpy`,\ntype ``np.<TAB>`` (where ``<TAB>`` refers to the TAB key), or use\n``np.*cos*?<ENTER>`` (where ``<ENTER>`` refers to the ENTER key) to narrow\ndown the list.  To view the docstring for a function, use\n``np.cos?<ENTER>`` (to view the docstring) and ``np.cos??<ENTER>`` (to view\nthe source code).\n\nCopies vs. in-place operation\n-----------------------------\nMost of the functions in `numpy` return a copy of the array argument\n(e.g., `np.sort`).  In-place versions of these functions are often\navailable as array methods, i.e. ``x = np.array([1,2,3]); x.sort()``.\nExceptions to this rule are documented.",
      "module_version": "2.4.0",
      "python_module": "numpy"
    },
    "signature_showcase": {
      "doc_missing_reason": "docstring missing",
      "doc_source": "empty",
      "docstring": "",
      "python_module": "signature_showcase"
    }
  },
  "symbols": {
    "Math.sqrt/1": {
      "docstring": "Return the square root of x.",
      "elixir_name": "sqrt",
      "function": "sqrt",
      "has_var_keyword": false,
      "has_var_positional": false,
      "maximum_arity": 2,
      "minimum_arity": 1,
      "module": "Math",
      "name": "sqrt",
      "optional_keyword_only": [],
      "parameters": [
        {
          "kind": "POSITIONAL_ONLY",
          "name": "x",
          "type": {
            "type": "any"
          }
        }
      ],
      "python_module": "math",
      "python_name": "sqrt",
      "required_arity": 1,
      "required_keyword_only": [],
      "return_annotation": null,
      "return_type": {
        "type": "any"
      },
      "signature_available": true
    },
    "Numpy.sqrt/1": {
      "docstring": "sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])\n\nReturn the non-negative square-root of an array, element-wise.\n\nParameters\n----------\nx : array_like\n    The values whose square-roots are required.\nout : ndarray, None, or tuple of ndarray and None, optional\n    A location into which the result is stored. If provided, it must have\n    a shape that the inputs broadcast to. If not provided or None,\n    a freshly-allocated array is returned. A tuple (possible only as a\n    keyword argument) must have length equal to the number of outputs.\nwhere : array_like, optional\n    This condition is broadcast over the input. At locations where the\n    condition is True, the `out` array will be set to the ufunc result.\n    Elsewhere, the `out` array will retain its original value.\n    Note that if an uninitialized `out` array is created via the default\n    ``out=None``, locations within it where the condition is False will\n    remain uninitialized.\n**kwargs\n    For other keyword-only arguments, see the\n    :ref:`ufunc docs <ufuncs.kwargs>`.\n\nReturns\n-------\ny : ndarray\n    An array of the same shape as `x`, containing the positive\n    square-root of each element in `x`.  If any element in `x` is\n    complex, a complex array is returned (and the square-roots of\n    negative reals are calculated).  If all of the elements in `x`\n    are real, so is `y`, with negative elements returning ``nan``.\n    If `out` was provided, `y` is a reference to it.\n    This is a scalar if `x` is a scalar.\n\nSee Also\n--------\nemath.sqrt\n    A version which returns complex numbers when given negative reals.\n    Note that 0.0 and -0.0 are handled differently for complex inputs.\n\nNotes\n-----\n*sqrt* has--consistent with common convention--as its branch cut the\nreal \"interval\" [`-inf`, 0), and is continuous from above on it.\nA branch cut is a curve in the complex plane across which a given\ncomplex function fails to be continuous.\n\nExamples\n--------\n>>> import numpy as np\n>>> np.sqrt([1,4,9])\narray([ 1.,  2.,  3.])\n\n>>> np.sqrt([4, -1, -3+4J])\narray([ 2.+0.j,  0.+1.j,  1.+2.j])\n\n>>> np.sqrt([4, -1, np.inf])\narray([ 2., nan, inf])",
      "elixir_name": "sqrt",
      "function": "sqrt",
      "has_var_keyword": false,
      "has_var_positional": false,
      "maximum_arity": 3,
      "minimum_arity": 1,
      "module": "Numpy",
      "name": "sqrt",
      "optional_keyword_only": [
        "where",
        "casting",
        "order",
        "dtype",
        "subok",
        "signature"
      ],
      "parameters": [
        {
          "kind": "POSITIONAL_ONLY",
          "name": "x",
          "type": {
            "type": "any"
          }
        },
        {
          "default": "None",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "out",
          "type": {
            "type": "any"
          }
        },
        {
          "default": "True",
          "kind": "KEYWORD_ONLY",
          "name": "where",
          "type": {
            "type": "any"
          }
        },
        {
          "default": "'same_kind'",
          "kind": "KEYWORD_ONLY",
          "name": "casting",
          "type": {
            "type": "any"
          }
        },
        {
          "default": "'K'",
          "kind": "KEYWORD_ONLY",
          "name": "order",
          "type": {
            "type": "any"
          }
        },
        {
          "default": "None",
          "kind": "KEYWORD_ONLY",
          "name": "dtype",
          "type": {
            "type": "any"
          }
        },
        {
          "default": "True",
          "kind": "KEYWORD_ONLY",
          "name": "subok",
          "type": {
            "type": "any"
          }
        },
        {
          "default": "None",
          "kind": "KEYWORD_ONLY",
          "name": "signature",
          "type": {
            "type": "any"
          }
        }
      ],
      "python_module": "numpy",
      "python_name": "sqrt",
      "required_arity": 1,
      "required_keyword_only": [],
      "return_annotation": null,
      "return_type": {
        "type": "any"
      },
      "signature_available": true
    },
    "SignatureShowcase.keyword_only/1": {
      "docstring": "",
      "elixir_name": "keyword_only",
      "function": "keyword_only",
      "has_var_keyword": false,
      "has_var_positional": false,
      "maximum_arity": 2,
      "minimum_arity": 1,
      "module": "SignatureShowcase",
      "name": "keyword_only",
      "optional_keyword_only": [
        "optional_kw"
      ],
      "parameters": [
        {
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "a",
          "type": {
            "type": "any"
          }
        },
        {
          "kind": "KEYWORD_ONLY",
          "name": "required_kw",
          "type": {
            "type": "any"
          }
        },
        {
          "default": "None",
          "kind": "KEYWORD_ONLY",
          "name": "optional_kw",
          "type": {
            "type": "any"
          }
        }
      ],
      "python_module": "signature_showcase",
      "python_name": "keyword_only",
      "required_arity": 1,
      "required_keyword_only": [
        "required_kw"
      ],
      "return_annotation": null,
      "return_type": {
        "type": "any"
      },
      "signature_available": true
    },
    "SignatureShowcase.optional_args/1": {
      "docstring": "",
      "elixir_name": "optional_args",
      "function": "optional_args",
      "has_var_keyword": false,
      "has_var_positional": false,
      "maximum_arity": 3,
      "minimum_arity": 1,
      "module": "SignatureShowcase",
      "name": "optional_args",
      "optional_keyword_only": [],
      "parameters": [
        {
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "a",
          "type": {
            "type": "any"
          }
        },
        {
          "default": "1",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "b",
          "type": {
            "type": "any"
          }
        },
        {
          "default": "2",
          "kind": "POSITIONAL_OR_KEYWORD",
          "name": "c",
          "type": {
            "type": "any"
          }
        }
      ],
      "python_module": "signature_showcase",
      "python_name": "optional_args",
      "required_arity": 1,
      "required_keyword_only": [],
      "return_annotation": null,
      "return_type": {
        "type": "any"
      },
      "signature_available": true
    },
    "SignatureShowcase.py_class/0": {
      "docstring": "",
      "elixir_name": "py_class",
      "function": "class",
      "has_var_keyword": false,
      "has_var_positional": false,
      "maximum_arity": 1,
      "minimum_arity": 0,
      "module": "SignatureShowcase",
      "name": "py_class",
      "optional_keyword_only": [],
      "parameters": [],
      "python_module": "signature_showcase",
      "python_name": "class",
      "required_arity": 0,
      "required_keyword_only": [],
      "return_annotation": null,
      "return_type": {
        "type": "any"
      },
      "signature_available": true
    },
    "SignatureShowcase.variadic/0": {
      "docstring": "",
      "elixir_name": "variadic",
      "function": "variadic",
      "has_var_keyword": false,
      "has_var_positional": false,
      "maximum_arity": 9,
      "minimum_arity": 0,
      "module": "SignatureShowcase",
      "name": "variadic",
      "optional_keyword_only": [],
      "parameters": [],
      "python_module": "signature_showcase",
      "python_name": "variadic",
      "required_arity": 0,
      "required_keyword_only": [],
      "return_annotation": null,
      "return_type": {
        "type": "any"
      },
      "signature_available": false
    }
  },
  "version": "0.14.0"
}