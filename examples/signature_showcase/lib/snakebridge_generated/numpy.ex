# Generated by SnakeBridge v0.9.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: numpy stdlib

defmodule Numpy do
  @moduledoc """
  SnakeBridge bindings for `numpy`.

  ## Runtime Options

  All functions accept a `__runtime__` option for controlling execution behavior:

      Elixir.Numpy.some_function(args, __runtime__: [timeout: 120_000])

  ### Supported runtime options

  - `:timeout` - Call timeout in milliseconds (default: 120,000ms / 2 minutes)
  - `:timeout_profile` - Use a named profile (`:default`, `:ml_inference`, `:batch_job`, `:streaming`)
  - `:stream_timeout` - Timeout for streaming operations (default: 1,800,000ms / 30 minutes)
  - `:session_id` - Override the session ID for this call
  - `:pool_name` - Target a specific Snakepit pool (multi-pool setups)
  - `:affinity` - Override session affinity (`:hint`, `:strict_queue`, `:strict_fail_fast`)

  ### Timeout Profiles

  - `:default` - 2 minute timeout for regular calls
  - `:ml_inference` - 10 minute timeout for ML/LLM workloads
  - `:batch_job` - Unlimited timeout for long-running jobs
  - `:streaming` - 2 minute timeout, 30 minute stream_timeout

  ### Example with timeout override

      # For a long-running ML inference call
      Elixir.Numpy.predict(data, __runtime__: [timeout_profile: :ml_inference])

      # Or explicit timeout
      Elixir.Numpy.predict(data, __runtime__: [timeout: 600_000])

      # Route to a pool and enforce strict affinity
      Elixir.Numpy.predict(data, __runtime__: [pool_name: :strict_pool, affinity: :strict_queue])

  See `SnakeBridge.Defaults` for global timeout configuration.
  """

  def __snakebridge_python_name__, do: "numpy"
  def __snakebridge_library__, do: "numpy"

  @doc """
  sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])

  Return the non-negative square-root of an array, element-wise.

  ## Parameters

  - `x` - array_like The values whose square-roots are required.
  - `out` - ndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs.
  - `where` - array_like, optional This condition is broadcast over the input. At locations where the condition is True, the `out` array will be set to the ufunc result. Elsewhere, the `out` array will retain its original value. Note that if an uninitialized `out` array is created via the default ``out=None``, locations within it where the condition is False will remain uninitialized.
  - `**kwargs For other keyword-only arguments, see the :ref:`ufunc docs <ufuncs.kwargs>`.` - 

  ## Returns

  Returns `y`. ndarray An array of the same shape as `x`, containing the positive square-root of each element in `x`.  If any element in `x` is complex, a complex array is returned (and the square-roots of negative reals are calculated).  If all of the elements in `x` are real, so is `y`, with negative elements returning ``nan``. If `out` was provided, `y` is a reference to it. This is a scalar if `x` is a scalar.

  ## Examples

    iex> import numpy as np
    iex> np.sqrt([1,4,9])
    array([ 1.,  2.,  3.])

    iex> np.sqrt([4, -1, -3+4J])
    array([ 2.+0.j,  0.+1.j,  1.+2.j])

    iex> np.sqrt([4, -1, np.inf])
    array([ 2., nan, inf])

  ## Notes

  *sqrt* has--consistent with common convention--as its branch cut the
  real "interval" [`-inf`, 0), and is continuous from above on it.
  A branch cut is a curve in the complex plane across which a given
  complex function fails to be continuous.

  Parameters:
  - `x` (term())
  - `out` (term() default: None)
  - `where` (term() keyword-only default: True)
  - `casting` (term() keyword-only default: 'same_kind')
  - `order` (term() keyword-only default: 'K')
  - `dtype` (term() keyword-only default: None)
  - `subok` (term() keyword-only default: True)
  - `signature` (term() keyword-only default: None)

  Returns:
  - `term()`
  """
  @spec sqrt(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec sqrt(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec sqrt(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec sqrt(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def sqrt(x) do
    SnakeBridge.Runtime.call(__MODULE__, :sqrt, [x], [])
  end

  def sqrt(x, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :sqrt, [x], opts)
  end

  def sqrt(x, out) do
    SnakeBridge.Runtime.call(__MODULE__, :sqrt, [x, out], [])
  end

  def sqrt(x, out, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :sqrt, [x, out], opts)
  end

  @doc false
  def __functions__ do
    [
      {:sqrt, 1, __MODULE__,
       "sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])"}
    ]
  end

  @doc false
  def __classes__ do
    []
  end

  @doc false
  def __search__(query) do
    SnakeBridge.Docs.search(__MODULE__, query)
  end

  @doc false
  def doc(function) do
    SnakeBridge.Docs.get(__MODULE__, function)
  end
end
