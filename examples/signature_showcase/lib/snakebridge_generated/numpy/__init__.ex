# Generated by SnakeBridge v0.14.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: numpy stdlib
# Python module: numpy

defmodule Numpy do
  @moduledoc """
  NumPy

  =====

  Provides
    1. An array object of arbitrary homogeneous items
    2. Fast mathematical operations over arrays
    3. Linear Algebra, Fourier Transforms, Random Number Generation

  How to use the documentation
  ----------------------------
  Documentation is available in two forms: docstrings provided
  with the code, and a loose standing reference guide, available from
  `the NumPy homepage <https://numpy.org>`_.

  We recommend exploring the docstrings using
  `IPython <https://ipython.org>`_, an advanced Python shell with
  TAB-completion and introspection capabilities.  See below for further
  instructions.

  The docstring examples assume that `numpy` has been imported as ``np``::

    >>> import numpy as np

  Code snippets are indicated by three greater-than signs::

    >>> x = 42
    >>> x = x + 1

  Use the built-in ``help`` function to view a function's docstring::

    >>> help(np.sort)
    ... # doctest: +SKIP

  For some objects, ``np.info(obj)`` may provide additional help.  This is
  particularly true if you see the line "Help on ufunc object:" at the top
  of the help() page.  Ufuncs are implemented in C, not Python, for speed.
  The native Python help() does not know how to view their help, but our
  np.info() function does.

  Available subpackages
  ---------------------
  lib
      Basic functions used by several sub-packages.
  random
      Core Random Tools
  linalg
      Core Linear Algebra Tools
  fft
      Core FFT routines
  polynomial
      Polynomial tools
  testing
      NumPy testing tools
  distutils
      Enhancements to distutils with support for
      Fortran compilers support and more (for Python <= 3.11)

  Utilities
  ---------
  test
      Run numpy unittests
  show_config
      Show numpy build configuration
  __version__
      NumPy version string

  Viewing documentation using IPython
  -----------------------------------

  Start IPython and import `numpy` usually under the alias ``np``: `import
  numpy as np`.  Then, directly past or use the ``%cpaste`` magic to paste
  examples into the shell.  To see which functions are available in `numpy`,
  type ``np.<TAB>`` (where ``<TAB>`` refers to the TAB key), or use
  ``np.*cos*?<ENTER>`` (where ``<ENTER>`` refers to the ENTER key) to narrow
  down the list.  To view the docstring for a function, use
  ``np.cos?<ENTER>`` (to view the docstring) and ``np.cos??<ENTER>`` (to view
  the source code).

  Copies vs. in-place operation
  -----------------------------
  Most of the functions in `numpy` return a copy of the array argument
  (e.g., `np.sort`).  In-place versions of these functions are often
  available as array methods, i.e. ``x = np.array([1,2,3]); x.sort()``.
  Exceptions to this rule are documented.

  ## Python Docs

  - [Python docs](https://docs.python.org/3/library/numpy.html)

  ## Version

  - Python stdlib (Python 3.12.3)

  ## Runtime Options

  All functions accept a `__runtime__` option for controlling execution behavior:

      Numpy.some_function(args, __runtime__: [timeout: 120_000])

  ### Supported runtime options

  - `:timeout` - Call timeout in milliseconds (default: 120,000ms / 2 minutes)
  - `:timeout_profile` - Use a named profile (`:default`, `:ml_inference`, `:batch_job`, `:streaming`)
  - `:stream_timeout` - Timeout for streaming operations (default: 1,800,000ms / 30 minutes)
  - `:session_id` - Override the session ID for this call
  - `:pool_name` - Target a specific Snakepit pool (multi-pool setups)
  - `:affinity` - Override session affinity (`:hint`, `:strict_queue`, `:strict_fail_fast`)

  ### Timeout Profiles

  - `:default` - 2 minute timeout for regular calls
  - `:ml_inference` - 10 minute timeout for ML/LLM workloads
  - `:batch_job` - Unlimited timeout for long-running jobs
  - `:streaming` - 2 minute timeout, 30 minute stream_timeout

  ### Example with timeout override

      # For a long-running ML inference call
      Numpy.predict(data, __runtime__: [timeout_profile: :ml_inference])

      # Or explicit timeout
      Numpy.predict(data, __runtime__: [timeout: 600_000])

      # Route to a pool and enforce strict affinity
      Numpy.predict(data, __runtime__: [pool_name: :strict_pool, affinity: :strict_queue])

  See `SnakeBridge.Defaults` for global timeout configuration.

  """

  @doc false
  def __snakebridge_python_name__, do: "numpy"
  @doc false
  def __snakebridge_library__, do: "numpy"

  @doc """
  sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])

  Return the non-negative square-root of an array, element-wise.

  ## Parameters

  - `x` - array_like The values whose square-roots are required.
  - `out` - ndarray, None, or tuple of ndarray and None, optional A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs.
  - `where` - array_like, optional This condition is broadcast over the input. At locations where the condition is True, the `out` array will be set to the ufunc result. Elsewhere, the `out` array will retain its original value. Note that if an uninitialized `out` array is created via the default ``out=None``, locations within it where the condition is False will remain uninitialized.
  - `**kwargs For other keyword-only arguments, see the :ref:`ufunc docs <ufuncs.kwargs>`.` - 

  ## Returns

  Returns `y`. ndarray An array of the same shape as `x`, containing the positive square-root of each element in `x`.  If any element in `x` is complex, a complex array is returned (and the square-roots of negative reals are calculated).  If all of the elements in `x` are real, so is `y`, with negative elements returning ``nan``. If `out` was provided, `y` is a reference to it. This is a scalar if `x` is a scalar.

  ## Examples

    iex> import numpy as np
    iex> np.sqrt([1,4,9])
    array([ 1.,  2.,  3.])

    iex> np.sqrt([4, -1, -3+4J])
    array([ 2.+0.j,  0.+1.j,  1.+2.j])

    iex> np.sqrt([4, -1, np.inf])
    array([ 2., nan, inf])

  ## Notes

  *sqrt* has--consistent with common convention--as its branch cut the
  real "interval" [`-inf`, 0), and is continuous from above on it.
  A branch cut is a curve in the complex plane across which a given
  complex function fails to be continuous.
  """
  @spec sqrt(term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec sqrt(term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec sqrt(term(), term()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  @spec sqrt(term(), term(), keyword()) :: {:ok, term()} | {:error, Snakepit.Error.t()}
  def sqrt(x) do
    SnakeBridge.Runtime.call(__MODULE__, :sqrt, [x], [])
  end

  def sqrt(x, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :sqrt, [x], opts)
  end

  def sqrt(x, out) do
    SnakeBridge.Runtime.call(__MODULE__, :sqrt, [x, out], [])
  end

  def sqrt(x, out, opts)
      when is_list(opts) and
             (opts == [] or
                (is_tuple(hd(opts)) and tuple_size(hd(opts)) == 2 and is_atom(elem(hd(opts), 0)))) do
    SnakeBridge.Runtime.call(__MODULE__, :sqrt, [x, out], opts)
  end

  @doc false
  def __functions__ do
    [
      {:sqrt, 1, __MODULE__,
       "sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature])"}
    ]
  end

  @doc false
  def __classes__ do
    []
  end

  @doc false
  def __search__(query) do
    SnakeBridge.Docs.search(__MODULE__, query)
  end

  @doc false
  def doc(function) do
    SnakeBridge.Docs.get(__MODULE__, function)
  end
end
