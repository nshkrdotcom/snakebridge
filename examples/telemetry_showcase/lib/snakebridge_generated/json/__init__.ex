# Generated by SnakeBridge v0.15.0 - DO NOT EDIT MANUALLY
# Regenerate with: mix compile
# Library: json stdlib
# Python module: json

defmodule Json do
  @moduledoc """
  JSON (JavaScript Object Notation) <https://json.org> is a subset of

  JavaScript syntax (ECMA-262 3rd edition) used as a lightweight data
  interchange format.

  :mod:`json` exposes an API familiar to users of the standard library
  :mod:`marshal` and :mod:`pickle` modules.  It is derived from a
  version of the externally maintained simplejson library.

  Encoding basic Python object hierarchies::

      >>> import json
      >>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])
      '["foo", {"bar": ["baz", null, 1.0, 2]}]'
      >>> print(json.dumps("\"foo\bar"))
      "\"foo\bar"
      >>> print(json.dumps('\u1234'))
      "\u1234"
      >>> print(json.dumps('\\'))
      "\\"
      >>> print(json.dumps({"c": 0, "b": 0, "a": 0}, sort_keys=True))
      {"a": 0, "b": 0, "c": 0}
      >>> from io import StringIO
      >>> io = StringIO()
      >>> json.dump(['streaming API'], io)
      >>> io.getvalue()
      '["streaming API"]'

  Compact encoding::

      >>> import json
      >>> mydict = {'4': 5, '6': 7}
      >>> json.dumps([1,2,3,mydict], separators=(',', ':'))
      '[1,2,3,{"4":5,"6":7}]'

  Pretty printing::

      >>> import json
      >>> print(json.dumps({'4': 5, '6': 7}, sort_keys=True, indent=4))
      {
          "4": 5,
          "6": 7
      }

  Decoding JSON::

      >>> import json
      >>> obj = ['foo', {'bar': ['baz', None, 1.0, 2]}]
      >>> json.loads('["foo", {"bar":["baz", null, 1.0, 2]}]') == obj
      True
      >>> json.loads('"\\"foo\\bar"') == '"foo\x08ar'
      True
      >>> from io import StringIO
      >>> io = StringIO('["streaming API"]')
      >>> json.load(io)[0] == 'streaming API'
      True

  Specializing JSON object decoding::

      >>> import json
      >>> def as_complex(dct):
      ...     if '__complex__' in dct:
      ...         return complex(dct['real'], dct['imag'])
      ...     return dct
      ...
      >>> json.loads('{"__complex__": true, "real": 1, "imag": 2}',
      ...     object_hook=as_complex)
      (1+2j)
      >>> from decimal import Decimal
      >>> json.loads('1.1', parse_float=Decimal) == Decimal('1.1')
      True

  Specializing JSON object encoding::

      >>> import json
      >>> def encode_complex(obj):
      ...     if isinstance(obj, complex):
      ...         return [obj.real, obj.imag]
      ...     raise TypeError(f'Object of type {obj.__class__.__name__} '
      ...                     f'is not JSON serializable')
      ...
      >>> json.dumps(2 + 1j, default=encode_complex)
      '[2.0, 1.0]'
      >>> json.JSONEncoder(default=encode_complex).encode(2 + 1j)
      '[2.0, 1.0]'
      >>> ''.join(json.JSONEncoder(default=encode_complex).iterencode(2 + 1j))
      '[2.0, 1.0]'


  Using json.tool from the shell to validate and pretty-print::

      $ echo '{"json":"obj"}' | python -m json.tool
      {
          "json": "obj"
      }
      $ echo '{ 1.2:3.4}' | python -m json.tool
      Expecting property name enclosed in double quotes: line 1 column 3 (char 2)

  ## Python Docs

  - [Python docs](https://docs.python.org/3/library/json.html)

  ## Version

  - Python stdlib (Python 3.12.3)

  ## Runtime Options

  All functions accept a `__runtime__` option for controlling execution behavior:

      Json.some_function(args, __runtime__: [timeout: 120_000])

  ### Supported runtime options

  - `:timeout` - Call timeout in milliseconds (default: 120,000ms / 2 minutes)
  - `:timeout_profile` - Use a named profile (`:default`, `:ml_inference`, `:batch_job`, `:streaming`)
  - `:stream_timeout` - Timeout for streaming operations (default: 1,800,000ms / 30 minutes)
  - `:session_id` - Override the session ID for this call
  - `:pool_name` - Target a specific Snakepit pool (multi-pool setups)
  - `:affinity` - Override session affinity (`:hint`, `:strict_queue`, `:strict_fail_fast`)

  ### Timeout Profiles

  - `:default` - 2 minute timeout for regular calls
  - `:ml_inference` - 10 minute timeout for ML/LLM workloads
  - `:batch_job` - Unlimited timeout for long-running jobs
  - `:streaming` - 2 minute timeout, 30 minute stream_timeout

  ### Example with timeout override

      # For a long-running ML inference call
      Json.predict(data, __runtime__: [timeout_profile: :ml_inference])

      # Or explicit timeout
      Json.predict(data, __runtime__: [timeout: 600_000])

      # Route to a pool and enforce strict affinity
      Json.predict(data, __runtime__: [pool_name: :strict_pool, affinity: :strict_queue])

  See `SnakeBridge.Defaults` for global timeout configuration.

  """

  @doc false
  def __snakebridge_python_name__, do: "json"
  @doc false
  def __snakebridge_library__, do: "json"

  @doc false
  def __functions__ do
    []
  end

  @doc false
  def __classes__ do
    []
  end

  @doc false
  def __search__(query) do
    SnakeBridge.Docs.search(__MODULE__, query)
  end

  @doc false
  def doc(function) do
    SnakeBridge.Docs.get(__MODULE__, function)
  end
end
