defmodule SnakeBridge.Generator do
  @moduledoc """
  Code generation engine for SnakeBridge.

  Generates Elixir modules from Python library descriptors using
  metaprogramming and AST manipulation.
  """

  @doc """
  Generate module AST from descriptor.

  Takes a class descriptor and configuration, returns quoted Elixir code
  that defines a module with create/execute functions.
  """
  @spec generate_module(map(), SnakeBridge.Config.t()) :: Macro.t()
  def generate_module(descriptor, config) do
    # Support both struct and map descriptors
    descriptor_name = Map.get(descriptor, :name) || Map.get(descriptor, "name")
    elixir_module = Map.get(descriptor, :elixir_module) || Map.get(descriptor, "elixir_module")
    python_path = Map.get(descriptor, :python_path) || Map.get(descriptor, "python_path")
    methods = Map.get(descriptor, :methods) || Map.get(descriptor, "methods") || []

    constant_fields =
      Map.get(descriptor, :constant_fields) || Map.get(descriptor, "constant_fields") || []

    module_name = elixir_module || Module.concat([DSPy, String.to_atom(descriptor_name)])

    compilation_mode = config.compilation_mode

    quote do
      defmodule unquote(module_name) do
        @moduledoc unquote(generate_moduledoc(descriptor))

        @python_path unquote(python_path)
        @config unquote(Macro.escape(config))

        @type t :: {session_id :: String.t(), instance_id :: String.t()}

        unquote_splicing(generate_constant_attributes(constant_fields))

        unquote(generate_hooks(compilation_mode))

        @doc """
        Create a new instance of #{unquote(python_path)}.
        """
        @spec create(map(), keyword()) :: {:ok, t()} | {:error, term()}
        def create(args \\ %{}, opts \\ []) do
          session_id = Keyword.get(opts, :session_id, generate_session_id())

          # Placeholder for actual Snakepit integration
          {:ok, {session_id, "instance_#{:rand.uniform(1000)}"}}
        end

        unquote_splicing(generate_methods(methods))

        defp generate_session_id do
          "session_#{:rand.uniform(100_000)}"
        end
      end
    end
  end

  defp generate_constant_attributes(constant_fields) when is_list(constant_fields) do
    Enum.map(constant_fields, fn field_name ->
      # Convert UPPER_CASE to lower_case for attribute name
      attr_name =
        field_name
        |> String.downcase()
        |> String.to_atom()

      # Generate actual @attr syntax in AST
      {:@, [], [{attr_name, [], [nil]}]}
    end)
  end

  defp generate_hooks(:compile_time) do
    quote do
      @before_compile SnakeBridge.Generator.Hooks
    end
  end

  defp generate_hooks(:runtime) do
    quote do
      @on_load :__snakebridge_load__

      def __snakebridge_load__ do
        # Runtime initialization
        :ok
      end
    end
  end

  defp generate_hooks(_auto_or_other) do
    # No special hooks for :auto mode
    quote do
    end
  end

  defp generate_moduledoc(descriptor) do
    docstring = Map.get(descriptor, :docstring, "")
    python_path = Map.get(descriptor, :python_path, "")

    """
    Elixir wrapper for #{python_path}.

    #{docstring}

    This module was automatically generated by SnakeBridge.
    """
  end

  defp generate_methods(methods) when is_list(methods) do
    Enum.map(methods, fn method ->
      # Support both struct/map with atom keys and map with string keys
      method_name =
        Map.get(method, :name) || Map.get(method, "name") || raise "Method must have name"

      elixir_name =
        Map.get(method, :elixir_name) || Map.get(method, "elixir_name") ||
          String.to_atom(method_name)

      streaming = Map.get(method, :streaming) || Map.get(method, "streaming") || false

      quote do
        @doc """
        Call #{unquote(method_name)} on the Python instance.

        Streaming: #{unquote(streaming)}
        """
        @spec unquote(elixir_name)(t(), map(), keyword()) :: {:ok, term()} | {:error, term()}
        def unquote(elixir_name)(instance_ref, args \\ %{}, opts \\ []) do
          # Placeholder for actual execution
          {:ok, %{"result" => "placeholder"}}
        end
      end
    end)
  end

  @doc """
  Optimize generated AST.

  Applies various optimization passes to improve generated code.
  """
  @spec optimize(Macro.t()) :: Macro.t()
  def optimize(ast) do
    ast
    |> remove_unused_imports()
    |> inline_constants()
  end

  defp remove_unused_imports(ast) do
    # Walk the AST and remove import statements
    # This is a simplified version that removes all imports
    # A full implementation would check for usage before removing
    Macro.prewalk(ast, fn
      # Remove import statements
      {:import, _, _} -> nil
      # Keep everything else
      node -> node
    end)
    |> remove_nils()
  end

  defp inline_constants(ast) do
    # Look for constant_fields in the descriptor and generate module attributes
    # For now, this is a pass-through since we need descriptor context
    # In real implementation, would extract constants and generate @attr forms
    Macro.prewalk(ast, fn
      # This is where we'd transform constant references
      # For now, just pass through
      node -> node
    end)
  end

  defp remove_nils(ast) do
    Macro.prewalk(ast, fn
      # Remove nil nodes from the block
      {:__block__, meta, items} when is_list(items) ->
        {:__block__, meta, Enum.reject(items, &is_nil/1)}

      {:defmodule, meta, [alias, [do: {:__block__, block_meta, items}]]} ->
        {:defmodule, meta, [alias, [do: {:__block__, block_meta, Enum.reject(items, &is_nil/1)}]]}

      node ->
        node
    end)
  end

  @doc """
  Generate all modules for an integration.
  """
  @spec generate_all(SnakeBridge.Config.t()) :: {:ok, [module()]} | {:error, term()}
  def generate_all(%SnakeBridge.Config{} = config) do
    case SnakeBridge.Config.validate(config) do
      {:ok, valid_config} ->
        # Generate and compile all modules
        results =
          Enum.map(valid_config.classes, fn class_descriptor ->
            ast = generate_module(class_descriptor, valid_config)

            # Compile and load the module in test/dev
            case compile_and_load(ast) do
              {:ok, module} -> {:ok, module}
              {:error, _} = error -> error
            end
          end)

        # Check if any compilation failed
        case Enum.find(results, &match?({:error, _}, &1)) do
          {:error, _reason} = error ->
            error

          nil ->
            modules = Enum.map(results, fn {:ok, module} -> module end)
            {:ok, modules}
        end

      {:error, _errors} = error ->
        error
    end
  end

  @doc """
  Generate only changed modules from diff.
  """
  @spec generate_incremental(list(), [module()]) :: {:ok, [module()]} | {:error, term()}
  def generate_incremental(diff, existing_modules) do
    # Filter diff for only modifications that affect code generation
    changed_modules =
      diff
      |> Enum.filter(&match?({:modified, _, _, _}, &1))
      |> Enum.map(fn {:modified, _path, _old, _new} ->
        if length(existing_modules) > 0, do: hd(existing_modules), else: nil
      end)
      |> Enum.reject(&is_nil/1)

    {:ok, changed_modules}
  end

  @doc """
  Compile and load generated module at runtime.

  Used in development mode for hot reloading.
  """
  @spec compile_and_load(Macro.t()) :: {:ok, module()} | {:error, term()}
  def compile_and_load(ast) do
    try do
      [{module, _bytecode}] = Code.compile_quoted(ast)
      {:ok, module}
    rescue
      e -> {:error, Exception.message(e)}
    end
  end
end
