defmodule SnakeBridge.Generator do
  @moduledoc """
  Code generation engine for SnakeBridge.

  Generates Elixir modules from Python library descriptors using
  metaprogramming and AST manipulation.
  """

  @doc """
  Generate module AST from descriptor.

  Takes a class descriptor and configuration, returns quoted Elixir code
  that defines a module with create/execute functions.
  """
  @spec generate_module(map(), SnakeBridge.Config.t()) :: Macro.t()
  def generate_module(descriptor, config) do
    module_name = descriptor.elixir_module || Module.concat([DSPy, descriptor.name])
    python_path = descriptor.python_path
    methods = descriptor.methods || []

    quote do
      defmodule unquote(module_name) do
        @moduledoc unquote(generate_moduledoc(descriptor))

        @python_path unquote(python_path)
        @config unquote(Macro.escape(config))

        @type t :: {session_id :: String.t(), instance_id :: String.t()}

        @doc """
        Create a new instance of #{unquote(python_path)}.
        """
        @spec create(map(), keyword()) :: {:ok, t()} | {:error, term()}
        def create(args \\ %{}, opts \\ []) do
          session_id = Keyword.get(opts, :session_id, generate_session_id())

          # Placeholder for actual Snakepit integration
          {:ok, {session_id, "instance_#{:rand.uniform(1000)}"}}
        end

        unquote_splicing(generate_methods(methods))

        defp generate_session_id do
          "session_#{:rand.uniform(100_000)}"
        end
      end
    end
  end

  defp generate_moduledoc(descriptor) do
    docstring = Map.get(descriptor, :docstring, "")
    python_path = Map.get(descriptor, :python_path, "")

    """
    Elixir wrapper for #{python_path}.

    #{docstring}

    This module was automatically generated by SnakeBridge.
    """
  end

  defp generate_methods(methods) when is_list(methods) do
    Enum.map(methods, fn method ->
      method_name = method.name || method["name"]
      elixir_name = method.elixir_name || method["elixir_name"] || String.to_atom(method_name)
      streaming = method.streaming || method["streaming"] || false

      quote do
        @doc """
        Call #{unquote(method_name)} on the Python instance.

        Streaming: #{unquote(streaming)}
        """
        @spec unquote(elixir_name)(t(), map(), keyword()) :: {:ok, term()} | {:error, term()}
        def unquote(elixir_name)(instance_ref, args \\ %{}, opts \\ []) do
          # Placeholder for actual execution
          {:ok, %{"result" => "placeholder"}}
        end
      end
    end)
  end

  @doc """
  Optimize generated AST.

  Applies various optimization passes to improve generated code.
  """
  @spec optimize(Macro.t()) :: Macro.t()
  def optimize(ast) do
    ast
    |> remove_unused_imports()
    |> inline_constants()
  end

  defp remove_unused_imports(ast) do
    # Simple implementation - just return ast for now
    # Full implementation would analyze usage and remove unused imports
    ast
  end

  defp inline_constants(ast) do
    # Placeholder - would inline module attributes when possible
    ast
  end

  @doc """
  Generate all modules for an integration.
  """
  @spec generate_all(SnakeBridge.Config.t()) :: {:ok, [module()]} | {:error, term()}
  def generate_all(%SnakeBridge.Config{} = config) do
    case SnakeBridge.Config.validate(config) do
      {:ok, valid_config} ->
        modules =
          Enum.map(valid_config.classes, fn class_descriptor ->
            ast = generate_module(class_descriptor, valid_config)
            # In production, would compile and load the module
            # For now, just return the module name
            class_descriptor.elixir_module || Module.concat([Generated, Placeholder])
          end)

        {:ok, modules}

      {:error, _errors} = error ->
        error
    end
  end

  @doc """
  Generate only changed modules from diff.
  """
  @spec generate_incremental(list(), [module()]) :: {:ok, [module()]} | {:error, term()}
  def generate_incremental(diff, existing_modules) do
    # Filter diff for only modifications that affect code generation
    changed_modules =
      diff
      |> Enum.filter(&match?({:modified, _, _, _}, &1))
      |> Enum.map(fn {:modified, _path, _old, _new} ->
        if length(existing_modules) > 0, do: hd(existing_modules), else: nil
      end)
      |> Enum.reject(&is_nil/1)

    {:ok, changed_modules}
  end

  @doc """
  Compile and load generated module at runtime.

  Used in development mode for hot reloading.
  """
  @spec compile_and_load(Macro.t()) :: {:ok, module()} | {:error, term()}
  def compile_and_load(ast) do
    try do
      [{module, _bytecode}] = Code.compile_quoted(ast)
      {:ok, module}
    rescue
      e -> {:error, Exception.message(e)}
    end
  end
end
