defmodule SnakeBridge.Generator.Helpers do
  @moduledoc """
  Shared helper functions for code generation.

  Extracts common patterns used in module/function generation
  to reduce duplication.
  """

  alias SnakeBridge.TypeSystem.Mapper

  @doc """
  Convert Python module path to Elixir module name.

  ## Examples

      iex> Helpers.module_name("sympy.Symbol")
      Sympy.Symbol

      iex> Helpers.module_name("json")
      Json
  """
  @spec module_name(String.t()) :: module()
  def module_name(python_path) do
    Mapper.python_class_to_elixir_module(python_path)
  end

  @doc """
  Build a moduledoc string from a descriptor.

  ## Examples

      iex> Helpers.build_moduledoc(%{python_path: "sympy.Symbol", docstring: "Symbol constructor."})
      \"\"\"
      Elixir wrapper for sympy.Symbol.

      Symbol constructor.

      This module was automatically generated by SnakeBridge.
      \"\"\"
  """
  @spec build_moduledoc(map()) :: String.t()
  def build_moduledoc(descriptor) do
    docstring = get_field(descriptor, :docstring, "")
    python_path = get_field(descriptor, :python_path, "")

    """
    Elixir wrapper for #{python_path}.

    #{docstring}

    This module was automatically generated by SnakeBridge.
    """
  end

  @doc """
  Build a function docstring from method/function descriptor.
  """
  @spec build_function_doc(map(), map()) :: String.t()
  def build_function_doc(function_desc, _class_config \\ %{}) do
    name = get_field(function_desc, :name, "unknown")
    docstring = get_field(function_desc, :docstring, "")
    streaming = get_field(function_desc, :streaming, false)

    """
    Call #{name} on the Python instance.

    #{docstring}

    Streaming: #{streaming}
    """
  end

  @doc """
  Build typespec for a method based on its parameters and return type.

  Uses the TypeMapper to convert Python types to Elixir typespecs.
  """
  @spec build_typespec(atom(), list(), map() | nil, boolean()) :: Macro.t()
  def build_typespec(method_name, params, return_type, is_instance_method \\ true) do
    param_specs = build_param_specs(params)
    return_spec = build_return_spec(return_type)

    if is_instance_method do
      # Instance method: (t(), params..., opts) -> {:ok, return} | {:error, term()}
      quote do
        @spec unquote(method_name)(t(), unquote_splicing(param_specs), keyword()) ::
                {:ok, unquote(return_spec)} | {:error, term()}
      end
    else
      # Module function: (params..., opts) -> {:ok, return} | {:error, term()}
      quote do
        @spec unquote(method_name)(unquote_splicing(param_specs), keyword()) ::
                {:ok, unquote(return_spec)} | {:error, term()}
      end
    end
  end

  @doc """
  Build parameter specs from a list of parameter descriptors.
  """
  @spec build_param_specs(list()) :: [Macro.t()]
  def build_param_specs(params) when is_list(params) do
    params
    |> Enum.reject(fn p ->
      # Filter out 'self' and 'cls' parameters
      name = get_field(p, :name, "")
      name in ["self", "cls"]
    end)
    |> Enum.map(fn param ->
      type_desc = get_field(param, :type, %{})
      Mapper.to_elixir_spec(type_desc)
    end)
  end

  def build_param_specs(_), do: []

  @doc """
  Build return spec from a return type descriptor.
  """
  @spec build_return_spec(map() | nil) :: Macro.t()
  def build_return_spec(nil), do: quote(do: term())

  def build_return_spec(return_type) when is_map(return_type) do
    Mapper.to_elixir_spec(return_type)
  end

  def build_return_spec(_), do: quote(do: term())

  @doc """
  Generate session ID helper code.

  Returns a quoted expression for generating session IDs.
  """
  @spec session_id_code() :: Macro.t()
  def session_id_code do
    quote do
      defp generate_session_id do
        SnakeBridge.SessionId.generate("session")
      end
    end
  end

  @doc """
  Normalize an Elixir function name from a Python method name.

  Converts Python naming conventions to Elixir conventions:
  - `__call__` -> `:call`
  - `get_value` -> `:get_value`
  - `__init__` -> `:new`
  """
  @spec normalize_function_name(String.t(), atom() | nil) :: atom()
  def normalize_function_name(python_name, elixir_override \\ nil)

  def normalize_function_name(_python_name, elixir_name)
      when is_atom(elixir_name) and not is_nil(elixir_name) do
    elixir_name
  end

  def normalize_function_name("__call__", _), do: :call
  def normalize_function_name("__init__", _), do: :new
  def normalize_function_name("__str__", _), do: :to_string
  def normalize_function_name("__repr__", _), do: :inspect
  def normalize_function_name("__len__", _), do: :length
  def normalize_function_name("__iter__", _), do: :to_list

  def normalize_function_name(python_name, _) when is_binary(python_name) do
    String.to_atom(python_name)
  end

  @doc """
  Get a field from a descriptor, supporting both atom and string keys.
  """
  @spec get_field(map(), atom(), term()) :: term()
  def get_field(descriptor, key, default \\ nil) when is_map(descriptor) and is_atom(key) do
    Map.get(descriptor, key) || Map.get(descriptor, Atom.to_string(key)) || default
  end

  @doc """
  Extract parameters requiring user input (no default values).
  """
  @spec required_params(list()) :: list()
  def required_params(params) when is_list(params) do
    Enum.filter(params, fn p ->
      required = get_field(p, :required, true)
      name = get_field(p, :name, "")
      required and name not in ["self", "cls"]
    end)
  end

  @doc """
  Extract optional parameters (have default values).
  """
  @spec optional_params(list()) :: list()
  def optional_params(params) when is_list(params) do
    Enum.filter(params, fn p ->
      required = get_field(p, :required, true)
      name = get_field(p, :name, "")
      not required and name not in ["self", "cls"]
    end)
  end
end
