defmodule SnakeBridge.Manifest.Compiler do
  @moduledoc """
  Compile manifests into Elixir source files for compile-time loading.
  """

  alias SnakeBridge.{Generator, Manifest}

  @doc """
  Compile manifest files into source files under the output directory.
  """
  @spec compile_files([String.t()], String.t()) :: {:ok, [String.t()]} | {:error, term()}
  def compile_files(files, output_dir) when is_list(files) and is_binary(output_dir) do
    File.mkdir_p!(output_dir)

    outputs =
      files
      |> Enum.flat_map(fn file ->
        case Manifest.from_file(file) do
          {:ok, config} ->
            config
            |> Generator.generate_all_ast()
            |> Enum.map(&write_ast(&1, output_dir))

          {:error, reason} ->
            raise "Failed to load manifest #{file}: #{inspect(reason)}"
        end
      end)

    {:ok, outputs}
  rescue
    e -> {:error, e}
  end

  defp write_ast(ast, output_dir) do
    module = module_from_ast(ast)
    file_path = Path.join(output_dir, module_filename(module))
    File.mkdir_p!(Path.dirname(file_path))

    contents =
      ast
      |> Macro.to_string()
      |> Code.format_string!()
      |> IO.iodata_to_binary()

    header = "# Generated by mix snakebridge.manifest.compile\n\n"
    File.write!(file_path, header <> contents <> "\n")
    file_path
  end

  defp module_from_ast({:defmodule, _meta, [module_ast, _]}), do: module_from_ast(module_ast)
  defp module_from_ast({:__aliases__, _meta, parts}), do: Module.concat(parts)
  defp module_from_ast(module) when is_atom(module), do: module

  defp module_from_ast(other) do
    other
    |> Macro.to_string()
    |> String.trim_leading(":")
    |> String.split(".")
    |> Module.concat()
  end

  defp module_filename(module) when is_atom(module) do
    module
    |> Atom.to_string()
    |> String.replace_prefix("Elixir.", "")
    |> Macro.underscore()
    |> Kernel.<>(".ex")
  end
end
