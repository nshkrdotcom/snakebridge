{
  "category": "utilities",
  "description": "SnakeBridge adapter for sympy",
  "elixir_module": "SnakeBridge.Sympy",
  "functions": [
    {
      "args": [
        "expr",
        "settings"
      ],
      "doc": "Converts an expr to a string of the Wolfram Mathematica code\n\nExamples\n========\n\n>>> from sympy import mathematica_code as mcode, symbols, sin\n>>> x = symbols('x')\n>>> mcode(sin(x).series(x).removeO()",
      "name": "mathematica_code",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expr",
          "required": true
        },
        {
          "default": null,
          "kind": "var_keyword",
          "name": "settings",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "n",
        "limit",
        "use_trial",
        "use_rho",
        "use_pm1",
        "use_ecm",
        "verbose",
        "visual",
        "multiple"
      ],
      "doc": "Given a positive integer ``n``, ``factorint(n)`` returns a dict containing\nthe prime factors of ``n`` as keys and their respective multiplicities\nas values. For example:\n\n>>> from sympy.ntheory import",
      "name": "factorint",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "n",
          "required": true
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "limit",
          "required": false
        },
        {
          "default": "True",
          "kind": "positional_or_keyword",
          "name": "use_trial",
          "required": false
        },
        {
          "default": "True",
          "kind": "positional_or_keyword",
          "name": "use_rho",
          "required": false
        },
        {
          "default": "True",
          "kind": "positional_or_keyword",
          "name": "use_pm1",
          "required": false
        },
        {
          "default": "True",
          "kind": "positional_or_keyword",
          "name": "use_ecm",
          "required": false
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "verbose",
          "required": false
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "visual",
          "required": false
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "multiple",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "a",
        "locals",
        "convert_xor",
        "strict",
        "rational",
        "evaluate"
      ],
      "doc": "Converts an arbitrary expression to a type that can be used inside SymPy.\n\nExplanation\n===========\n\nIt will convert Python ints into instances of :class:`~.Integer`, floats\ninto instances of :class:`~",
      "name": "sympify",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "a",
          "required": true
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "locals",
          "required": false
        },
        {
          "default": "True",
          "kind": "positional_or_keyword",
          "name": "convert_xor",
          "required": false
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "strict",
          "required": false
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "rational",
          "required": false
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "evaluate",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "lhs",
        "rhs",
        "symbols",
        "exclude"
      ],
      "doc": "Return a tuple derived from ``f = lhs - rhs`` that is one of\nthe following: ``(0, 1)``, ``(0, 0)``, ``(symbol, solution)``, ``(n, d)``.\n\nExplanation\n===========\n\n``(0, 1)`` meaning that ``f`` is indep",
      "name": "solve_linear",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "lhs",
          "required": true
        },
        {
          "default": "0",
          "kind": "positional_or_keyword",
          "name": "rhs",
          "required": false
        },
        {
          "default": "[]",
          "kind": "positional_or_keyword",
          "name": "symbols",
          "required": false
        },
        {
          "default": "[]",
          "kind": "positional_or_keyword",
          "name": "exclude",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "args"
      ],
      "doc": "Tensor product among scalars or array-like objects.\n\nThe equivalent operator for array expressions is ``ArrayTensorProduct``,\nwhich can be used to keep the expression unevaluated.\n\nExamples\n========\n\n",
      "name": "tensorproduct",
      "params": [
        {
          "default": null,
          "kind": "var_positional",
          "name": "args",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "args",
        "expr",
        "modules",
        "printer",
        "use_imps",
        "dummify",
        "cse",
        "docstring_limit"
      ],
      "doc": "Convert a SymPy expression into a function that allows for fast\nnumeric evaluation.\n\n.. warning::\n   This function uses ``exec``, and thus should not be used on\n   unsanitized input.\n\n.. deprecated:: ",
      "name": "lambdify",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "args",
          "required": true
        },
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expr",
          "required": true
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "modules",
          "required": false
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "printer",
          "required": false
        },
        {
          "default": "True",
          "kind": "positional_or_keyword",
          "name": "use_imps",
          "required": false
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "dummify",
          "required": false
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "cse",
          "required": false
        },
        {
          "default": "1000",
          "kind": "positional_or_keyword",
          "name": "docstring_limit",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "expression",
        "interval",
        "symbol"
      ],
      "doc": "Return whether the function is strictly decreasing in the given interval.\n\nParameters\n==========\n\nexpression : Expr\n    The target function which is being checked.\ninterval : Set, optional\n    The ran",
      "name": "is_strictly_decreasing",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expression",
          "required": true
        },
        {
          "default": "Reals",
          "kind": "positional_or_keyword",
          "name": "interval",
          "required": false
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "symbol",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "seq",
        "dps"
      ],
      "doc": "Performs the Discrete Fourier Transform (**DFT**) in the complex domain.\n\nThe sequence is automatically padded to the right with zeros, as the\n*radix-2 FFT* requires the number of sample points to be ",
      "name": "ifft",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "seq",
          "required": true
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "dps",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "expr",
        "deep",
        "combine",
        "force",
        "measure"
      ],
      "doc": "Reduce expression by combining powers with similar bases and exponents.\n\nExplanation\n===========\n\nIf ``deep`` is ``True`` then powsimp() will also simplify arguments of\nfunctions. By default ``deep`` ",
      "name": "powsimp",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expr",
          "required": true
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "deep",
          "required": false
        },
        {
          "default": "'all'",
          "kind": "positional_or_keyword",
          "name": "combine",
          "required": false
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "force",
          "required": false
        },
        {
          "default": "<function count_ops at 0x799010129940>",
          "kind": "positional_or_keyword",
          "name": "measure",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "f",
        "x",
        "x0",
        "dir",
        "hyper",
        "order",
        "rational",
        "full"
      ],
      "doc": "Generates Formal Power Series of ``f``.\n\nExplanation\n===========\n\nReturns the formal series expansion of ``f`` around ``x = x0``\nwith respect to ``x`` in the form of a ``FormalPowerSeries`` object.\n\nF",
      "name": "fps",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "f",
          "required": true
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "x",
          "required": false
        },
        {
          "default": "0",
          "kind": "positional_or_keyword",
          "name": "x0",
          "required": false
        },
        {
          "default": "1",
          "kind": "positional_or_keyword",
          "name": "dir",
          "required": false
        },
        {
          "default": "True",
          "kind": "positional_or_keyword",
          "name": "hyper",
          "required": false
        },
        {
          "default": "4",
          "kind": "positional_or_keyword",
          "name": "order",
          "required": false
        },
        {
          "default": "True",
          "kind": "positional_or_keyword",
          "name": "rational",
          "required": false
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "full",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "f",
        "g",
        "gens",
        "args"
      ],
      "doc": "Compute polynomial pseudo-quotient of ``f`` and ``g``.\n\nExamples\n========\n\n>>> from sympy import pquo\n>>> from sympy.abc import x\n\n>>> pquo(x**2 + 1, 2*x - 4)\n2*x + 4\n>>> pquo(x**2 - 1, 2*x - 1)\n2*x +",
      "name": "pquo",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "f",
          "required": true
        },
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "g",
          "required": true
        },
        {
          "default": null,
          "kind": "var_positional",
          "name": "gens",
          "required": true
        },
        {
          "default": null,
          "kind": "var_keyword",
          "name": "args",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "expr",
        "settings"
      ],
      "doc": "Prints R representation of the given expression.",
      "name": "print_rcode",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expr",
          "required": true
        },
        {
          "default": null,
          "kind": "var_keyword",
          "name": "settings",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "r",
        "c",
        "min",
        "max",
        "seed",
        "symmetric",
        "percent",
        "prng"
      ],
      "doc": "Create random matrix with dimensions ``r`` x ``c``. If ``c`` is omitted\nthe matrix will be square. If ``symmetric`` is True the matrix must be\nsquare. If ``percent`` is less than 100 then only approxi",
      "name": "randMatrix",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "r",
          "required": true
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "c",
          "required": false
        },
        {
          "default": "0",
          "kind": "positional_or_keyword",
          "name": "min",
          "required": false
        },
        {
          "default": "99",
          "kind": "positional_or_keyword",
          "name": "max",
          "required": false
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "seed",
          "required": false
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "symmetric",
          "required": false
        },
        {
          "default": "100",
          "kind": "positional_or_keyword",
          "name": "percent",
          "required": false
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "prng",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "rv",
        "F",
        "atoms",
        "nonbasic"
      ],
      "doc": "Apply ``F`` to all expressions in an expression tree from the\nbottom up. If ``atoms`` is True, apply ``F`` even if there are no args;\nif ``nonbasic`` is True, try to apply ``F`` to non-Basic objects.",
      "name": "bottom_up",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "rv",
          "required": true
        },
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "F",
          "required": true
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "atoms",
          "required": false
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "nonbasic",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "expression",
        "interval",
        "symbol"
      ],
      "doc": "Return whether the function is monotonic in the given interval.\n\nParameters\n==========\n\nexpression : Expr\n    The target function which is being checked.\ninterval : Set, optional\n    The range of valu",
      "name": "is_monotonic",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expression",
          "required": true
        },
        {
          "default": "Reals",
          "kind": "positional_or_keyword",
          "name": "interval",
          "required": false
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "symbol",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "f",
        "gens"
      ],
      "doc": "Return the total_degree of ``f`` in the given variables.\n\nExamples\n========\n>>> from sympy import total_degree, Poly\n>>> from sympy.abc import x, y\n\n>>> total_degree(1)\n0\n>>> total_degree(x + x*y)\n2\n>",
      "name": "total_degree",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "f",
          "required": true
        },
        {
          "default": null,
          "kind": "var_positional",
          "name": "gens",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "n"
      ],
      "doc": "Test if n is a prime number (True) or not (False). For n < 2^64 the\nanswer is definitive; larger n values have a small probability of actually\nbeing pseudoprimes.\n\nNegative numbers (e.g. -2) are not c",
      "name": "isprime",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "n",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "expr"
      ],
      "doc": "Put an expression over a common denominator, cancel and reduce.\n\nExamples\n========\n\n>>> from sympy import ratsimp\n>>> from sympy.abc import x, y\n>>> ratsimp(1/x + 1/y)\n(x + y)/(x*y)",
      "name": "ratsimp",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expr",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "f",
        "gens",
        "args"
      ],
      "doc": "Compute Sturm sequence of ``f``.\n\nExamples\n========\n\n>>> from sympy import sturm\n>>> from sympy.abc import x\n\n>>> sturm(x**3 - 2*x**2 + x - 3)\n[x**3 - 2*x**2 + x - 3, 3*x**2 - 4*x + 1, 2*x/9 + 25/9, -",
      "name": "sturm",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "f",
          "required": true
        },
        {
          "default": null,
          "kind": "var_positional",
          "name": "gens",
          "required": true
        },
        {
          "default": null,
          "kind": "var_keyword",
          "name": "args",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "expr",
        "simplify",
        "force"
      ],
      "doc": "Convert a propositional logical sentence ``expr`` to conjunctive normal\nform: ``((A | ~B | ...) & (B | C | ...) & ...)``.\nIf ``simplify`` is ``True``, ``expr`` is evaluated to its simplest CNF\nform us",
      "name": "to_cnf",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expr",
          "required": true
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "simplify",
          "required": false
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "force",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "expr",
        "settings"
      ],
      "doc": "Converts an expr to a string of Python code\n\nParameters\n==========\n\nexpr : Expr\n    A SymPy expression.\nfully_qualified_modules : bool\n    Whether or not to write out full module names of functions\n  ",
      "name": "pycode",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expr",
          "required": true
        },
        {
          "default": null,
          "kind": "var_keyword",
          "name": "settings",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "expr",
        "assign_to",
        "standard",
        "settings"
      ],
      "doc": "C++ equivalent of :func:`~.ccode`. ",
      "name": "cxxcode",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expr",
          "required": true
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "assign_to",
          "required": false
        },
        {
          "default": "'c++11'",
          "kind": "positional_or_keyword",
          "name": "standard",
          "required": false
        },
        {
          "default": null,
          "kind": "var_keyword",
          "name": "settings",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "expr",
        "visual"
      ],
      "doc": "Return a representation (integer or expression) of the operations in expr.\n\nParameters\n==========\n\nexpr : Expr\n    If expr is an iterable, the sum of the op counts of the\n    items will be returned.\n\n",
      "name": "count_ops",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expr",
          "required": true
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "visual",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "f",
        "multiple",
        "radicals",
        "extension"
      ],
      "doc": "Returns the real roots of ``f`` with multiplicities.\n\nExplanation\n===========\n\nFinds all real roots of a univariate polynomial with rational coefficients\nof any degree exactly. The roots are represent",
      "name": "real_roots",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "f",
          "required": true
        },
        {
          "default": "True",
          "kind": "positional_or_keyword",
          "name": "multiple",
          "required": false
        },
        {
          "default": "True",
          "kind": "positional_or_keyword",
          "name": "radicals",
          "required": false
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "extension",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "args",
        "kwargs"
      ],
      "doc": "Compute the product.\n\nExplanation\n===========\n\nThe notation for symbols is similar to the notation used in Sum or\nIntegral. product(f, (i, a, b)) computes the product of f with\nrespect to i from a to ",
      "name": "product",
      "params": [
        {
          "default": null,
          "kind": "var_positional",
          "name": "args",
          "required": true
        },
        {
          "default": null,
          "kind": "var_keyword",
          "name": "kwargs",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "cls"
      ],
      "doc": "Return the arity of the function if it is known, else None.\n\nExplanation\n===========\n\nWhen default values are specified for some arguments, they are\noptional and the arity is reported as a tuple of po",
      "name": "arity",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "cls",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "n",
        "k",
        "method",
        "dps"
      ],
      "doc": "Zeros of the spherical Bessel function of the first kind.\n\nExplanation\n===========\n\nThis returns an array of zeros of $jn$ up to the $k$-th zero.\n\n* method = \"sympy\": uses `mpmath.besseljzero\n  <https",
      "name": "jn_zeros",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "n",
          "required": true
        },
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "k",
          "required": true
        },
        {
          "default": "'sympy'",
          "kind": "positional_or_keyword",
          "name": "method",
          "required": false
        },
        {
          "default": "15",
          "kind": "positional_or_keyword",
          "name": "dps",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "x",
        "n",
        "options"
      ],
      "doc": "Calls x.evalf(n, \\*\\*options).\n\nExplanations\n============\n\nBoth .n() and N() are equivalent to .evalf(); use the one that you like better.\nSee also the docstring of .evalf() for information on the opt",
      "name": "N",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "x",
          "required": true
        },
        {
          "default": "15",
          "kind": "positional_or_keyword",
          "name": "n",
          "required": false
        },
        {
          "default": null,
          "kind": "var_keyword",
          "name": "options",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "arg",
        "evaluate"
      ],
      "doc": "Returns the principal cube root.\n\nParameters\n==========\n\nevaluate : bool, optional\n    The parameter determines if the expression should be evaluated.\n    If ``None``, its value is taken from\n    ``gl",
      "name": "cbrt",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "arg",
          "required": true
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "evaluate",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "n",
        "verbose"
      ],
      "doc": "Calculate the partition function P(n), i.e. the number of ways that\nn can be written as a sum of positive integers.\n\n.. deprecated:: 1.13\n\n    The ``npartitions`` function is deprecated. Use :class:`s",
      "name": "npartitions",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "n",
          "required": true
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "verbose",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "expr"
      ],
      "doc": "Simplify expressions with gamma functions.\n\nExplanation\n===========\n\nThis function takes as input an expression containing gamma\nfunctions or functions that can be rewritten in terms of gamma\nfunction",
      "name": "gammasimp",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expr",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "f",
        "g",
        "gens",
        "args"
      ],
      "doc": "Invert ``f`` modulo ``g`` when possible.\n\nExamples\n========\n\n>>> from sympy import invert, S, mod_inverse\n>>> from sympy.abc import x\n\n>>> invert(x**2 - 1, 2*x - 1)\n-4/3\n\n>>> invert(x**2 - 1, x - 1)\nT",
      "name": "invert",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "f",
          "required": true
        },
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "g",
          "required": true
        },
        {
          "default": null,
          "kind": "var_positional",
          "name": "gens",
          "required": true
        },
        {
          "default": null,
          "kind": "var_keyword",
          "name": "args",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "expr"
      ],
      "doc": "Determine the outer indices of expression ``expr``\n\nBy *outer* we mean indices that are not summation indices.  Returns a set\nand a dict.  The set contains outer indices and the dict contains\ninformat",
      "name": "get_indices",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expr",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "expr",
        "syms",
        "func",
        "evaluate",
        "exact",
        "distribute_order_term"
      ],
      "doc": "Collect additive terms of an expression.\n\nExplanation\n===========\n\nThis function collects additive terms of an expression with respect\nto a list of expression up to powers with rational exponents. By ",
      "name": "collect",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expr",
          "required": true
        },
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "syms",
          "required": true
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "func",
          "required": false
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "evaluate",
          "required": false
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "exact",
          "required": false
        },
        {
          "default": "True",
          "kind": "positional_or_keyword",
          "name": "distribute_order_term",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "path",
        "expr",
        "func",
        "args",
        "kwargs"
      ],
      "doc": "Manipulate parts of an expression selected by a path.\n\nExplanation\n===========\n\nThis function allows to manipulate large nested expressions in single\nline of code, utilizing techniques to those applie",
      "name": "epath",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "path",
          "required": true
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "expr",
          "required": false
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "func",
          "required": false
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "args",
          "required": false
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "kwargs",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "p",
        "smallest"
      ],
      "doc": "Returns a primitive root of ``p`` or None.\n\nExplanation\n===========\n\nFor the definition of primitive root,\nsee the explanation of ``is_primitive_root``.\n\nThe primitive root of ``p`` exist only for\n`p ",
      "name": "primitive_root",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "p",
          "required": true
        },
        {
          "default": "True",
          "kind": "positional_or_keyword",
          "name": "smallest",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "cf"
      ],
      "doc": "Return an iterator over the convergents of a continued fraction (cf).\n\nThe parameter should be in either of the following to forms:\n- A list of partial quotients, possibly with the last element being ",
      "name": "continued_fraction_convergents",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "cf",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "f",
        "x",
        "index",
        "radicals",
        "expand"
      ],
      "doc": "An indexed root of a univariate polynomial.\n\nReturns either a :obj:`ComplexRootOf` object or an explicit\nexpression involving radicals.\n\nParameters\n==========\n\nf : Expr\n    Univariate polynomial.\nx : ",
      "name": "rootof",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "f",
          "required": true
        },
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "x",
          "required": true
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "index",
          "required": false
        },
        {
          "default": "True",
          "kind": "positional_or_keyword",
          "name": "radicals",
          "required": false
        },
        {
          "default": "True",
          "kind": "positional_or_keyword",
          "name": "expand",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "expr",
        "symbols",
        "points",
        "x0",
        "wrt",
        "evaluate"
      ],
      "doc": "Differentiate expr and replace Derivatives with finite differences.\n\nParameters\n==========\n\nexpr : expression\n\\*symbols : differentiate with respect to symbols\npoints: sequence, coefficient or undefin",
      "name": "differentiate_finite",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expr",
          "required": true
        },
        {
          "default": null,
          "kind": "var_positional",
          "name": "symbols",
          "required": true
        },
        {
          "default": "1",
          "kind": "keyword_only",
          "name": "points",
          "required": false
        },
        {
          "default": "None",
          "kind": "keyword_only",
          "name": "x0",
          "required": false
        },
        {
          "default": "None",
          "kind": "keyword_only",
          "name": "wrt",
          "required": false
        },
        {
          "default": "False",
          "kind": "keyword_only",
          "name": "evaluate",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "f",
        "gens",
        "auto",
        "cubics",
        "trig",
        "quartics",
        "quintics",
        "multiple",
        "filter",
        "predicate",
        "strict",
        "flags"
      ],
      "doc": "Computes symbolic roots of a univariate polynomial.\n\nGiven a univariate polynomial f with symbolic coefficients (or\na list of the polynomial's coefficients), returns a dictionary\nwith its roots and th",
      "name": "roots",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "f",
          "required": true
        },
        {
          "default": null,
          "kind": "var_positional",
          "name": "gens",
          "required": true
        },
        {
          "default": "True",
          "kind": "keyword_only",
          "name": "auto",
          "required": false
        },
        {
          "default": "True",
          "kind": "keyword_only",
          "name": "cubics",
          "required": false
        },
        {
          "default": "False",
          "kind": "keyword_only",
          "name": "trig",
          "required": false
        },
        {
          "default": "True",
          "kind": "keyword_only",
          "name": "quartics",
          "required": false
        },
        {
          "default": "False",
          "kind": "keyword_only",
          "name": "quintics",
          "required": false
        },
        {
          "default": "False",
          "kind": "keyword_only",
          "name": "multiple",
          "required": false
        },
        {
          "default": "None",
          "kind": "keyword_only",
          "name": "filter",
          "required": false
        },
        {
          "default": "None",
          "kind": "keyword_only",
          "name": "predicate",
          "required": false
        },
        {
          "default": "False",
          "kind": "keyword_only",
          "name": "strict",
          "required": false
        },
        {
          "default": null,
          "kind": "var_keyword",
          "name": "flags",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "expr",
        "assign_to",
        "settings"
      ],
      "doc": "Converts `expr` to a string of Octave (or Matlab) code.\n\nThe string uses a subset of the Octave language for Matlab compatibility.\n\nParameters\n==========\n\nexpr : Expr\n    A SymPy expression to be conv",
      "name": "octave_code",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expr",
          "required": true
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "assign_to",
          "required": false
        },
        {
          "default": null,
          "kind": "var_keyword",
          "name": "settings",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "n",
        "generator"
      ],
      "doc": "Return all divisors of n except n, sorted by default.\nIf generator is ``True`` an unordered generator is returned.\n\nExamples\n========\n\n>>> from sympy import proper_divisors, proper_divisor_count\n>>> p",
      "name": "proper_divisors",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "n",
          "required": true
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "generator",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "l",
        "dtype"
      ],
      "doc": "Converts Python list of SymPy expressions to a NumPy array.\n\nSee Also\n========\n\nmatrix2numpy",
      "name": "list2numpy",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "l",
          "required": true
        },
        {
          "default": "<class 'object'>",
          "kind": "positional_or_keyword",
          "name": "dtype",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "seq",
        "how"
      ],
      "doc": "Reshape the sequence according to the template in ``how``.\n\nExamples\n========\n\n>>> from sympy.utilities import reshape\n>>> seq = list(range(1, 9))\n\n>>> reshape(seq, [4]) # lists of 4\n[[1, 2, 3, 4], [5",
      "name": "reshape",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "seq",
          "required": true
        },
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "how",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "n",
        "x",
        "polys"
      ],
      "doc": "Generates n-th Swinnerton-Dyer polynomial in `x`.\n\nParameters\n----------\nn : int\n    `n` decides the order of polynomial\nx : optional\npolys : bool, optional\n    ``polys=True`` returns an expression, o",
      "name": "swinnerton_dyer_poly",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "n",
          "required": true
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "x",
          "required": false
        },
        {
          "default": "False",
          "kind": "positional_or_keyword",
          "name": "polys",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "F",
        "gens",
        "args"
      ],
      "doc": "Computes the reduced Groebner basis for a set of polynomials.\n\nUse the ``order`` argument to set the monomial ordering that will be\nused to compute the basis. Allowed orders are ``lex``, ``grlex`` and",
      "name": "groebner",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "F",
          "required": true
        },
        {
          "default": null,
          "kind": "var_positional",
          "name": "gens",
          "required": true
        },
        {
          "default": null,
          "kind": "var_keyword",
          "name": "args",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "f",
        "symbols",
        "kwargs"
      ],
      "doc": "Differentiate f with respect to symbols.\n\nExplanation\n===========\n\nThis is just a wrapper to unify .diff() and the Derivative class; its\ninterface is similar to that of integrate().  You can use the s",
      "name": "diff",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "f",
          "required": true
        },
        {
          "default": null,
          "kind": "var_positional",
          "name": "symbols",
          "required": true
        },
        {
          "default": null,
          "kind": "var_keyword",
          "name": "kwargs",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": false
    },
    {
      "args": [
        "expr",
        "against",
        "assume"
      ],
      "doc": "Checks whether assumptions of ``expr`` match the T/F assumptions\ngiven (or possessed by ``against``). True is returned if all\nassumptions match; False is returned if there is a mismatch and\nthe assump",
      "name": "check_assumptions",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "expr",
          "required": true
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "against",
          "required": false
        },
        {
          "default": null,
          "kind": "var_keyword",
          "name": "assume",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "pde",
        "sol",
        "func",
        "solve_for_func"
      ],
      "doc": "Checks if the given solution satisfies the partial differential\nequation.\n\npde is the partial differential equation which can be given in the\nform of an equation or an expression. sol is the solution ",
      "name": "checkpdesol",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "pde",
          "required": true
        },
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "sol",
          "required": true
        },
        {
          "default": "None",
          "kind": "positional_or_keyword",
          "name": "func",
          "required": false
        },
        {
          "default": "True",
          "kind": "positional_or_keyword",
          "name": "solve_for_func",
          "required": false
        }
      ],
      "returns": "any",
      "stateless": true
    },
    {
      "args": [
        "f",
        "gens",
        "args"
      ],
      "doc": "Compute a list of greatest factorial factors of ``f``.\n\nNote that the input to ff() and rf() should be Poly instances to use the\ndefinitions here.\n\nExamples\n========\n\n>>> from sympy import gff_list, f",
      "name": "gff_list",
      "params": [
        {
          "default": null,
          "kind": "positional_or_keyword",
          "name": "f",
          "required": true
        },
        {
          "default": null,
          "kind": "var_positional",
          "name": "gens",
          "required": true
        },
        {
          "default": null,
          "kind": "var_keyword",
          "name": "args",
          "required": true
        }
      ],
      "returns": "any",
      "stateless": true
    }
  ],
  "name": "sympy",
  "pypi_package": "sympy",
  "python_module": "sympy",
  "python_path_prefix": "sympy",
  "status": "experimental",
  "types": {
    "standard": "any",
    "use_trial": "any",
    "func": "any",
    "cf": "any",
    "filter": "any",
    "a": "any",
    "points": "any",
    "visual": "any",
    "dummify": "any",
    "assume": "any",
    "sol": "any",
    "trig": "any",
    "percent": "any",
    "syms": "any",
    "prng": "any",
    "expand": "any",
    "dtype": "any",
    "evaluate": "any",
    "rhs": "any",
    "index": "any",
    "printer": "any",
    "path": "any",
    "force": "any",
    "use_ecm": "any",
    "docstring_limit": "any",
    "gens": "any",
    "strict": "any",
    "seed": "any",
    "expr": "any",
    "measure": "any",
    "dir": "any",
    "multiple": "any",
    "arg": "any",
    "generator": "any",
    "how": "any",
    "flags": "any",
    "x": "any",
    "smallest": "any",
    "locals": "any",
    "f": "any",
    "method": "any",
    "min": "any",
    "cubics": "any",
    "combine": "any",
    "cse": "any",
    "assign_to": "any",
    "n": "any",
    "pde": "any",
    "kwargs": "any",
    "hyper": "any",
    "modules": "any",
    "symbols": "any",
    "distribute_order_term": "any",
    "limit": "any",
    "quartics": "any",
    "g": "any",
    "against": "any",
    "quintics": "any",
    "use_rho": "any",
    "convert_xor": "any",
    "F": "any",
    "p": "any",
    "extension": "any",
    "x0": "any",
    "wrt": "any",
    "l": "any",
    "use_imps": "any",
    "r": "any",
    "settings": "any",
    "seq": "any",
    "order": "any",
    "rv": "any",
    "deep": "any",
    "expression": "any",
    "full": "any",
    "k": "any",
    "nonbasic": "any",
    "cls": "any",
    "predicate": "any",
    "auto": "any",
    "max": "any",
    "options": "any",
    "solve_for_func": "any",
    "simplify": "any",
    "args": "any",
    "rational": "any",
    "symmetric": "any",
    "interval": "any",
    "lhs": "any",
    "c": "any",
    "exclude": "any",
    "verbose": "any",
    "symbol": "any",
    "use_pm1": "any",
    "radicals": "any",
    "atoms": "any",
    "exact": "any",
    "polys": "any",
    "dps": "any"
  },
  "version": null
}